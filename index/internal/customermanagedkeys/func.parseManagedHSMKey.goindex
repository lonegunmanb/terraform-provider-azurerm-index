package github.com/hashicorp/terraform-provider-azurerm/internal/customermanagedkeys
import (
	"fmt"

	"github.com/hashicorp/go-azure-sdk/sdk/environments"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	hsmParse "github.com/hashicorp/terraform-provider-azurerm/internal/services/managedhsm/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
)
func parseManagedHSMKey(keyRaw string, requireVersion VersionType, hsmEnv environments.Api) (
	versioned *hsmParse.ManagedHSMDataPlaneVersionedKeyId, versionless *hsmParse.ManagedHSMDataPlaneVersionlessKeyId, err error,
) {
	// if specified with hasVersion == True, then it has to be parsed as versionedKeyID
	var domainSuffix *string
	if hsmEnv != nil {
		domainSuffix, _ = hsmEnv.DomainSuffix()
	}

	switch requireVersion {
	case VersionTypeAny:
		if versioned, err = hsmParse.ManagedHSMDataPlaneVersionedKeyID(keyRaw, domainSuffix); err != nil {
			if versionless, err = hsmParse.ManagedHSMDataPlaneVersionlessKeyID(keyRaw, domainSuffix); err != nil {
				return nil, nil, fmt.Errorf("parse Managed HSM both versionedID and versionlessID err for %s", keyRaw)
			}
		}
	case VersionTypeVersioned:
		versioned, err = hsmParse.ManagedHSMDataPlaneVersionedKeyID(keyRaw, domainSuffix)
	case VersionTypeVersionless:
		versionless, err = hsmParse.ManagedHSMDataPlaneVersionlessKeyID(keyRaw, domainSuffix)
	}

	return versioned, versionless, err
}
