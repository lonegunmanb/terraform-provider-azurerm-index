package github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-fmt/rule
import (
	"fmt"
	"reflect"
	"regexp"
	"slices"
	"strconv"
	"strings"

	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-fmt/data"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-fmt/differror"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-fmt/markdown"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-fmt/template"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-fmt/util"
	log "github.com/sirupsen/logrus"
)
func (r S002) Run(rd *data.TerraformNodeData, fix bool) []error {
	if SkipRule(rd.Type, rd.Name, r.ID()) {
		return nil
	}

	if !rd.Document.Exists {
		return nil
	}

	errs := make([]error, 0)
	resourceTimeouts := timeoutSliceToMap(rd.Timeouts)

	var section *markdown.TimeoutsSection
	for _, sec := range rd.Document.Sections {
		if sec, ok := sec.(*markdown.TimeoutsSection); ok {
			section = sec
			break
		}
	}

	if len(resourceTimeouts) == 0 {
		// add an error?
		return errs
	}

	if section == nil {
		errs = append(errs, fmt.Errorf("%s: Missing Timeouts section", IdAndName(r)))

		if !fix {
			return errs
		}

		section = &markdown.TimeoutsSection{}
		content, err := template.Render(rd, section.Template())
		if err != nil {
			log.WithFields(log.Fields{
				"name": rd.Name,
				"type": rd.Type,
			}).Error(fmt.Errorf("%s: Failed to render template: %+v", IdAndName(r), err))
		}

		rd.Document.HasChange = true
		section.SetContent(content)
		sections, err := markdown.InsertAfterSection(section, rd.Document.Sections, &markdown.AttributesSection{})
		if err != nil {
			log.WithFields(log.Fields{
				"name": rd.Name,
				"type": rd.Type,
			}).Error(fmt.Errorf("%s: Failed to insert new templated section: %+v", IdAndName(r), err))
		}
		rd.Document.Sections = sections
	} else {
		content := section.GetContent()
		foundTimeouts := make(map[data.TimeoutType]int)
		timeoutBrandName := ""
		start, end := 0, 0

		for idx, line := range content {
			if partialTimeoutRegex.MatchString(line) {
				// track start and end of timeout lines, in case we need to insert a new timeout
				// we can insert at end and let the reorder func take care of the rest
				if start == 0 {
					start = idx
				}
				end = idx

				t := parseTimeout(line)
				if t == nil {
					errs = append(errs, fmt.Errorf("%s: Unable to parse timeout line (`%s`), this will require a manual fix", IdAndName(r), line))
					continue
				}
				timeoutBrandName = t.Name

				if _, ok := foundTimeouts[t.Type]; ok {
					errs = append(errs, fmt.Errorf("%s: Documentation contains a duplicate timeout", IdAndName(r)))

					if fix {
						rd.Document.HasChange = true
						content = slices.Delete(content, idx, idx+1)
						section.SetContent(content)
						continue
					}
				}
				foundTimeouts[t.Type] = idx

				if _, ok := resourceTimeouts[t.Type]; !ok {
					errs = append(errs, fmt.Errorf("%s: Documentation contains a timeout (%s) that is not present in the %s", IdAndName(r), t.Type, rd.Type))

					if fix {
						rd.Document.HasChange = true
						content = slices.Delete(content, idx, idx+1)
						section.SetContent(content)
						continue
					}

					return errs
				}

				expectedTimeout := resourceTimeouts[t.Type]
				expectedTimeout.Name = t.Name

				expected := expectedTimeout.String()

				if line != expected {
					errs = append(errs, differror.New(fmt.Sprintf("%s: Timeout line for `%s` not in expected format", IdAndName(r), t.Type), line, expected))

					if fix {
						rd.Document.HasChange = true
						content[idx] = expected
						section.SetContent(content)
					}
				}
			}
		}

		for _, t := range rd.Timeouts {
			if _, ok := foundTimeouts[t.Type]; !ok {
				errs = append(errs, fmt.Errorf("%s: Timeout line for `%s` missing in the documentation", IdAndName(r), t.Type))

				if fix {
					if timeoutBrandName != "" {
						t.Name = timeoutBrandName
					}
					rd.Document.HasChange = true
					content = slices.Insert(content, end+1, t.String())
					foundTimeouts[t.Type] = end + 1
					section.SetContent(content)
				}
			}
		}

		var orderChanged bool
		content, orderChanged = reorderTimeouts(content, foundTimeouts)
		if orderChanged {
			errs = append(errs, fmt.Errorf("%s: Timeouts are not ordered as expected (CRUD)", IdAndName(r)))

			if fix {
				rd.Document.HasChange = true
				section.SetContent(content)
			}
		}
	}

	return errs
}
