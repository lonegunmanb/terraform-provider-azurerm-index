package github.com/hashicorp/terraform-provider-azurerm/internal/tools/scaff/commands
import (
	"errors"
	"flag"
	"fmt"
	"log"
	"os"
	"os/exec"
	"strings"
	"text/template"

	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/templatehelpers"
	"github.com/mitchellh/cli"
)
func (d *resourceData) parseArgs(args []string) (errs []error) {
	argSet := flag.NewFlagSet("resource", flag.ExitOnError)

	argSet.StringVar(&d.Name, "name", "", "(Required) the name of the resource to scaffold the resource for.")
	argSet.StringVar(&d.ServicePackageName, "service_package_name", "", "(Required) the name of the service package to scaffold the resource into.")
	argSet.StringVar(&d.RPName, "rp_name", "", "(Required) the name of the resource provider of the new resource.")
	argSet.StringVar(&d.ClientName, "client_name", "", "(Required) the name of the client used to manage the new resource.")
	argSet.StringVar(&d.APIVersion, "api_version", "", "(Required) the API version of the resource to scaffold. e.g. 2025-01-01")
	argSet.StringVar(&d.IdType, "id_type", "", "(Required) the type of resource to scaffold. e.g. `commonids.AppServiceId`, or `virtualmachines.VirtualMachineId`.")
	argSet.StringVar(&d.IdSegments, "id_segments", "", "(Required) The User-Specified Segment names for the ID, Order matters. Future versions of this command will discover this from the id_type value, I hope...")
	argSet.BoolVar(&d.Updatable, "updatable", false, "(Optional) whether the new resource can be updated. i.e. any schema property is not going to be `ForceNew`.")
	argSet.BoolVar(&d.UsesLROCRUD, "uses_lro_crud", false, "(Optional) the new resource uses LROs for Create, Update, and Delete.")
	argSet.BoolVar(&d.UseCreateOptions, "use_create_options", false, "(Optional) the new resource uses OperationOptions for Create.")
	argSet.BoolVar(&d.UseReadOptions, "use_read_options", false, "(Optional) the new resource uses OperationOptions for Read.")
	argSet.BoolVar(&d.UseUpdateOptions, "use_update_options", false, "(Optional) the new resource uses OperationOptions for Update.")
	argSet.BoolVar(&d.UseDeleteOptions, "use_delete_options", false, "(Optional) the new resource uses OperationOptions for Delete.")
	argSet.BoolVar(&d.ConfigValidators, "config_validators", false, "(Optional) does the resource have configuration validators.")
	argSet.BoolVar(&d.NoResourceGroup, "no_resource_group", false, "(Optional) Set to true if the resource is not created in a resource group, or if the RG is inferred from a parent resource ID.")
	argSet.StringVar(&d.SDKName, "sdk_name", "", "(Optional) the name of the SDK used to manage the new resource. If omitted, the first slug of the id_type value will be used.")
	if err := argSet.Parse(args); err != nil {
		errs = append(errs, err)
		return
	}

	switch {
	case d.Name == "":
		errs = append(errs, errors.New("resource name is required"))
	case d.ServicePackageName == "":
		errs = append(errs, errors.New("service package name is required"))
	case d.RPName == "":
		errs = append(errs, errors.New("resource name is required"))
	case d.ClientName == "":
		errs = append(errs, errors.New("client name is required"))
	case d.APIVersion == "":
		errs = append(errs, errors.New("api version is required"))
	case d.IdType == "":
		errs = append(errs, errors.New("id_type is required"))
	case d.IdSegments == "":
		errs = append(errs, errors.New("id_segments is required"))
	}

	d.IdTypeParts = strings.Split(d.IdType, ".")
	if l := len(d.IdTypeParts); l != 2 {
		errs = append(errs, fmt.Errorf("id_type has incorrect number of segments, expected 2 got %d", l))
	}

	d.IDSegments = strings.Split(d.IdSegments, ",")
	d.SegmentCount = len(d.IDSegments) - 1

	for idx, segment := range d.IDSegments {
		switch {
		case idx == len(d.IDSegments)-1:
			d.ResourceIdentitySegments = append(d.ResourceIdentitySegments, "Name")
		default:
			d.ResourceIdentitySegments = append(d.ResourceIdentitySegments, segment)
		}
	}

	return errs
}
