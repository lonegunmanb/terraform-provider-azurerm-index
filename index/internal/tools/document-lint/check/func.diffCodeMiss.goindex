package github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/check
import (
	"fmt"
	"strconv"
	"strings"

	schema2 "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/md"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/model"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/schema"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/util"
)
func diffCodeMiss(rt, path string, f *model.Field, s *schema2.Schema) (res []Checker) {
	if shouldSkipCodeProp(rt, path) {
		return res
	}
	if isSkipProp(rt, path) {
		return res
	}

	if f != nil && f.FormatErr != "" {
		if strings.Contains(f.FormatErr, md.BlcokNotDefined) && s != nil {
			// document line mark as block but to block defined in the document.
			// if schema is not a block neither, then should update the document
			if _, ok := s.Elem.(*pluginsdk.Resource); !ok {
				f.FormatErr = md.IncorrectlyBlockMarked
			}
		}
		if strings.Contains(f.FormatErr, "misspell of name from") {
			res = append(res, newPropertyMiss(newCheckBase(f.Line, path, f), Misspelling))
		} else {
			res = append(res, newFormatErr(f.Content, f.FormatErr, newCheckBase(f.Line, path, f)))
		}
		return res
	}

	if s == nil {
		if path != "id" && f != nil { // id not defined in code
			if strings.TrimSpace(path) == "" {
				path = fmt.Sprintf("%s:L%d", f.Name, f.Line)
			}
			if strings.Contains(strings.ToLower(f.Content), "deprecated") {
				path += " deprecated"
			}
			// not available for some block
			if idx := strings.Index(strings.ToLower(f.Content), "not available for"); idx > 0 {
				if code := util.FirstCodeValue(f.Content[idx:]); code != "" && strings.Contains(path, code) {
					return res
				}
			}
			res = append(res, newMissInCode(path, f))
		}
		return res
	}

	if f == nil {
		return nil
	}
	base := newCheckBase(f.Line, path, f)

	// check optional. optional&computed property diff
	if (f.Required != model.Required) && s.Required {
		res = append(res, newRequireDiff(base, ShouldBeRequired))
	} else if s.Optional {
		if f.Required != model.Optional && f.Pos == model.PosArgs {
			res = append(res, newRequireDiff(base, ShouldBeOptional))
		}
		if s.Computed {
			// optional and computed, but not in attribute part
			if f.SameNameAttr != nil && f.SameNameAttr.Required > 0 && f.SameNameAttr.Pos == model.PosAttr { // attribute should not have requriedness spec
				// there are maybe more than one entry for a field
				// (like azurerm_kubernetes_cluster_node_pool),
				// only set ShouldBeComputed for Attributes
				base2 := newCheckBase(f.SameNameAttr.Line, path, f.SameNameAttr)
				res = append(res, newRequireDiff(base2, ShouldBeComputed))
			}
		}
	}

	// check default values
	if s.Default != nil {
		defaultStr := fmt.Sprintf("%v", s.Default)
		if str, ok := s.Default.(string); ok && str == "" {
			defaultStr = `""` // empty string in code
		}
		shouldSkip := func() bool {
			if defaultStr == f.Default {
				return true
			}
			if defaultStr == "false" && f.Default == "" {
				return true
			}
			return false
		}()
		// for many default value is `false`, just skip them for now
		if !shouldSkip {
			// maybe numbers: convert to number and compare
			if defNum, e1 := strconv.ParseFloat(defaultStr, 64); e1 == nil {
				if fNum, e2 := strconv.ParseFloat(f.Default, 64); e2 == nil {
					if int(defNum) != int(fNum) {
						res = append(res, newDefaultDiff(base, f.Default, defaultStr))
					}
				}
			} else {
				res = append(res, newDefaultDiff(base, f.Default, defaultStr))
			}
		}
	} else if f.Default != "" && !s.Computed {
		// schema has no default, but the document has default value, then we need a diff item
		// but if schema is a boolean type and the document has a false default value, it's fine
		if s.Type != pluginsdk.TypeBool || f.Default != "false" {
			res = append(res, newDefaultDiff(base, f.Default, ""))
		}
	}

	// check forceNew attribute
	if s.ForceNew != f.ForceNew && f.Name != "resource_group_name" {
		forceNew := ForceNewDefault
		if s.ForceNew && !f.ForceNew {
			forceNew = ShouldBeForceNew
		} else if f.ForceNew && !s.ForceNew {
			forceNew = ShouldBeNotForceNew
		}
		res = append(res, newForceNewDiff(base, forceNew))
	}

	// if code schema is not list/set and md field is attr, then skip iterate sub-fields even exists
	// for we guess a md property as block if not found other block-type properties
	if s.Type != schema2.TypeList && f.Typ == model.FieldTypeAttr {
		return res
	}

	var subRes *schema2.Resource
	if res, ok := s.Elem.(*schema2.Resource); ok {
		subRes = res
	}
	// doc has sub-field but schema has no
	subTF := func(name string) *schema2.Schema {
		if subRes == nil || subRes.Schema == nil {
			return nil
		}
		return subRes.Schema[name]
	}

	for _, subField := range f.Subs {
		subPath := path + "." + subField.Name
		sub := subTF(subField.Name)
		res = append(res, diffCodeMiss(rt, subPath, subField, sub)...)
	}

	return res
}
