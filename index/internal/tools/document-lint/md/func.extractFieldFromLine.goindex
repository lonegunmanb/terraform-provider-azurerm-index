package github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/md
import (
	"log"
	"regexp"
	"strings"

	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/model"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/util"
)
func extractFieldFromLine(line string) (field *model.Field) {
	field = &model.Field{
		Content: line,
	}
	// if defautl exists
	field.Default = getDefaultValue(line)
	field.ForceNew = isForceNew(line)

	res := fieldReg.FindStringSubmatch(line)
	if len(res) <= 1 || res[1] == "" {
		field.Name = util.FirstCodeValue(line) // try to use the first code as name
		field.FormatErr = "no field name found"
		return field
	}
	field.Name = res[1]
	if field.Name == "" {
		log.Printf("field name is empty")
	}
	if len(res) > 2 {
		// may not exist
		switch {
		case strings.Contains(line, "(Required)"):
			field.Required = model.Required
		case strings.Contains(line, "(Optional)"):
			field.Required = model.Optional
		case strings.Contains(line, "Required"):
			field.Required = model.Required
		case strings.Contains(line, "Optional"):
			field.Required = model.Optional
		}
	}

	possibleValueSep := func(line string) int {
		line = strings.ToLower(line)
		for _, sep := range []string{
			"possible value", "must be one of", "be one of", "allowed value", "valid value",
			"supported value", "valid option", "accepted value",
		} {
			if sepIdx := strings.Index(line, sep); sepIdx >= 0 {
				return sepIdx
			}
		}
		return -1
	}

	var enums []string
	if len(res) > 3 {
		// extract enums from code part
		// from possible value to first '.'
		// skip if there are more than one sep exists
		// do not check the possible part
		if sepIdx := possibleValueSep(line); sepIdx > 0 {
			subStr := line[sepIdx:]
			field.EnumStart = sepIdx
			// end with dot may not work in values like `7.2` ....
			// should be . not in ` mark
			// Possible values are `a`, `b`, `a.b` and `def`.
			pointEnd := strings.Index(subStr, ".")
			if pointEnd < 0 {
				pointEnd = len(subStr)
			}
			enumIndex := codeReg.FindAllStringIndex(subStr, -1)
			for idx, val := range enumIndex {
				_ = idx
				start, end := val[0], val[1]
				if pointEnd > start && pointEnd < end {
					// point inside the code block
					if pointEnd = strings.Index(subStr[end:], "."); pointEnd < 0 {
						pointEnd = len(subStr)
					} else {
						pointEnd += end
					}
				}
				// search end to a dot
				if pointEnd < start {
					break
				}
				enums = append(enums, strings.Trim(subStr[start:end], "`'\""))
				field.EnumEnd = sepIdx + end
			}
			// breaks if there are more than 1 possible value
			if sepIdx = possibleValueSep(line[sepIdx+1:]); sepIdx >= 0 {
				field.Skip = true
			}
		}
		if len(enums) == 0 && strings.Index(res[3], "`") > 0 {
			guessValues := codeReg.FindAllString(res[3], -1)
			field.SetGuessEnums(guessValues)
		}
	}
	field.AddEnum(enums...)
	return field
}
