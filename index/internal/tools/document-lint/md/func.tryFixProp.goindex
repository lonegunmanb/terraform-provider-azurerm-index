package github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/md
import (
	"os"
	"regexp"
	"strings"
	"unicode"

	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/document-lint/model"
)
func tryFixProp(line string) string {
	if strings.HasPrefix(line, "**") {
		return "~> " + line
	}
	if reqIdx := requireIndex(line); reqIdx > 0 {
		if !strings.HasSuffix(strings.TrimSpace(line[:reqIdx]), "-") {
			line = line[:reqIdx] + "- " + line[reqIdx:]
			reqIdx += 2
		}

		// a blank character before requiredness
		if divIdx := strings.Index(line[:reqIdx], "-"); divIdx > 0 {
			if ch := line[divIdx-1]; ch != ' ' {
				if unicode.IsSpace(rune(ch)) {
					line = line[:divIdx-1] + " " + line[divIdx:]
				} else {
					line = line[:divIdx] + " " + line[divIdx:]
				}
				divIdx += 1
			}
			if ch := line[divIdx+1]; ch != ' ' {
				if unicode.IsSpace(rune(ch)) {
					line = line[:divIdx+1] + " " + line[divIdx+2:]
				} else {
					line = line[:divIdx+1] + " " + line[divIdx+1:]
				}
			}
		}
	}
	// Skip adding dashes for note sections
	if !strings.HasPrefix(line, "~>") && !strings.HasPrefix(line, "->") && !strings.HasPrefix(line, "!>") {
		// need a dash after property name
		idx := strings.Index(line, "`")
		if idx += strings.Index(line[idx+1:], "`") + 1; idx > 0 {
			for idx2 := idx + 1; idx2 < len(line); idx2++ {
				if line[idx2] == ' ' {
					continue
				}
				if line[idx2] != '-' {
					line2 := line[:idx+2]
					if line[idx2-1] != ' ' {
						line2 += " "
					}
					line2 += "- "
					line2 += line[idx2:]
					line = line2
					break
				} else {
					// if line[idx2] == '-'  exists
					if line[idx2-1] != ' ' {
						line = line[:idx2] + " " + line[idx2:]
					}
					if line[idx2+1] != ' ' {
						line = line[:idx2+1] + " " + line[idx2+1:]
					}
					break
				}
			}
		}
	}

	// add ` to default value
	if vals := defaultValueReg.FindStringSubmatchIndex(line); len(vals) > 0 {
		// add a backquote to value
		valStr := line[vals[2]:vals[3]]
		line = line[:vals[2]] + "`" + valStr + "`" + line[vals[3]:]
	}

	// need a blank
	if tryBlockPropReg.MatchString(line) {
		if !strings.Contains(line, "below") && !strings.Contains(line, "above") {
			line = strings.TrimSuffix(line, ".")
			line += " as defined below."
		}
	}

	return line
}
