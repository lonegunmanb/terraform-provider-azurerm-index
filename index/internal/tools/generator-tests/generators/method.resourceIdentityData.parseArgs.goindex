package github.com/hashicorp/terraform-provider-azurerm/internal/tools/generator-tests/generators
import (
	"flag"
	"fmt"
	"log"
	"os"
	"strings"
	"text/template"

	"github.com/hashicorp/terraform-provider-azurerm/internal/tools/templatehelpers"
	"github.com/mitchellh/cli"
)
func (d *resourceIdentityData) parseArgs(args []string) (errors []error) {
	argSet := flag.NewFlagSet("ri", flag.ExitOnError)

	argSet.StringVar(&d.ResourceName, "resource-name", "", "(Required) the name of the resource to generate the resource identity test for.")
	argSet.StringVar(&d.IdentityProperties, "properties", "", "(Required) a comma separated list of schema property names that make up the resource identity for this resource. Do not include 'known' values here, only schema comparisons are supported.")
	argSet.StringVar(&d.ServicePackageName, "service-package-name", "", "(Required) the path to the directory containing the service package to write the generated test to.")
	argSet.StringVar(&d.BasicTestParams, "test-params", "", "(Optional) comma separated list of additional properties that need to be passed to the basic test config for this resource.")
	argSet.StringVar(&d.KnownValues, "known-values", "", "(Optional) comma separated list of known (aka discriminated) value names and their values for this resource type, formatted as [attribute_name]:[attribute value]. e.g. `kind:linux;functionapp,foo:bar`")
	argSet.StringVar(&d.CompareValues, "compare-values", "", "(Optional) comma separated list of resource identity names that are contained within a schema property value, formatted as [attribute_name]:[attribute value]. e.g. `parent_name:parent_resource_id;resource_group_name,parent_resource_id`")
	argSet.StringVar(&d.TestName, "test-name", "basic", "(Optional) the name of the config that will be used to test Resource Identity. Defaults to `basic`.")

	if err := argSet.Parse(args); err != nil {
		errors = append(errors, err)
		return
	}

	// check we have the essentials
	switch {
	case d.ResourceName == "":
		errors = append(errors, fmt.Errorf("resource name is required"))
	case d.ServicePackageName == "":
		errors = append(errors, fmt.Errorf("service-package-path is required"))
	}

	// d.PropertyNameMap = strings.Split(d.IdentityProperties, ",")
	if len(d.IdentityProperties) > 0 {
		d.PropertyNameMap = map[string]string{}
		propertiesList := strings.Split(d.IdentityProperties, ",")
		for _, property := range propertiesList {
			v := strings.Split(property, ":")
			switch len(v) {
			case 1:
				d.PropertyNameMap[v[0]] = v[0]
			case 2:
				d.PropertyNameMap[v[0]] = v[1]
			default:
				errors = append(errors, fmt.Errorf("invalid property name: %s", property))
				return
			}
		}
	}

	if len(d.BasicTestParams) > 0 {
		d.TestParams = strings.Split(d.BasicTestParams, ",")
	}

	if len(d.KnownValues) > 0 {
		d.KnownValueMap = make(map[string]string)
		kv := strings.Split(d.KnownValues, ",")
		// if len(kv)%2 != 0 {
		// 	errors = append(errors, fmt.Errorf("known-values must be a list of an even number of name/values (comma separated values should be represented with semi-colon for replacement later) e.g. 'var1:val1,var2:val2;val3'"))
		// }

		for _, v := range kv {
			vParts := strings.Split(v, ":")
			if len(vParts) != 2 {
				errors = append(errors, fmt.Errorf("invalid property format in known-values: '%s'", v))
				return
			}
			d.KnownValueMap[vParts[0]] = strings.ReplaceAll(vParts[1], ";", ",")
		}
	}

	if len(d.CompareValues) > 0 {
		d.CompareValueMap = make(map[string]string)
		kv := strings.Split(d.CompareValues, ",")

		for _, v := range kv {
			vParts := strings.Split(v, ":")
			if len(vParts) != 2 {
				errors = append(errors, fmt.Errorf("invalid property format in known-values: '%s'", v))
				return
			}
			d.CompareValueMap[vParts[0]] = strings.ReplaceAll(vParts[1], ";", ",")
		}
	}

	return
}
