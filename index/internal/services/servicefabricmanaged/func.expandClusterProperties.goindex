package github.com/hashicorp/terraform-provider-azurerm/internal/services/servicefabricmanaged
import (
	"context"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-sdk/resource-manager/servicefabricmanagedcluster/2024-04-01/managedcluster"
	"github.com/hashicorp/go-azure-sdk/resource-manager/servicefabricmanagedcluster/2024-04-01/nodetype"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tags"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func expandClusterProperties(model *ClusterResourceModel) *managedcluster.ManagedClusterProperties {
	out := &managedcluster.ManagedClusterProperties{}

	addons := make([]managedcluster.ManagedClusterAddOnFeature, 0)
	if model.DNSService {
		addons = append(addons, managedcluster.ManagedClusterAddOnFeatureDnsService)
	}
	if model.BackupRestoreService {
		addons = append(addons, managedcluster.ManagedClusterAddOnFeatureBackupRestoreService)
	}
	out.AddonFeatures = &addons

	out.AdminPassword = utils.String(model.Password)
	out.AdminUserName = model.Username

	out.DnsName = model.Name
	if model.DNSName != "" && model.DNSName != model.Name {
		out.DnsName = model.DNSName
	}

	if v := model.SubnetId; v != "" {
		out.SubnetId = pointer.To(v)
	}

	if auth := model.Authentication; len(auth) > 0 {
		if adAuth := auth[0].ADAuth; len(adAuth) > 0 {
			if adAuth[0].ClientApp != "" && adAuth[0].ClusterApp != "" && adAuth[0].TenantId != "" {
				out.AzureActiveDirectory = &managedcluster.AzureActiveDirectory{
					ClientApplication:  utils.String(adAuth[0].ClientApp),
					ClusterApplication: utils.String(adAuth[0].ClusterApp),
					TenantId:           utils.String(adAuth[0].TenantId),
				}
			}
		}
		if certs := auth[0].CertAuthentication; len(certs) > 0 {
			clients := make([]managedcluster.ClientCertificate, len(certs))
			for idx, cert := range certs {
				clients[idx] = managedcluster.ClientCertificate{
					CommonName: utils.String(cert.CommonName),
					IsAdmin:    cert.CertificateType == CertTypeAdmin,
					Thumbprint: utils.String(cert.Thumbprint),
				}
			}
			out.Clients = &clients
		}
	}

	out.ClientConnectionPort = &model.ClientConnectionPort
	out.ClusterUpgradeCadence = &model.UpgradeWave

	if customSettings := model.CustomFabricSettings; len(customSettings) > 0 {
		// First we build a map of all settings per section
		fsMap := make(map[string][]managedcluster.SettingsParameterDescription)
		for _, cs := range customSettings {
			spd := managedcluster.SettingsParameterDescription{
				Name:  cs.Parameter,
				Value: cs.Value,
			}
			fsMap[cs.Section] = append(fsMap[cs.Section], spd)
		}

		// Then we update the properties struct
		fs := make([]managedcluster.SettingsSectionDescription, 0)
		for k, v := range fsMap {
			fs = append(fs, managedcluster.SettingsSectionDescription{
				Name:       k,
				Parameters: v,
			})
		}
		out.FabricSettings = &fs
	}

	out.HTTPGatewayConnectionPort = &model.HTTPGatewayPort

	if rules := model.LBRules; len(rules) > 0 {
		lbRules := make([]managedcluster.LoadBalancingRule, len(rules))
		nsRules := make([]managedcluster.NetworkSecurityRule, len(rules))

		for idx, rule := range rules {
			lbRules[idx] = managedcluster.LoadBalancingRule{
				BackendPort:      rule.BackendPort,
				FrontendPort:     rule.FrontendPort,
				ProbeProtocol:    rule.ProbeProtocol,
				ProbeRequestPath: utils.String(rule.ProbeRequestPath),
				Protocol:         rule.Protocol,
			}

			fePortStr := strconv.FormatInt(rule.FrontendPort, 10)
			var sgProto managedcluster.NsgProtocol
			switch rule.Protocol {
			case managedcluster.ProtocolTcp:
				sgProto = managedcluster.NsgProtocolTcp
			case managedcluster.ProtocolUdp:
				sgProto = managedcluster.NsgProtocolUdp
			}
			nsRules[idx] = managedcluster.NetworkSecurityRule{
				Access:                     managedcluster.AccessAllow,
				SourceAddressPrefixes:      &[]string{"0.0.0.0/0"},
				SourcePortRanges:           &[]string{"1-65535"},
				DestinationPortRanges:      &[]string{fePortStr},
				DestinationAddressPrefixes: &[]string{"0.0.0.0/0"},
				Direction:                  managedcluster.DirectionInbound,
				Name:                       fmt.Sprintf("rule%d-allow-fe", rule.FrontendPort),
				Priority:                   1000,
				Protocol:                   sgProto,
			}
		}
		out.LoadBalancingRules = &lbRules
		out.NetworkSecurityRules = &nsRules
	}
	return out
}
