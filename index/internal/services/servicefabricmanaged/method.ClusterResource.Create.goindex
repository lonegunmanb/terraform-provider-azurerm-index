package github.com/hashicorp/terraform-provider-azurerm/internal/services/servicefabricmanaged
import (
	"context"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-sdk/resource-manager/servicefabricmanagedcluster/2024-04-01/managedcluster"
	"github.com/hashicorp/go-azure-sdk/resource-manager/servicefabricmanagedcluster/2024-04-01/nodetype"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tags"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func (k ClusterResource) Create() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			var model ClusterResourceModel
			if err := metadata.Decode(&model); err != nil {
				return fmt.Errorf("decoding %+v", err)
			}

			clusterClient := metadata.Client.ServiceFabricManaged.ManagedClusterClient
			nodeTypeClient := metadata.Client.ServiceFabricManaged.NodeTypeClient

			subscriptionId := metadata.Client.Account.SubscriptionId

			managedClusterId := managedcluster.NewManagedClusterID(subscriptionId, model.ResourceGroup, model.Name)
			cluster := managedcluster.ManagedCluster{
				Location:   model.Location,
				Name:       utils.String(model.Name),
				Properties: expandClusterProperties(&model),
				Sku:        managedcluster.Sku{Name: model.Sku},
			}

			tagsMap := make(map[string]string)
			for k, v := range model.Tags {
				tagsMap[k] = v.(string)
			}
			cluster.Tags = &tagsMap

			existing, err := clusterClient.Get(ctx, managedClusterId)
			if err != nil {
				if !response.WasNotFound(existing.HttpResponse) {
					return fmt.Errorf("while checking if cluster %q already exists: %+v", managedClusterId.String(), err)
				}
			} else {
				return metadata.ResourceRequiresImport("azurerm_service_fabric_managed_cluster", managedClusterId)
			}

			if err := clusterClient.CreateOrUpdateThenPoll(ctx, managedClusterId, cluster); err != nil {
				return fmt.Errorf("creating %s: %+v", managedClusterId, err)
			}

			toDelete := make([]string, 0)
			if metadata.ResourceData.HasChange("node_type") {
				o, n := metadata.ResourceData.GetChange("node_type")
				ont := o.([]interface{})
				nnt := n.([]interface{})

				for _, on := range ont {
					oldNodeType := on.(map[string]interface{})
					oldId := oldNodeType["name"].(string)
					found := false
					for _, nt := range nnt {
						newNodeType := nt.(map[string]interface{})
						newId := newNodeType["name"].(string)
						if oldId == newId {
							found = true
							break
						}
					}

					if !found {
						toDelete = append(toDelete, oldId)
					}
				}
			}

			// Delete the old Node Types
			for _, nodeType := range toDelete {
				nodeTypeId := nodetype.NewNodeTypeID(subscriptionId, model.ResourceGroup, model.Name, nodeType)
				if err := nodeTypeClient.DeleteThenPoll(ctx, nodeTypeId); err != nil {
					return fmt.Errorf("deleting %s: %+v", nodeTypeId, err)
				}
			}

			// Then provision the Node Types
			for _, nt := range model.NodeTypes {
				nodeTypeProperties, err := expandNodeTypeProperties(&nt)
				if err != nil {
					return fmt.Errorf("while expanding node type %q: %+v", nt.Name, err)
				}

				nodeTypeId := nodetype.NewNodeTypeID(subscriptionId, model.ResourceGroup, model.Name, nt.Name)
				payload := nodetype.NodeType{
					Properties: nodeTypeProperties,
				}
				if err := nodeTypeClient.CreateOrUpdateThenPoll(ctx, nodeTypeId, payload); err != nil {
					return fmt.Errorf("adding %s: %+v", nodeTypeId, err)
				}
			}

			metadata.SetID(managedClusterId)
			return nil
		},

		Timeout: 90 * time.Minute,
	}
}
