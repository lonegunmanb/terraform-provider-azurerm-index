package github.com/hashicorp/terraform-provider-azurerm/internal/services/postgres
import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/postgresql/2017-12-01/replicas"
	"github.com/hashicorp/go-azure-sdk/resource-manager/postgresql/2017-12-01/servers"
	"github.com/hashicorp/go-azure-sdk/resource-manager/postgresql/2017-12-01/serversecurityalertpolicies"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/postgres/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/postgres/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourcePostgreSQLServerCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Postgres.ServersClient
	securityClient := meta.(*clients.Client).Postgres.ServerSecurityAlertPoliciesClient
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	log.Printf("[INFO] preparing arguments for AzureRM PostgreSQL Server creation.")

	id := servers.NewServerID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))
	existing, err := client.Get(ctx, id)
	if err != nil {
		if !response.WasNotFound(existing.HttpResponse) {
			return fmt.Errorf("checking for presence of existing %s: %+v", id, err)
		}
	}

	if !response.WasNotFound(existing.HttpResponse) {
		return tf.ImportAsExistsError("azurerm_postgresql_server", id.ID())
	}

	mode := servers.CreateMode(d.Get("create_mode").(string))
	source := d.Get("creation_source_server_id").(string)
	version := servers.ServerVersion(d.Get("version").(string))

	sku, err := expandServerSkuName(d.Get("sku_name").(string))
	if err != nil {
		return fmt.Errorf("expanding `sku_name`: %+v", err)
	}

	infraEncrypt := servers.InfrastructureEncryptionEnabled
	if v := d.Get("infrastructure_encryption_enabled"); !v.(bool) {
		infraEncrypt = servers.InfrastructureEncryptionDisabled
	}

	publicAccess := servers.PublicNetworkAccessEnumEnabled
	if v := d.Get("public_network_access_enabled"); !v.(bool) {
		publicAccess = servers.PublicNetworkAccessEnumDisabled
	}

	ssl := servers.SslEnforcementEnumEnabled
	if v := d.Get("ssl_enforcement_enabled"); !v.(bool) {
		ssl = servers.SslEnforcementEnumDisabled
	}

	tlsMin := servers.MinimalTlsVersionEnum(d.Get("ssl_minimal_tls_version_enforced").(string))
	if ssl == servers.SslEnforcementEnumDisabled && tlsMin != servers.MinimalTlsVersionEnumTLSEnforcementDisabled {
		return fmt.Errorf("`ssl_minimal_tls_version_enforced` must be set to `TLSEnforcementDisabled` if `ssl_enforcement_enabled` is set to `false`")
	}

	storage := expandPostgreSQLStorageProfile(d)
	var props servers.ServerPropertiesForCreate
	switch mode {
	case servers.CreateModeDefault:
		admin := d.Get("administrator_login").(string)
		password := ""

		if v, ok := d.GetOk("administrator_login_password"); ok {
			password = v.(string)
		}
		woPassword, err := pluginsdk.GetWriteOnly(d, "administrator_login_password_wo", cty.String)
		if err != nil {
			return err
		}
		if !woPassword.IsNull() {
			password = woPassword.AsString()
		}

		if admin == "" {
			return fmt.Errorf("`administrator_login` must not be empty when `create_mode` is `Default`")
		}
		if password == "" {
			return fmt.Errorf("`administrator_login_password_wo` or `administrator_login_password` must be set when `create_mode` is `Default`")
		}

		if _, ok := d.GetOk("restore_point_in_time"); ok {
			return fmt.Errorf("`restore_point_in_time` cannot be set when `create_mode` is `Default`")
		}

		// check admin
		props = servers.ServerPropertiesForDefaultCreate{
			AdministratorLogin:         admin,
			AdministratorLoginPassword: password,
			InfrastructureEncryption:   &infraEncrypt,
			PublicNetworkAccess:        &publicAccess,
			MinimalTlsVersion:          &tlsMin,
			SslEnforcement:             &ssl,
			StorageProfile:             storage,
			Version:                    &version,
		}
	case servers.CreateModePointInTimeRestore:
		v, ok := d.GetOk("restore_point_in_time")
		if !ok || v.(string) == "" {
			return fmt.Errorf("restore_point_in_time must be set when create_mode is PointInTimeRestore")
		}

		props = &servers.ServerPropertiesForRestore{
			SourceServerId:           source,
			RestorePointInTime:       v.(string),
			InfrastructureEncryption: &infraEncrypt,
			MinimalTlsVersion:        &tlsMin,
			SslEnforcement:           &ssl,
			StorageProfile:           storage,
			Version:                  &version,
		}
	case servers.CreateModeGeoRestore:
		props = &servers.ServerPropertiesForGeoRestore{
			SourceServerId:           source,
			InfrastructureEncryption: &infraEncrypt,
			PublicNetworkAccess:      &publicAccess,
			MinimalTlsVersion:        &tlsMin,
			SslEnforcement:           &ssl,
			StorageProfile:           storage,
			Version:                  &version,
		}
	case servers.CreateModeReplica:
		props = &servers.ServerPropertiesForReplica{
			SourceServerId:           source,
			InfrastructureEncryption: &infraEncrypt,
			PublicNetworkAccess:      &publicAccess,
			MinimalTlsVersion:        &tlsMin,
			SslEnforcement:           &ssl,
			Version:                  &version,
		}
	}

	expandedIdentity, err := identity.ExpandSystemAssigned(d.Get("identity").([]interface{}))
	if err != nil {
		return fmt.Errorf("expanding `identity`: %+v", err)
	}
	server := servers.ServerForCreate{
		Identity:   expandedIdentity,
		Location:   location.Normalize(d.Get("location").(string)),
		Properties: props,
		Sku:        sku,
		Tags:       tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	if err = client.CreateThenPoll(ctx, id, server); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}

	log.Printf("[DEBUG] Waiting for %s to become available", id)
	stateConf := &pluginsdk.StateChangeConf{
		Pending:    []string{string(servers.ServerStateInaccessible)},
		Target:     []string{string(servers.ServerStateReady)},
		Refresh:    postgreSqlStateRefreshFunc(ctx, client, id),
		MinTimeout: 15 * time.Second,
		Timeout:    d.Timeout(pluginsdk.TimeoutCreate),
	}

	if _, err = stateConf.WaitForStateContext(ctx); err != nil {
		return fmt.Errorf("waiting for %s to become available: %+v", id, err)
	}

	d.SetId(id.ID())

	if v, ok := d.GetOk("threat_detection_policy"); ok {
		securityAlertId := serversecurityalertpolicies.NewServerID(id.SubscriptionId, id.ResourceGroupName, id.ServerName)
		alert := expandSecurityAlertPolicy(v)
		if alert != nil {
			if err = securityClient.CreateOrUpdateThenPoll(ctx, securityAlertId, *alert); err != nil {
				return fmt.Errorf("updating security alert policy for %s: %v", id, err)
			}
		}
	}

	// Issue tracking the REST API update failure: https://github.com/Azure/azure-rest-api-specs/issues/14117
	if mode == servers.CreateModeReplica {
		log.Printf("[INFO] updating `public_network_access_enabled` and `identity` for %s", id)
		properties := servers.ServerUpdateParameters{
			Identity: expandedIdentity,
			Properties: &servers.ServerUpdateParametersProperties{
				PublicNetworkAccess: &publicAccess,
			},
		}

		if err = client.UpdateThenPoll(ctx, id, properties); err != nil {
			return fmt.Errorf("updating Public Network Access for Replica %q: %+v", id, err)
		}
	}

	if mode == servers.CreateModePointInTimeRestore {
		log.Printf("[INFO] updating `public_network_access_enabled` for %s", id)
		properties := servers.ServerUpdateParameters{
			Properties: &servers.ServerUpdateParametersProperties{
				PublicNetworkAccess: &publicAccess,
			},
		}

		if err = client.UpdateThenPoll(ctx, id, properties); err != nil {
			return fmt.Errorf("updating Public Network Access for PointInTimeRestore %q: %+v", id, err)
		}
	}

	return resourcePostgreSQLServerRead(d, meta)
}
