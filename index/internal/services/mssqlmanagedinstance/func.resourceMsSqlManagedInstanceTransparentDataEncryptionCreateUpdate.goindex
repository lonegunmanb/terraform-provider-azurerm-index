package github.com/hashicorp/terraform-provider-azurerm/internal/services/mssqlmanagedinstance
import (
	"fmt"
	"log"
	"net/url"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/managedinstanceencryptionprotectors"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/managedinstancekeys"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	keyVaultParser "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	managedHsmHelpers "github.com/hashicorp/terraform-provider-azurerm/internal/services/managedhsm/helpers"
	mhsmParser "github.com/hashicorp/terraform-provider-azurerm/internal/services/managedhsm/parse"
	managedhsmValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/managedhsm/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssqlmanagedinstance/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssqlmanagedinstance/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceMsSqlManagedInstanceTransparentDataEncryptionCreateUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	encryptionProtectorClient := meta.(*clients.Client).MSSQLManagedInstance.ManagedInstanceEncryptionProtectorClient
	managedInstanceKeysClient := meta.(*clients.Client).MSSQLManagedInstance.ManagedInstanceKeysClient
	ctx, cancel := timeouts.ForCreateUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	managedInstanceId, err := commonids.ParseSqlManagedInstanceID(d.Get("managed_instance_id").(string))
	if err != nil {
		return err
	}

	// Normally we would check if this is a new resource, but the way encryption protector works, it always overwrites
	// whatever is there anyways. Compounding the issue is that SQL Server creates an instance of encryption protector
	// which causes the isNewResource check to fail because we are trying to create the encryption as a separate resource
	// and encryption protector is already present. The reason we create encryption protector as a separate resource is
	// because after the SQL server is created, we need to grant it permissions to AKV, so encryption protector can use those
	// keys are part of setting up TDE

	var managedInstanceKey managedinstancekeys.ManagedInstanceKey

	// Default values for Service Managed keys. Will update to AKV values if key_vault_key_id references a key.
	managedInstanceKeyName := ""
	managedInstanceKeyType := managedinstancekeys.ServerKeyTypeServiceManaged

	// If it has content, then we assume it's a key vault key id
	if v, ok := d.GetOk("key_vault_key_id"); ok {
		keyVaultKeyId := strings.TrimSpace(v.(string))
		// Update the server key type to AKV
		managedInstanceKeyType = managedinstancekeys.ServerKeyTypeAzureKeyVault

		// Set the SQL Managed Instance Key properties
		managedInstanceKeyProperties := managedinstancekeys.ManagedInstanceKeyProperties{
			ServerKeyType:       managedInstanceKeyType,
			Uri:                 &keyVaultKeyId,
			AutoRotationEnabled: pointer.To(d.Get("auto_rotation_enabled").(bool)),
		}
		managedInstanceKey.Properties = &managedInstanceKeyProperties

		// Set the encryption protector properties
		keyId, err := keyVaultParser.ParseNestedItemID(keyVaultKeyId)
		if err != nil {
			return fmt.Errorf("unable to parse key: %q: %+v", keyVaultKeyId, err)
		}

		// Make sure it's a key, if not, throw an error
		if keyId.NestedItemType == keyVaultParser.NestedItemTypeKey {
			keyName := keyId.Name
			keyVersion := keyId.Version

			// Extract the vault name from the keyvault base url
			idURL, err := url.ParseRequestURI(keyId.KeyVaultBaseUrl)
			if err != nil {
				return fmt.Errorf("unable to parse key vault hostname: %s", keyId.KeyVaultBaseUrl)
			}

			hostParts := strings.Split(idURL.Host, ".")
			vaultName := hostParts[0]

			// Create the key path for the Encryption Protector. Format is: {vaultname}_{key}_{key_version}
			managedInstanceKeyName = fmt.Sprintf("%s_%s_%s", vaultName, keyName, keyVersion)
		} else {
			return fmt.Errorf("key vault key id must be a reference to a key, but got: %s", keyId.NestedItemType)
		}
	}

	if v, ok := d.GetOk("managed_hsm_key_id"); ok {
		mhsmKeyId := strings.TrimSpace(v.(string))
		// Update the server key type to AKV
		managedInstanceKeyType = managedinstancekeys.ServerKeyTypeAzureKeyVault

		// Set the SQL Server Key properties z
		serverKeyProperties := managedinstancekeys.ManagedInstanceKeyProperties{
			ServerKeyType:       managedInstanceKeyType,
			Uri:                 &mhsmKeyId,
			AutoRotationEnabled: pointer.To(d.Get("auto_rotation_enabled").(bool)),
		}
		managedInstanceKey.Properties = &serverKeyProperties

		// Make sure it's a key, if not, throw an error
		keyId, err := mhsmParser.ManagedHSMDataPlaneVersionedKeyID(mhsmKeyId, nil)
		if err != nil {
			return fmt.Errorf("failed to parse '%s' as HSM key ID", mhsmKeyId)
		}

		// Extract the vault name from the keyvault base url
		idURL, err := url.ParseRequestURI(keyId.BaseUri())
		if err != nil {
			return fmt.Errorf("unable to parse key vault hostname: %s", keyId.BaseUri())
		}

		hostParts := strings.Split(idURL.Host, ".")
		vaultName := hostParts[0]

		// Create the key path for the Encryption Protector. Format is: {vaultname}_{key}_{key_version}
		managedInstanceKeyName = fmt.Sprintf("%s_%s_%s", vaultName, keyId.KeyName, keyId.KeyVersion)
	}

	keyType := managedinstanceencryptionprotectors.ServerKeyTypeServiceManaged
	if managedInstanceKeyType == managedinstancekeys.ServerKeyTypeAzureKeyVault {
		keyType = managedinstanceencryptionprotectors.ServerKeyTypeAzureKeyVault
	}
	// Service managed doesn't require a key name
	encryptionProtectorProperties := managedinstanceencryptionprotectors.ManagedInstanceEncryptionProtectorProperties{
		ServerKeyType:       keyType,
		ServerKeyName:       &managedInstanceKeyName,
		AutoRotationEnabled: utils.Bool(d.Get("auto_rotation_enabled").(bool)),
	}
	managedInstanceKeyId := managedinstancekeys.NewManagedInstanceKeyID(managedInstanceId.SubscriptionId, managedInstanceId.ResourceGroupName, managedInstanceId.ManagedInstanceName, managedInstanceKeyName)

	// Only create a managed instance key if the properties have been set
	if managedInstanceKey.Properties != nil {
		// Create a key on the managed instance
		err = managedInstanceKeysClient.CreateOrUpdateThenPoll(ctx, managedInstanceKeyId, managedInstanceKey)
		if err != nil {
			return fmt.Errorf("creating/updating managed instance key for %s: %+v", managedInstanceId, err)
		}
	}

	encryptionProtectorObject := managedinstanceencryptionprotectors.ManagedInstanceEncryptionProtector{
		Properties: &encryptionProtectorProperties,
	}

	// Encryption protector always uses "current" for the name
	id := parse.NewManagedInstanceEncryptionProtectorID(managedInstanceId.SubscriptionId, managedInstanceId.ResourceGroupName, managedInstanceId.ManagedInstanceName, "current")

	err = encryptionProtectorClient.CreateOrUpdateThenPoll(ctx, *managedInstanceId, encryptionProtectorObject)
	if err != nil {
		return fmt.Errorf("creating/updating %s: %+v", id, err)
	}

	d.SetId(id.ID())

	return resourceMsSqlManagedInstanceTransparentDataEncryptionRead(d, meta)
}
