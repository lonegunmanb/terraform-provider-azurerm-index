package github.com/hashicorp/terraform-provider-azurerm/internal/services/loganalytics
import (
	"context"
	"errors"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-sdk/resource-manager/insights/2023-03-11/datacollectionrules"
	sharedKeyWorkspaces "github.com/hashicorp/go-azure-sdk/resource-manager/operationalinsights/2020-08-01/workspaces"
	"github.com/hashicorp/go-azure-sdk/resource-manager/operationalinsights/2022-10-01/workspaces"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/loganalytics/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/loganalytics/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tags"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceLogAnalyticsWorkspaceCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).LogAnalytics.WorkspaceClient
	deletedWorkspaceClient := meta.(*clients.Client).LogAnalytics.DeletedWorkspacesClient
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()
	log.Printf("[INFO] preparing arguments for AzureRM Log Analytics Workspace creation.")

	var isLACluster bool

	name := d.Get("name").(string)
	id := workspaces.NewWorkspaceID(subscriptionId, d.Get("resource_group_name").(string), name)

	existing, err := client.Get(ctx, id)
	if err != nil {
		if !response.WasNotFound(existing.HttpResponse) {
			return fmt.Errorf("checking for presence of existing %s: %+v", id, err)
		}
	}

	if !response.WasNotFound(existing.HttpResponse) {
		return tf.ImportAsExistsError("azurerm_log_analytics_workspace", id.ID())
	}

	deleted, err := deletedWorkspaceClient.List(ctx, commonids.NewSubscriptionID(id.SubscriptionId))
	if err != nil {
		return fmt.Errorf("listing deleted Log Analytics Workspaces: %+v", err)
	}

	if model := deleted.Model; model != nil && model.Value != nil {
		for _, v := range *model.Value {
			if props := v.Properties; props != nil && props.Sku != nil {
				if pointer.From(v.Name) == name && string(props.Sku.Name) == string(workspaces.WorkspaceSkuNameEnumLACluster) {
					isLACluster = true
				}
			}
		}
	}

	skuName := d.Get("sku").(string)
	sku := &workspaces.WorkspaceSku{
		Name: workspaces.WorkspaceSkuNameEnum(skuName),
	}

	if !isLACluster && strings.EqualFold(skuName, string(workspaces.WorkspaceSkuNameEnumLACluster)) {
		return fmt.Errorf("`sku` cannot be set to `LACluster` during creation unless the workspace is in a soft-deleted state while linked to a Log Analytics Cluster")
	}

	if isLACluster {
		sku.Name = workspaces.WorkspaceSkuNameEnumLACluster
	} else if skuName == "" {
		// Default value if sku is not defined
		sku.Name = workspaces.WorkspaceSkuNameEnumPerGBTwoZeroOneEight
	}

	internetIngestionEnabled := workspaces.PublicNetworkAccessTypeDisabled
	if d.Get("internet_ingestion_enabled").(bool) {
		internetIngestionEnabled = workspaces.PublicNetworkAccessTypeEnabled
	}

	internetQueryEnabled := workspaces.PublicNetworkAccessTypeDisabled
	if d.Get("internet_query_enabled").(bool) {
		internetQueryEnabled = workspaces.PublicNetworkAccessTypeEnabled
	}

	allowResourceOnlyPermission := d.Get("allow_resource_only_permissions").(bool)

	parameters := workspaces.Workspace{
		Name:     &name,
		Location: location.Normalize(d.Get("location").(string)),
		Tags:     expandTags(d.Get("tags").(map[string]interface{})),
		Properties: &workspaces.WorkspaceProperties{
			Sku:                             sku,
			PublicNetworkAccessForIngestion: &internetIngestionEnabled,
			PublicNetworkAccessForQuery:     &internetQueryEnabled,
			RetentionInDays:                 pointer.To(int64(d.Get("retention_in_days").(int))),
			Features: &workspaces.WorkspaceFeatures{
				EnableLogAccessUsingOnlyResourcePermissions: pointer.To(allowResourceOnlyPermission),
				DisableLocalAuth: pointer.To(!d.Get("local_authentication_enabled").(bool)),
			},
		},
	}

	if !features.FivePointOh() {
		// In v4.0, we can not set default values for those O+C properties, we can only set the values manually.
		// `GetOk()` can not determine if the it's just zero-value (false) or the user specified `false`
		if pluginsdk.IsExplicitlyNullInConfig(d, "local_authentication_enabled") {
			parameters.Properties.Features.DisableLocalAuth = pointer.To(false)
		}
		if !pluginsdk.IsExplicitlyNullInConfig(d, "local_authentication_disabled") {
			v := d.Get("local_authentication_disabled")
			parameters.Properties.Features.DisableLocalAuth = pointer.To(v.(bool))
		}
	}

	// nolint : staticcheck
	if v, ok := d.GetOkExists("cmk_for_query_forced"); ok {
		parameters.Properties.ForceCmkForQuery = pointer.To(v.(bool))
	}

	if dailyQuotaGb, ok := d.GetOk("daily_quota_gb"); ok {
		parameters.Properties.WorkspaceCapping = &workspaces.WorkspaceCapping{
			DailyQuotaGb: pointer.To(dailyQuotaGb.(float64)),
		}
	}

	// The `ImmediatePurgeDataOn30Days` are not returned before it has been set
	// nolint : staticcheck
	if v, ok := d.GetOkExists("immediate_data_purge_on_30_days_enabled"); ok {
		parameters.Properties.Features.ImmediatePurgeDataOn30Days = pointer.To(v.(bool))
	}

	propName := "reservation_capacity_in_gb_per_day"
	capacityReservationLevel, ok := d.GetOk(propName)
	if ok {
		if strings.EqualFold(skuName, string(workspaces.WorkspaceSkuNameEnumCapacityReservation)) {
			capacityReservationLevelValue := workspaces.CapacityReservationLevel(int64(capacityReservationLevel.(int)))
			parameters.Properties.Sku.CapacityReservationLevel = &capacityReservationLevelValue
		} else {
			return fmt.Errorf("`%s` can only be used with the `CapacityReservation` SKU", propName)
		}
	} else {
		if strings.EqualFold(skuName, string(workspaces.WorkspaceSkuNameEnumCapacityReservation)) {
			return fmt.Errorf("`%s` must be set when using the `CapacityReservation` SKU", propName)
		}
	}

	if v, ok := d.GetOk("identity"); ok {
		expanded, err := identity.ExpandSystemOrUserAssignedMap(v.([]interface{}))
		if err != nil {
			return fmt.Errorf("expanding identity: %+v", err)
		}
		parameters.Identity = expanded
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, parameters); err != nil {
		return err
	}

	// `data_collection_rule_id` also needs an additional update.
	// error message: Default dcr is not applicable on workspace creation, please provide it on update.
	if v, ok := d.GetOk("data_collection_rule_id"); ok {
		parameters.Properties.DefaultDataCollectionRuleResourceId = pointer.To(v.(string))
	}

	// `allow_resource_only_permissions` needs an additional update, tracked in https://github.com/Azure/azure-rest-api-specs/issues/21591
	if err := client.CreateOrUpdateThenPoll(ctx, id, parameters); err != nil {
		return err
	}

	stateConf := &pluginsdk.StateChangeConf{
		Pending:    []string{strconv.FormatBool(!allowResourceOnlyPermission)},
		Target:     []string{strconv.FormatBool(allowResourceOnlyPermission)},
		Timeout:    d.Timeout(pluginsdk.TimeoutCreate),
		MinTimeout: 30 * time.Second,
		Refresh: func() (interface{}, string, error) {
			resp, err := client.Get(ctx, id)
			if err != nil {
				return resp, "error", fmt.Errorf("retrieving %s: %+v", id, err)
			}

			if resp.Model != nil && resp.Model.Properties != nil && resp.Model.Properties.Features != nil && resp.Model.Properties.Features.EnableLogAccessUsingOnlyResourcePermissions != nil {
				return resp, strconv.FormatBool(*resp.Model.Properties.Features.EnableLogAccessUsingOnlyResourcePermissions), nil
			}

			return resp, "false", fmt.Errorf("retrieving %s: feature is nil", id)
		},
	}

	if _, err := stateConf.WaitForStateContext(ctx); err != nil {
		return fmt.Errorf("waiting on update for %s: %+v", id, err)
	}

	d.SetId(id.ID())

	return resourceLogAnalyticsWorkspaceRead(d, meta)
}
