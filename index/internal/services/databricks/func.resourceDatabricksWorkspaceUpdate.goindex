package github.com/hashicorp/terraform-provider-azurerm/internal/services/databricks
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/databricks/2022-10-01-preview/accessconnector"
	"github.com/hashicorp/go-azure-sdk/resource-manager/databricks/2024-05-01/workspaces"
	mlworkspace "github.com/hashicorp/go-azure-sdk/resource-manager/machinelearningservices/2024-04-01/workspaces"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-09-01/loadbalancers"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2024-05-01/subnets"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/databricks/validate"
	keyVaultParse "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	resourcesParse "github.com/hashicorp/terraform-provider-azurerm/internal/services/resource/parse"
	storageValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/storage/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceDatabricksWorkspaceUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).DataBricks.WorkspacesClient
	acClient := meta.(*clients.Client).DataBricks.AccessConnectorClient
	keyVaultsClient := meta.(*clients.Client).KeyVault
	ctx, cancel := timeouts.ForUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := workspaces.ParseWorkspaceID(d.Id())
	if err != nil {
		return err
	}

	existing, err := client.Get(ctx, *id)
	if err != nil {
		return fmt.Errorf("retrieving %s: %+v", id, err)
	}

	if existing.Model == nil {
		return fmt.Errorf("retrieving %s: model is nil", id)
	}

	model := *existing.Model

	props := model.Properties

	if d.HasChange("sku") {
		if model.Sku == nil {
			model.Sku = &workspaces.Sku{}
		}
		model.Sku.Name = d.Get("sku").(string)
	}

	if d.HasChange("tags") {
		model.Tags = tags.Expand(d.Get("tags").(map[string]interface{}))
	}

	if d.HasChange("customer_managed_key_enabled") {
		if props.Parameters == nil {
			props.Parameters = &workspaces.WorkspaceCustomParameters{}
		}
		props.Parameters.PrepareEncryption = &workspaces.WorkspaceCustomBooleanParameter{
			Value: d.Get("customer_managed_key_enabled").(bool),
		}
	}

	if d.HasChange("infrastructure_encryption_enabled") {
		if props.Parameters == nil {
			props.Parameters = &workspaces.WorkspaceCustomParameters{}
		}
		props.Parameters.RequireInfrastructureEncryption = &workspaces.WorkspaceCustomBooleanParameter{
			Value: d.Get("infrastructure_encryption_enabled").(bool),
		}
	}

	if d.HasChange("default_storage_firewall_enabled") {
		defaultStorageFirewallEnabled := workspaces.DefaultStorageFirewallDisabled
		defaultStorageFirewallEnabledRaw := d.Get("default_storage_firewall_enabled").(bool)

		if defaultStorageFirewallEnabledRaw {
			defaultStorageFirewallEnabled = workspaces.DefaultStorageFirewallEnabled

			accessConnectorProperties := workspaces.WorkspacePropertiesAccessConnector{}
			accessConnectorIdRaw := d.Get("access_connector_id").(string)
			accessConnectorId, err := accessconnector.ParseAccessConnectorID(accessConnectorIdRaw)
			if err != nil {
				return err
			}

			accessConnector, err := acClient.Get(ctx, *accessConnectorId)
			if err != nil {
				return fmt.Errorf("retrieving Access Connector %s: %+v", accessConnectorId.AccessConnectorName, err)
			}

			if accessConnector.Model.Identity != nil {
				accIdentityId := ""
				for raw := range accessConnector.Model.Identity.IdentityIds {
					identityId, err := commonids.ParseUserAssignedIdentityIDInsensitively(raw)
					if err != nil {
						return err
					}
					accIdentityId = identityId.ID()
					break
				}

				accessConnectorProperties.Id = *accessConnector.Model.Id
				accessConnectorProperties.IdentityType = workspaces.IdentityType(accessConnector.Model.Identity.Type)
				accessConnectorProperties.UserAssignedIdentityId = &accIdentityId
			}

			props.AccessConnector = &accessConnectorProperties
		}

		props.DefaultStorageFirewall = &defaultStorageFirewallEnabled
	}

	if d.HasChange("public_network_access_enabled") {
		publicNetworkAccessRaw := d.Get("public_network_access_enabled").(bool)
		publicNetworkAccess := workspaces.PublicNetworkAccessDisabled
		if publicNetworkAccessRaw {
			publicNetworkAccess = workspaces.PublicNetworkAccessEnabled
		}
		props.PublicNetworkAccess = &publicNetworkAccess
	}

	if d.HasChange("network_security_group_rules_required") {
		props.RequiredNsgRules = pointer.To(workspaces.RequiredNsgRules(d.Get("network_security_group_rules_required").(string)))
	}

	if d.HasChange("custom_parameters") {
		if props.Parameters == nil {
			props.Parameters = &workspaces.WorkspaceCustomParameters{}
		}

		if customParams := d.Get("custom_parameters").([]interface{}); len(customParams) > 0 && customParams[0] != nil {
			config := customParams[0].(map[string]interface{})
			var pubSubnetAssoc, priSubnetAssoc *string

			pubSub := config["public_subnet_name"].(string)
			priSub := config["private_subnet_name"].(string)

			if v, ok := config["public_subnet_network_security_group_association_id"].(string); ok {
				pubSubnetAssoc = &v
			}

			if v, ok := config["private_subnet_network_security_group_association_id"].(string); ok {
				priSubnetAssoc = &v
			}

			if config["virtual_network_id"].(string) == "" && (pubSub != "" || priSub != "") {
				return fmt.Errorf("`public_subnet_name` and/or `private_subnet_name` cannot be defined if `virtual_network_id` is not set")
			}
			if config["virtual_network_id"].(string) != "" && (pubSub == "" || priSub == "") {
				return fmt.Errorf("`public_subnet_name` and `private_subnet_name` must both have values if `virtual_network_id` is set")
			}
			if pubSub != "" && pubSubnetAssoc == nil {
				return fmt.Errorf("you must define a value for `public_subnet_network_security_group_association_id` if `public_subnet_name` is set")
			}
			if priSub != "" && priSubnetAssoc == nil {
				return fmt.Errorf("you must define a value for `private_subnet_network_security_group_association_id` if `private_subnet_name` is set")
			}

			if v, ok := config["nat_gateway_name"].(string); ok && v != "" {
				props.Parameters.NatGatewayName = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["public_ip_name"].(string); ok && v != "" {
				props.Parameters.PublicIPName = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["storage_account_name"].(string); ok && v != "" {
				props.Parameters.StorageAccountName = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["storage_account_sku_name"].(string); ok && v != "" {
				props.Parameters.StorageAccountSkuName = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["vnet_address_prefix"].(string); ok && v != "" {
				props.Parameters.VnetAddressPrefix = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["machine_learning_workspace_id"].(string); ok && v != "" {
				props.Parameters.AmlWorkspaceId = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["no_public_ip"].(bool); ok {
				props.Parameters.EnableNoPublicIP = &workspaces.WorkspaceNoPublicIPBooleanParameter{
					Value: v,
				}
			}

			if v, ok := config["public_subnet_name"].(string); ok && v != "" {
				props.Parameters.CustomPublicSubnetName = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["private_subnet_name"].(string); ok && v != "" {
				props.Parameters.CustomPrivateSubnetName = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}

			if v, ok := config["virtual_network_id"].(string); ok && v != "" {
				props.Parameters.CustomVirtualNetworkId = &workspaces.WorkspaceCustomStringParameter{
					Value: v,
				}
			}
		}
	}

	// Set up customer-managed keys for managed services encryption (e.g. notebook)
	setEncrypt := false
	encrypt := &workspaces.WorkspacePropertiesEncryption{}
	encrypt.Entities = workspaces.EncryptionEntitiesDefinition{}

	var servicesKeyId string
	var servicesKeyVaultId string
	var diskKeyId string
	var diskKeyVaultId string

	if v, ok := d.GetOk("managed_services_cmk_key_vault_key_id"); ok {
		servicesKeyId = v.(string)
	}

	if v, ok := d.GetOk("managed_services_cmk_key_vault_id"); ok {
		servicesKeyVaultId = v.(string)
	}

	if v, ok := d.GetOk("managed_disk_cmk_key_vault_key_id"); ok {
		diskKeyId = v.(string)
	}

	if v, ok := d.GetOk("managed_disk_cmk_key_vault_id"); ok {
		diskKeyVaultId = v.(string)
	}

	// set default subscription as current subscription for key vault look-up...
	servicesResourceSubscriptionId := commonids.NewSubscriptionID(id.SubscriptionId)
	diskResourceSubscriptionId := commonids.NewSubscriptionID(id.SubscriptionId)

	if servicesKeyVaultId != "" {
		// If they passed the 'managed_cmk_key_vault_id' parse the Key Vault ID
		// to extract the correct key vault subscription for the exists call...
		v, err := commonids.ParseKeyVaultID(servicesKeyVaultId)
		if err != nil {
			return err
		}

		servicesResourceSubscriptionId = commonids.NewSubscriptionID(v.SubscriptionId)
	}

	if servicesKeyId != "" {
		setEncrypt = true
		key, err := keyVaultParse.ParseNestedItemID(servicesKeyId)
		if err != nil {
			return err
		}

		// make sure the key vault exists
		_, err = keyVaultsClient.KeyVaultIDFromBaseUrl(ctx, servicesResourceSubscriptionId, key.KeyVaultBaseUrl)
		if err != nil {
			return fmt.Errorf("retrieving the Resource ID for the customer-managed keys for managed services Key Vault in subscription %q at URL %q: %+v", servicesResourceSubscriptionId, key.KeyVaultBaseUrl, err)
		}

		encrypt.Entities.ManagedServices = &workspaces.EncryptionV2{
			KeySource: workspaces.EncryptionKeySourceMicrosoftPointKeyvault,
			KeyVaultProperties: &workspaces.EncryptionV2KeyVaultProperties{
				KeyName:     key.Name,
				KeyVersion:  key.Version,
				KeyVaultUri: key.KeyVaultBaseUrl,
			},
		}
	}

	if diskKeyVaultId != "" {
		// If they passed the 'managed_disk_cmk_key_vault_id' parse the Key Vault ID
		// to extract the correct key vault subscription for the exists call...
		v, err := commonids.ParseKeyVaultID(diskKeyVaultId)
		if err != nil {
			return err
		}

		diskResourceSubscriptionId = commonids.NewSubscriptionID(v.SubscriptionId)
	}

	if diskKeyId != "" {
		setEncrypt = true
		key, err := keyVaultParse.ParseNestedItemID(diskKeyId)
		if err != nil {
			return err
		}

		// make sure the key vault exists
		_, err = keyVaultsClient.KeyVaultIDFromBaseUrl(ctx, diskResourceSubscriptionId, key.KeyVaultBaseUrl)
		if err != nil {
			return fmt.Errorf("retrieving the Resource ID for the customer-managed keys for managed disk Key Vault in subscription %q at URL %q: %+v", diskResourceSubscriptionId, key.KeyVaultBaseUrl, err)
		}

		encrypt.Entities.ManagedDisk = &workspaces.ManagedDiskEncryption{
			KeySource: workspaces.EncryptionKeySourceMicrosoftPointKeyvault,
			KeyVaultProperties: workspaces.ManagedDiskEncryptionKeyVaultProperties{
				KeyName:     key.Name,
				KeyVersion:  key.Version,
				KeyVaultUri: key.KeyVaultBaseUrl,
			},
		}
	}

	if rotationEnabled := d.Get("managed_disk_cmk_rotation_to_latest_version_enabled").(bool); rotationEnabled {
		encrypt.Entities.ManagedDisk.RotationToLatestKeyVersionEnabled = pointer.To(rotationEnabled)
	}

	if setEncrypt {
		props.Encryption = encrypt
	}

	enhancedSecurityCompliance := d.Get("enhanced_security_compliance")
	props.EnhancedSecurityCompliance = expandWorkspaceEnhancedSecurity(enhancedSecurityCompliance.([]interface{}))

	model.Properties = props

	if err := client.CreateOrUpdateThenPoll(ctx, *id, model); err != nil {
		return fmt.Errorf("updating %s: %+v", id, err)
	}

	if d.HasChange("tags") {
		workspaceUpdate := workspaces.WorkspaceUpdate{
			Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
		}

		err := client.UpdateThenPoll(ctx, *id, workspaceUpdate)
		if err != nil {
			return fmt.Errorf("updating %s Tags: %+v", id, err)
		}
	}

	return resourceDatabricksWorkspaceRead(d, meta)
}
