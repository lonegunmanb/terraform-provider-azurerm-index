package github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/keyvault/2023-02-01/vaults"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	commonValidate "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/network"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/set"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
	dataplane "github.com/jackofallops/kermit/sdk/keyvault/7.4/keyvault"
)
func resourceKeyVaultRead(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).KeyVault.VaultsClient
	managementClient := meta.(*clients.Client).KeyVault.ManagementClient
	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := commonids.ParseKeyVaultID(d.Id())
	if err != nil {
		return err
	}

	resp, err := client.Get(ctx, *id)
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			log.Printf("[DEBUG] %s was not found - removing from state!", *id)
			d.SetId("")
			return nil
		}
		return fmt.Errorf("retrieving %s: %+v", *id, err)
	}

	vaultUri := ""
	if model := resp.Model; model != nil {
		if model.Properties.VaultUri != nil {
			vaultUri = *model.Properties.VaultUri
		}
	}

	if vaultUri != "" {
		meta.(*clients.Client).KeyVault.AddToCache(*id, vaultUri)
	}

	d.Set("name", id.VaultName)
	d.Set("resource_group_name", id.ResourceGroupName)
	d.Set("vault_uri", vaultUri)

	publicNetworkAccessEnabled := true

	if model := resp.Model; model != nil {
		d.Set("location", location.NormalizeNilable(model.Location))
		d.Set("tenant_id", model.Properties.TenantId)
		d.Set("enabled_for_deployment", model.Properties.EnabledForDeployment)
		d.Set("enabled_for_disk_encryption", model.Properties.EnabledForDiskEncryption)
		d.Set("enabled_for_template_deployment", model.Properties.EnabledForTemplateDeployment)
		d.Set("enable_rbac_authorization", model.Properties.EnableRbacAuthorization)
		d.Set("purge_protection_enabled", model.Properties.EnablePurgeProtection)

		if model.Properties.PublicNetworkAccess != nil {
			publicNetworkAccessEnabled = strings.EqualFold(*model.Properties.PublicNetworkAccess, "Enabled")
		}
		d.Set("public_network_access_enabled", publicNetworkAccessEnabled)

		// @tombuildsstuff: the API doesn't return this field if it's not configured
		// however https://docs.microsoft.com/en-us/azure/key-vault/general/soft-delete-overview
		// defaults this to 90 days, as such we're going to have to assume that for the moment
		// in lieu of anything being returned
		softDeleteRetentionDays := 90
		if model.Properties.SoftDeleteRetentionInDays != nil && *model.Properties.SoftDeleteRetentionInDays != 0 {
			softDeleteRetentionDays = int(*model.Properties.SoftDeleteRetentionInDays)
		}
		d.Set("soft_delete_retention_days", softDeleteRetentionDays)

		skuName := ""
		// The Azure API is inconsistent here, so rewrite this into the casing we expect
		// TODO: this can be removed when the new base layer is enabled?
		for _, v := range vaults.PossibleValuesForSkuName() {
			if strings.EqualFold(v, string(model.Properties.Sku.Name)) {
				skuName = v
			}
		}
		d.Set("sku_name", skuName)

		if err := d.Set("network_acls", flattenKeyVaultNetworkAcls(model.Properties.NetworkAcls)); err != nil {
			return fmt.Errorf("setting `network_acls`: %+v", err)
		}

		flattenedPolicies := flattenAccessPolicies(model.Properties.AccessPolicies)
		if err := d.Set("access_policy", flattenedPolicies); err != nil {
			return fmt.Errorf("setting `access_policy`: %+v", err)
		}

		if err := tags.FlattenAndSet(d, model.Tags); err != nil {
			return fmt.Errorf("setting `tags`: %+v", err)
		}
	}

	// If publicNetworkAccessEnabled is true, the data plane call should succeed.
	// (if the caller has the 'ManageContacts' certificate permissions)
	//
	// If an error is returned from the data plane call we need to return that error.
	//
	// If publicNetworkAccessEnabled is false, the data plane call should fail unless
	// there is a private endpoint connected to the key vault.
	// (and the caller has the 'ManageContacts' certificate permissions)
	//
	// We don't know if the private endpoint has been created yet, so we need
	// to ignore the error if the data plane call fails.
	contacts, err := managementClient.GetCertificateContacts(ctx, vaultUri)
	if err != nil {
		if publicNetworkAccessEnabled && (!utils.ResponseWasForbidden(contacts.Response) && !utils.ResponseWasNotFound(contacts.Response)) {
			return fmt.Errorf("retrieving `contact` for KeyVault: %+v", err)
		}
	}

	if err := d.Set("contact", flattenKeyVaultCertificateContactList(&contacts)); err != nil {
		return fmt.Errorf("setting `contact` for KeyVault: %+v", err)
	}

	return nil
}
