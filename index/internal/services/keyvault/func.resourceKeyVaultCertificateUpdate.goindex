package github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault
import (
	"context"
	"crypto/x509"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"log"
	"math"
	"strings"
	"time"

	"github.com/Azure/go-autorest/autorest"
	"github.com/google/go-cmp/cmp"
	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tags"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/set"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
	"github.com/jackofallops/kermit/sdk/keyvault/7.4/keyvault"
)
func resourceKeyVaultCertificateUpdate(d *schema.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).KeyVault.ManagementClient
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := parse.ParseNestedItemID(d.Id())
	if err != nil {
		return err
	}

	keyVaultId, err := commonids.ParseKeyVaultID(d.Get("key_vault_id").(string))
	if err != nil {
		return err
	}

	meta.(*clients.Client).KeyVault.AddToCache(*keyVaultId, id.KeyVaultBaseUrl)

	if d.HasChange("certificate") {
		if v, ok := d.GetOk("certificate"); ok {
			// Import new version of certificate
			certificate := expandKeyVaultCertificate(v)
			importParameters := keyvault.CertificateImportParameters{
				Base64EncodedCertificate: utils.String(certificate.CertificateData),
				Password:                 utils.String(certificate.CertificatePassword),
			}
			resp, err := client.ImportCertificate(ctx, id.KeyVaultBaseUrl, id.Name, importParameters)
			if err != nil {
				return err
			}

			if resp.ID == nil {
				return fmt.Errorf("error: Certificate %q in Vault %q get nil ID from server", id.Name, id.KeyVaultBaseUrl)
			}

			certificateId, err := parse.ParseNestedItemID(*resp.ID)
			if err != nil {
				return err
			}
			d.SetId(certificateId.ID())
		}
	}

	// update lifetime_action only should not recreate a certificate
	var lifeTimeOld, lifeTimeNew interface{}
	var policyOld, policyNew map[string]interface{}

	policyOldRaw, policyNewRaw := d.GetChange("certificate_policy")
	policyOldList, policyNewList := policyOldRaw.([]interface{}), policyNewRaw.([]interface{})

	if len(policyOldList) > 0 {
		policyOld = policyOldList[0].(map[string]interface{})
		lifeTimeOld = policyOld["lifetime_action"]
		delete(policyOld, "lifetime_action")
	}
	if len(policyNewList) > 0 {
		policyNew = policyNewList[0].(map[string]interface{})
		lifeTimeNew = policyNew["lifetime_action"]
		delete(policyNew, "lifetime_action")
	}

	// do not recreate cerfiticate when only lifetime_action changes
	if !cmp.Equal(policyNewList, policyOldList) {
		policyNew["lifetime_action"] = lifeTimeNew
		newCert, err := createCertificate(d, meta)
		if err != nil {
			return err
		}
		certificateId, err := parse.ParseNestedItemID(*newCert.ID)
		if err != nil {
			return err
		}
		d.SetId(certificateId.ID())
	}

	if updateLifetime := !cmp.Equal(lifeTimeOld, lifeTimeNew); d.HasChange("tags") || updateLifetime {
		patch := keyvault.CertificateUpdateParameters{}
		if d.HasChange("tags") {
			if t, ok := d.GetOk("tags"); ok {
				patch.Tags = tags.Expand(t.(map[string]interface{}))
			}
		}

		if updateLifetime {
			patch.CertificatePolicy = &keyvault.CertificatePolicy{
				LifetimeActions: expandKeyVaultCertificatePolicyLifetimeAction(lifeTimeNew),
			}
		}

		if _, err = client.UpdateCertificate(ctx, id.KeyVaultBaseUrl, id.Name, "", patch); err != nil {
			return err
		}
	}
	return resourceKeyVaultCertificateRead(d, meta)
}
