package github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/migration
import (
	"context"
	"strings"

	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/set"
)
func (KeyVaultV0ToV1) UpgradeFunc() pluginsdk.StateUpgraderFunc {
	return func(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) {
		inputAccessPolicies := rawState["access_policy"].([]interface{})
		if len(inputAccessPolicies) == 0 {
			return rawState, nil
		}

		outputAccessPolicies := make([]interface{}, 0)
		for _, accessPolicy := range inputAccessPolicies {
			policy := accessPolicy.(map[string]interface{})

			if v, ok := policy["certificate_permissions"]; ok {
				inputCertificatePermissions := v.([]interface{})
				outputCertificatePermissions := make([]string, 0)
				for _, p := range inputCertificatePermissions {
					permission := p.(string)
					if strings.ToLower(permission) == "all" {
						outputCertificatePermissions = append(outputCertificatePermissions, "create")
						outputCertificatePermissions = append(outputCertificatePermissions, "delete")
						outputCertificatePermissions = append(outputCertificatePermissions, "deleteissuers")
						outputCertificatePermissions = append(outputCertificatePermissions, "get")
						outputCertificatePermissions = append(outputCertificatePermissions, "getissuers")
						outputCertificatePermissions = append(outputCertificatePermissions, "import")
						outputCertificatePermissions = append(outputCertificatePermissions, "list")
						outputCertificatePermissions = append(outputCertificatePermissions, "listissuers")
						outputCertificatePermissions = append(outputCertificatePermissions, "managecontacts")
						outputCertificatePermissions = append(outputCertificatePermissions, "manageissuers")
						outputCertificatePermissions = append(outputCertificatePermissions, "setissuers")
						outputCertificatePermissions = append(outputCertificatePermissions, "update")
						break
					}
				}

				if len(outputCertificatePermissions) > 0 {
					policy["certificate_permissions"] = outputCertificatePermissions
				}
			}

			if v, ok := policy["key_permissions"]; ok {
				inputKeyPermissions := v.([]interface{})
				outputKeyPermissions := make([]string, 0)
				for _, p := range inputKeyPermissions {
					permission := p.(string)
					if strings.ToLower(permission) == "all" {
						outputKeyPermissions = append(outputKeyPermissions, "backup")
						outputKeyPermissions = append(outputKeyPermissions, "create")
						outputKeyPermissions = append(outputKeyPermissions, "decrypt")
						outputKeyPermissions = append(outputKeyPermissions, "delete")
						outputKeyPermissions = append(outputKeyPermissions, "encrypt")
						outputKeyPermissions = append(outputKeyPermissions, "get")
						outputKeyPermissions = append(outputKeyPermissions, "import")
						outputKeyPermissions = append(outputKeyPermissions, "list")
						outputKeyPermissions = append(outputKeyPermissions, "purge")
						outputKeyPermissions = append(outputKeyPermissions, "recover")
						outputKeyPermissions = append(outputKeyPermissions, "restore")
						outputKeyPermissions = append(outputKeyPermissions, "sign")
						outputKeyPermissions = append(outputKeyPermissions, "unwrapKey")
						outputKeyPermissions = append(outputKeyPermissions, "update")
						outputKeyPermissions = append(outputKeyPermissions, "verify")
						outputKeyPermissions = append(outputKeyPermissions, "wrapKey")
						outputKeyPermissions = append(outputKeyPermissions, "release")
						outputKeyPermissions = append(outputKeyPermissions, "rotate")
						outputKeyPermissions = append(outputKeyPermissions, "getRotationPolicy")
						outputKeyPermissions = append(outputKeyPermissions, "setRotationPolicy")
						break
					}
				}

				if len(outputKeyPermissions) > 0 {
					policy["key_permissions"] = outputKeyPermissions
				}
			}

			if v, ok := policy["secret_permissions"]; ok {
				inputSecretPermissions := v.([]interface{})
				outputSecretPermissions := make([]string, 0)
				for _, p := range inputSecretPermissions {
					permission := p.(string)
					if strings.ToLower(permission) == "all" {
						outputSecretPermissions = append(outputSecretPermissions, "backup")
						outputSecretPermissions = append(outputSecretPermissions, "delete")
						outputSecretPermissions = append(outputSecretPermissions, "get")
						outputSecretPermissions = append(outputSecretPermissions, "list")
						outputSecretPermissions = append(outputSecretPermissions, "purge")
						outputSecretPermissions = append(outputSecretPermissions, "recover")
						outputSecretPermissions = append(outputSecretPermissions, "restore")
						outputSecretPermissions = append(outputSecretPermissions, "set")
						break
					}
				}

				if len(outputSecretPermissions) > 0 {
					policy["secret_permissions"] = outputSecretPermissions
				}
			}

			outputAccessPolicies = append(outputAccessPolicies, policy)
		}

		rawState["access_policy"] = outputAccessPolicies
		return rawState, nil
	}
}
