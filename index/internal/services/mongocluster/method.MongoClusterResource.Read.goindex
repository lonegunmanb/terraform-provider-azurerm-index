package github.com/hashicorp/terraform-provider-azurerm/internal/services/mongocluster
import (
	"context"
	"fmt"
	"net/url"
	"regexp"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-sdk/resource-manager/mongocluster/2025-09-01/mongoclusters"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (r MongoClusterResource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.MongoCluster.MongoClustersClient

			id, err := mongoclusters.ParseMongoClusterID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}

			resp, err := client.Get(ctx, *id)
			if err != nil {
				if response.WasNotFound(resp.HttpResponse) {
					return metadata.MarkAsGone(*id)
				}
				return fmt.Errorf("retrieving %s: %+v", *id, err)
			}

			state := MongoClusterResourceModel{
				Name:              id.MongoClusterName,
				ResourceGroupName: id.ResourceGroupName,
			}

			if model := resp.Model; model != nil {
				state.Location = location.Normalize(model.Location)

				identity, err := identity.FlattenUserAssignedMapToModel(model.Identity)
				if err != nil {
					return fmt.Errorf("flattening `identity`: %+v", err)
				}
				state.Identity = pointer.From(identity)

				if props := model.Properties; props != nil {
					// API doesn't return the value of administrator_password
					state.AdministratorPassword = metadata.ResourceData.Get("administrator_password").(string)

					// API doesn't return the value of create_mode, https://github.com/Azure/azure-rest-api-specs/issues/31266 has been filed to track it.
					state.CreateMode = metadata.ResourceData.Get("create_mode").(string)

					state.CustomerManagedKey = flattenMongoClusterCustomerManagedKey(props.Encryption)

					if v := props.Administrator; v != nil {
						state.AdministratorUserName = pointer.From(v.UserName)
					}

					if v := props.Replica; v != nil {
						// API doesn't return the value of source_location, https://github.com/Azure/azure-rest-api-specs/issues/31266 has been filed to track it.
						state.SourceLocation = metadata.ResourceData.Get("source_location").(string)
						if v.SourceResourceId != nil {
							id, err := mongoclusters.ParseMongoClusterID(pointer.From(v.SourceResourceId))
							if err != nil {
								return err
							}
							state.SourceServerId = id.ID()
						}
					}

					state.Restore = flattenMongoClusterRestore(props.RestoreParameters)

					if v := props.Sharding; v != nil {
						state.ShardCount = pointer.From(v.ShardCount)
					}
					if v := props.Compute; v != nil {
						state.ComputeTier = pointer.From(v.Tier)
					}

					if v := props.HighAvailability; v != nil {
						state.HighAvailabilityMode = string(pointer.From(v.TargetMode))
					}
					state.PublicNetworkAccess = string(pointer.From(props.PublicNetworkAccess))

					if v := props.Storage; v != nil {
						state.StorageSizeInGb = pointer.From(v.SizeGb)
						state.StorageType = pointer.FromEnum(v.Type)
					}
					if v := props.PreviewFeatures; v != nil {
						state.PreviewFeatures = flattenMongoClusterPreviewFeatures(v)
					}
					state.Version = pointer.From(props.ServerVersion)

					state.AuthenticationMethods = flattenMongoClusterAuthConfig(props.AuthConfig)

					if v := props.DataApi; v != nil {
						state.DataApiModeEnabled = pointer.From(v.Mode) == mongoclusters.DataApiModeEnabled
					}
				}

				state.Tags = pointer.From(model.Tags)
			}

			csResp, err := client.ListConnectionStrings(ctx, *id)
			if err != nil {
				return fmt.Errorf("listing connection strings for %s: %+v", *id, err)
			}
			if model := csResp.Model; model != nil {
				state.ConnectionStrings = flattenMongoClusterConnectionStrings(model.ConnectionStrings, state.AdministratorUserName, state.AdministratorPassword)
			}

			return metadata.Encode(&state)
		},
	}
}
