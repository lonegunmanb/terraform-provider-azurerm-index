package github.com/hashicorp/terraform-provider-azurerm/internal/services/mongocluster
import (
	"context"
	"fmt"
	"net/url"
	"regexp"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-sdk/resource-manager/mongocluster/2024-07-01/mongoclusters"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (r MongoClusterResource) CustomizeDiff() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			var state MongoClusterResourceModel
			if err := metadata.DecodeDiff(&state); err != nil {
				return fmt.Errorf("DecodeDiff: %+v", err)
			}

			switch state.CreateMode {
			case string(mongoclusters.CreateModeDefault):
				if state.AdministratorUserName == "" {
					return fmt.Errorf("`administrator_username` is required when `create_mode` is %s", string(mongoclusters.CreateModeDefault))
				}

				if state.ComputeTier == "" {
					return fmt.Errorf("`compute_tier` is required when `create_mode` is %s", string(mongoclusters.CreateModeDefault))
				}

				if state.StorageSizeInGb == 0 {
					return fmt.Errorf("`storage_size_in_gb` is required when `create_mode` is %s", string(mongoclusters.CreateModeDefault))
				}

				if state.HighAvailabilityMode == "" {
					return fmt.Errorf("`high_availability_mode` is required when `create_mode` is %s", string(mongoclusters.CreateModeDefault))
				}

				if state.ShardCount == 0 {
					return fmt.Errorf("`shard_count` is required when `create_mode` is %s", string(mongoclusters.CreateModeDefault))
				}

				if state.Version == "" {
					return fmt.Errorf("`version` is required when `create_mode` is %s", string(mongoclusters.CreateModeDefault))
				}
			case string(mongoclusters.CreateModeGeoReplica):
				if state.SourceLocation == "" {
					return fmt.Errorf("`source_location` is required when `create_mode` is `GeoReplica`")
				}
			}

			if state.ComputeTier == "Free" || state.ComputeTier == "M25" {
				if state.HighAvailabilityMode == string(mongoclusters.HighAvailabilityModeZoneRedundantPreferred) {
					return fmt.Errorf("high Availability is not available with the `Free` or `M25` Compute Tier")
				}

				if state.ShardCount > 1 {
					return fmt.Errorf("the value of `shard_count` cannot exceed 1 for the `Free` or `M25` Compute Tier")
				}
			}

			if len(state.PreviewFeatures) > 0 {
				existing := make(map[string]bool)
				for _, str := range state.PreviewFeatures {
					if existing[str] {
						return fmt.Errorf("`preview_features` contains the duplicate value %q", str)
					}
					existing[str] = true
				}
			}

			// Since the API doesn't return the value of create_mode, when importing `azurerm_mongo_cluster`, it will cause replacement.
			if oldVal, newVal := metadata.ResourceDiff.GetChange("create_mode"); oldVal.(string) != "" && oldVal.(string) != newVal.(string) {
				if err := metadata.ResourceDiff.ForceNew("create_mode"); err != nil {
					return err
				}
			}
			return nil
		},
	}
}
