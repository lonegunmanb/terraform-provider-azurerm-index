package github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql
import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/restorabledroppeddatabases"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/serverazureadadministrators"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/serverazureadonlyauthentications"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/serverconnectionpolicies"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/servers"
	"github.com/hashicorp/go-azure-sdk/sdk/client/pollers"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	keyVaultParser "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql/custompollers"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceMsSqlServerUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).MSSQL.ServersClient
	connectionClient := meta.(*clients.Client).MSSQL.ServerConnectionPoliciesClient
	adminClient := meta.(*clients.Client).MSSQL.ServerAzureADAdministratorsClient
	aadOnlyAuthenticationsClient := meta.(*clients.Client).MSSQL.ServerAzureADOnlyAuthenticationsClient
	ctx, cancel := timeouts.ForUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := commonids.ParseSqlServerID(d.Id())
	if err != nil {
		return err
	}

	existing, err := client.Get(ctx, *id, servers.DefaultGetOperationOptions())
	if err != nil {
		return fmt.Errorf("retrieving %s: %+v", id, err)
	}

	if payload := existing.Model; payload != nil {
		if d.HasChange("tags") {
			payload.Tags = tags.Expand(d.Get("tags").(map[string]interface{}))
		}

		if d.HasChange("identity") {
			expanded, err := identity.ExpandLegacySystemAndUserAssignedMap(d.Get("identity").([]interface{}))
			if err != nil {
				return fmt.Errorf("expanding `identity`: %+v", err)
			}
			payload.Identity = expanded
		}

		if d.HasChange("transparent_data_encryption_key_vault_key_id") {
			keyVaultKeyId := d.Get(("transparent_data_encryption_key_vault_key_id")).(string)

			keyId, err := keyVaultParser.ParseNestedItemID(keyVaultKeyId)
			if err != nil {
				return fmt.Errorf("unable to parse key: %q: %+v", keyVaultKeyId, err)
			}

			if keyId.NestedItemType == keyVaultParser.NestedItemTypeKey {
				payload.Properties.KeyId = pointer.To(keyId.ID())
			} else {
				return fmt.Errorf("key vault key id must be a reference to a key, got %s", keyId.NestedItemType)
			}
		}

		if primaryUserAssignedIdentityID, ok := d.GetOk("primary_user_assigned_identity_id"); ok {
			payload.Properties.PrimaryUserAssignedIdentityId = pointer.To(primaryUserAssignedIdentityID.(string))
		}

		payload.Properties.PublicNetworkAccess = pointer.To(servers.ServerPublicNetworkAccessFlagDisabled)
		payload.Properties.RestrictOutboundNetworkAccess = pointer.To(servers.ServerNetworkAccessFlagDisabled)

		if v := d.Get("public_network_access_enabled"); v.(bool) {
			payload.Properties.PublicNetworkAccess = pointer.To(servers.ServerPublicNetworkAccessFlagEnabled)
		}

		if v := d.Get("outbound_network_restriction_enabled"); v.(bool) {
			payload.Properties.RestrictOutboundNetworkAccess = pointer.To(servers.ServerNetworkAccessFlagEnabled)
		}

		if d.HasChange("administrator_login_password") {
			adminPassword := d.Get("administrator_login_password").(string)
			payload.Properties.AdministratorLoginPassword = pointer.To(adminPassword)
		}

		if d.HasChange("minimum_tls_version") {
			payload.Properties.MinimalTlsVersion = pointer.To(servers.MinimalTlsVersion(d.Get("minimum_tls_version").(string)))
		}

		err := client.CreateOrUpdateThenPoll(ctx, *id, *payload)
		if err != nil {
			return fmt.Errorf("updating %s: %+v", id, err)
		}
	}

	if d.HasChange("azuread_administrator") {
		// need to check if aadOnly is enabled or not before calling delete, else you will get the following error:
		// InvalidServerAADOnlyAuthNoAADAdminPropertyName: AAD Admin is not configured, AAD Admin must be set
		// before enabling/disabling AAD Only Authentication.
		log.Printf("[INFO] Checking if Azure Active Directory Administrators exist")
		aadOnlyAdmin := false

		resp, err := adminClient.Get(ctx, pointer.From(id))
		if err != nil {
			if !response.WasNotFound(resp.HttpResponse) {
				return fmt.Errorf("retrieving Azure Active Directory Administrators %s: %+v", pointer.From(id), err)
			}
		} else {
			aadOnlyAdmin = true
		}

		if aadOnlyAdmin {
			resp, err := aadOnlyAuthenticationsClient.Delete(ctx, *id)
			if err != nil {
				log.Printf("[INFO] Deletion of Azure Active Directory Only Authentication failed for %s: %+v", pointer.From(id), err)
				return fmt.Errorf("deleting Azure Active Directory Only Authentications for %s: %+v", pointer.From(id), err)
			}

			// NOTE: This call does not return a future it returns a response, but you will get a future back if the status code is 202...
			// https://learn.microsoft.com/en-us/rest/api/sql/server-azure-ad-only-authentications/delete?view=rest-sql-2023-05-01-preview&tabs=HTTP
			if response.WasStatusCode(resp.HttpResponse, 202) {
				// NOTE: It was accepted but not completed, it is now an async operation...
				// create a custom poller and wait for it to complete as 'Succeeded'...
				log.Printf("[INFO] Delete Azure Active Directory Only Administrators response was a 202 WaitForStateContext...")

				initialDelayDuration := 5 * time.Second
				pollerType := custompollers.NewMsSqlServerDeleteServerAzureADOnlyAuthenticationPoller(aadOnlyAuthenticationsClient, pointer.From(id))
				poller := pollers.NewPoller(pollerType, initialDelayDuration, pollers.DefaultNumberOfDroppedConnectionsToAllow)
				if err := poller.PollUntilDone(ctx); err != nil {
					return fmt.Errorf("waiting for the deletion of the Azure Active Directory Only Administrator: %+v", err)
				}
			}
		}

		log.Printf("[INFO] Expanding 'azuread_administrator' to see if we need Create or Delete")
		if adminProps := expandMsSqlServerAdministrator(d.Get("azuread_administrator").([]interface{})); adminProps != nil {
			err := adminClient.CreateOrUpdateThenPoll(ctx, *id, pointer.From(adminProps))
			if err != nil {
				return fmt.Errorf("creating Azure Active Directory Administrator %s: %+v", id, err)
			}
		} else {
			_, err := adminClient.Get(ctx, *id)
			if err != nil {
				return fmt.Errorf("retrieving Azure Active Directory Administrator %s: %+v", id, err)
			}

			err = adminClient.DeleteThenPoll(ctx, *id)
			if err != nil {
				return fmt.Errorf("deleting Azure Active Directory Administrator %s: %+v", id, err)
			}
		}
	}

	if aadOnlyAuthentictionsEnabled := expandMsSqlServerAADOnlyAuthentictions(d.Get("azuread_administrator").([]interface{})); d.HasChange("azuread_administrator") && aadOnlyAuthentictionsEnabled {
		aadOnlyAuthentictionsProps := serverazureadonlyauthentications.ServerAzureADOnlyAuthentication{
			Properties: &serverazureadonlyauthentications.AzureADOnlyAuthProperties{
				AzureADOnlyAuthentication: aadOnlyAuthentictionsEnabled,
			},
		}

		err := aadOnlyAuthenticationsClient.CreateOrUpdateThenPoll(ctx, *id, aadOnlyAuthentictionsProps)
		if err != nil {
			return fmt.Errorf("updating Azure Active Directory Only Authentication for %s: %+v", id, err)
		}
	}

	connection := serverconnectionpolicies.ServerConnectionPolicy{
		Properties: &serverconnectionpolicies.ServerConnectionPolicyProperties{
			ConnectionType: serverconnectionpolicies.ServerConnectionType(d.Get("connection_policy").(string)),
		},
	}

	if err = connectionClient.CreateOrUpdateThenPoll(ctx, *id, connection); err != nil {
		return fmt.Errorf("updating request for Connection Policy %s: %+v", id, err)
	}

	return resourceMsSqlServerRead(d, meta)
}
