package github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/services/preview/sql/mgmt/v5.0/sql" // nolint: staticcheck
	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/maintenance/2023-04-01/publicmaintenanceconfigurations"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/backupshorttermretentionpolicies"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/databases"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/databasesecurityalertpolicies"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/elasticpools"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/geobackuppolicies"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/longtermretentionpolicies"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/servers"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/serversecurityalertpolicies"
	"github.com/hashicorp/go-azure-sdk/resource-manager/sql/2023-08-01-preview/transparentdataencryptions"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	helperValidate "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	keyVaultParser "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql/helper"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/mssql/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceMsSqlDatabaseRead(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).MSSQL.DatabasesClient
	securityAlertPoliciesClient := meta.(*clients.Client).MSSQL.DatabaseSecurityAlertPoliciesClient

	longTermRetentionClient := meta.(*clients.Client).MSSQL.LongTermRetentionPoliciesClient
	shortTermRetentionClient := meta.(*clients.Client).MSSQL.BackupShortTermRetentionPoliciesClient
	geoBackupPoliciesClient := meta.(*clients.Client).MSSQL.GeoBackupPoliciesClient
	transparentEncryptionClient := meta.(*clients.Client).MSSQL.TransparentDataEncryptionsClient

	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := commonids.ParseSqlDatabaseID(d.Id())
	if err != nil {
		return err
	}

	serverId := commonids.NewSqlServerID(id.SubscriptionId, id.ResourceGroupName, id.ServerName)
	d.Set("server_id", serverId.ID())

	resp, err := client.Get(ctx, pointer.From(id), databases.DefaultGetOperationOptions())
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			d.SetId("")
			return nil
		}
		return fmt.Errorf("retrieving %s: %+v", id, err)
	}

	geoBackupPolicy := true
	skuName := ""
	elasticPoolId := ""
	ledgerEnabled := false
	enclaveType := ""

	if model := resp.Model; model != nil {
		d.Set("name", id.DatabaseName)

		if props := model.Properties; props != nil {
			minCapacity := pointer.From(props.MinCapacity)

			requestedBackupStorageRedundancy := ""
			if props.RequestedBackupStorageRedundancy != nil {
				requestedBackupStorageRedundancy = string(*props.RequestedBackupStorageRedundancy)
			}

			// A named replica doesn't return props.RequestedBackupStorageRedundancy from the api but it is Geo in the portal regardless of what the parent database has
			// so we'll copy that here to get around a perpetual diff
			if props.SecondaryType != nil && *props.SecondaryType == "Named" {
				requestedBackupStorageRedundancy = string(databases.BackupStorageRedundancyGeo)
			}

			d.Set("auto_pause_delay_in_minutes", pointer.From(props.AutoPauseDelay))
			d.Set("collation", pointer.From(props.Collation))
			d.Set("read_replica_count", pointer.From(props.HighAvailabilityReplicaCount))
			d.Set("storage_account_type", requestedBackupStorageRedundancy)
			d.Set("zone_redundant", pointer.From(props.ZoneRedundant))
			d.Set("read_scale", pointer.From(props.ReadScale) == databases.DatabaseReadScaleEnabled)
			d.Set("secondary_type", pointer.From(props.SecondaryType))

			if props.ElasticPoolId != nil {
				elasticPoolId = pointer.From(props.ElasticPoolId)
			}

			if props.LicenseType != nil {
				d.Set("license_type", string(pointer.From(props.LicenseType)))
			} else {
				// value not returned, try to set from state
				d.Set("license_type", d.Get("license_type").(string))
			}

			if props.MaxSizeBytes != nil {
				d.Set("max_size_gb", int32((*props.MaxSizeBytes)/int64(1073741824)))
			}

			if props.CurrentServiceObjectiveName != nil {
				skuName = *props.CurrentServiceObjectiveName
			}

			if props.IsLedgerOn != nil {
				ledgerEnabled = *props.IsLedgerOn
			}

			// NOTE: Always set the PreferredEnclaveType to an empty string
			// if not in the properties that were returned from Azure...
			if v := props.PreferredEnclaveType; v != nil {
				enclaveType = string(pointer.From(v))
			}

			configurationName := ""
			if v := props.MaintenanceConfigurationId; v != nil {
				maintenanceConfigId, err := publicmaintenanceconfigurations.ParsePublicMaintenanceConfigurationIDInsensitively(pointer.From(v))
				if err != nil {
					return err
				}
				configurationName = maintenanceConfigId.PublicMaintenanceConfigurationName
			}

			d.Set("elastic_pool_id", elasticPoolId)
			d.Set("min_capacity", minCapacity)
			d.Set("sku_name", skuName)
			d.Set("maintenance_configuration_name", configurationName)
			d.Set("ledger_enabled", ledgerEnabled)
			d.Set("enclave_type", enclaveType)
			d.Set("transparent_data_encryption_key_vault_key_id", props.EncryptionProtector)
			d.Set("transparent_data_encryption_key_automatic_rotation_enabled", pointer.From(props.EncryptionProtectorAutoRotation))

			identity, err := identity.FlattenUserAssignedMap(model.Identity)
			if err != nil {
				return fmt.Errorf("setting `identity`: %+v", err)
			}

			if err := d.Set("identity", identity); err != nil {
				return fmt.Errorf("setting `identity`: %+v", err)
			}

			if err := tags.FlattenAndSet(d, model.Tags); err != nil {
				return err
			}
		}

		// Determine whether the SKU is for SQL Data Warehouse
		isDwSku := strings.HasPrefix(strings.ToLower(skuName), "dw")

		// Determine whether the SKU is for SQL Database Free tier
		isFreeSku := strings.EqualFold(skuName, "free")

		// DW SKUs and SQL Database Free tier do not currently support LRP and do not honour normal SRP operations
		if !isDwSku && !isFreeSku {
			longTermPolicy, err := longTermRetentionClient.Get(ctx, pointer.From(id))
			if err != nil {
				return fmt.Errorf("retrieving Long Term Retention Policies for %s: %+v", id, err)
			}

			if longTermPolicyModel := longTermPolicy.Model; longTermPolicyModel != nil {
				if err := d.Set("long_term_retention_policy", helper.FlattenLongTermRetentionPolicy(longTermPolicyModel)); err != nil {
					return fmt.Errorf("setting `long_term_retention_policy`: %+v", err)
				}
			}

			shortTermPolicy, err := shortTermRetentionClient.Get(ctx, pointer.From(id))
			if err != nil {
				return fmt.Errorf("retrieving Short Term Retention Policies for %s: %+v", id, err)
			}

			if shortTermPolicyModel := shortTermPolicy.Model; shortTermPolicyModel != nil {
				if err := d.Set("short_term_retention_policy", helper.FlattenShortTermRetentionPolicy(shortTermPolicyModel)); err != nil {
					return fmt.Errorf("setting `short_term_retention_policy`: %+v", err)
				}
			}
		} else {
			// DW SKUs and SQL Database Free tier need the retention policies to be empty for state consistency
			emptySlice := make([]interface{}, 0)
			d.Set("long_term_retention_policy", emptySlice)
			d.Set("short_term_retention_policy", emptySlice)

			geoPoliciesResponse, err := geoBackupPoliciesClient.Get(ctx, pointer.From(id))
			if err != nil {
				if response.WasNotFound(geoPoliciesResponse.HttpResponse) {
					d.SetId("")
					return nil
				}

				return fmt.Errorf("retrieving Geo Backup Policies for %s: %+v", id, err)
			}

			// For Datawarehouse SKUs and SQL Database Free tier, set the geo-backup policy setting
			if geoPolicyModel := geoPoliciesResponse.Model; geoPolicyModel != nil {
				if (isDwSku || isFreeSku) && geoPolicyModel.Properties.State == geobackuppolicies.GeoBackupPolicyStateDisabled {
					geoBackupPolicy = false
				}
			}
		}
	}

	if err := d.Set("geo_backup_enabled", geoBackupPolicy); err != nil {
		return fmt.Errorf("setting `geo_backup_enabled`: %+v", err)
	}

	securityAlertPolicy, err := securityAlertPoliciesClient.Get(ctx, pointer.From(id))
	if err == nil && securityAlertPolicy.Model != nil {
		if err := d.Set("threat_detection_policy", flattenMsSqlServerSecurityAlertPolicy(d, pointer.From(securityAlertPolicy.Model))); err != nil {
			return fmt.Errorf("setting `threat_detection_policy`: %+v", err)
		}
	}

	tde, err := transparentEncryptionClient.Get(ctx, pointer.From(id))
	if err != nil {
		return fmt.Errorf("while retrieving Transparent Data Encryption state for %s: %+v", id, err)
	}

	tdeState := false
	if model := tde.Model; model != nil {
		if props := model.Properties; props != nil {
			tdeState = (props.State == transparentdataencryptions.TransparentDataEncryptionStateEnabled)
		}
	}
	d.Set("transparent_data_encryption_enabled", tdeState)

	return nil
}
