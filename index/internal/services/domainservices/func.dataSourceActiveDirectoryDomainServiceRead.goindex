package github.com/hashicorp/terraform-provider-azurerm/internal/services/domainservices
import (
	"fmt"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/aad/2021-05-01/domainservices"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func dataSourceActiveDirectoryDomainServiceRead(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).DomainServices.DomainServicesClient
	subscrptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	name := d.Get("name").(string)
	resourceGroup := d.Get("resource_group_name").(string)

	idsdk := domainservices.NewDomainServiceID(subscrptionId, resourceGroup, name)

	resp, err := client.Get(ctx, idsdk)
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			return nil
		}
		return err
	}

	model := resp.Model
	if model == nil {
		return fmt.Errorf("reading Domain Service: model was returned nil")
	}

	if model.Id == nil {
		return fmt.Errorf("reading Domain Service: ID was returned nil")
	}

	d.SetId(idsdk.ID())

	d.Set("name", name)
	d.Set("resource_group_name", resourceGroup)
	d.Set("location", location.NormalizeNilable(model.Location))
	if err := tags.FlattenAndSet(d, model.Tags); err != nil {
		return err
	}

	if props := model.Properties; props != nil {
		d.Set("deployment_id", props.DeploymentId)

		domainConfigType := ""
		if v := props.DomainConfigurationType; v != nil {
			domainConfigType = *v
		}
		d.Set("domain_configuration_type", domainConfigType)

		d.Set("domain_name", props.DomainName)

		d.Set("filtered_sync_enabled", false)
		if props.FilteredSync != nil && *props.FilteredSync == domainservices.FilteredSyncEnabled {
			d.Set("filtered_sync_enabled", true)
		}

		d.Set("resource_id", model.Id)
		d.Set("sku", props.Sku)
		d.Set("sync_owner", props.SyncOwner)
		d.Set("tenant_id", props.TenantId)
		d.Set("version", props.Version)

		if err := d.Set("notifications", flattenDomainServiceNotifications(props.NotificationSettings)); err != nil {
			return fmt.Errorf("setting `notifications`: %+v", err)
		}

		if err := d.Set("secure_ldap", flattenDomainServiceLdaps(d, props.LdapsSettings, true)); err != nil {
			return fmt.Errorf("setting `secure_ldap`: %+v", err)
		}

		if err := d.Set("security", flattenDomainServiceSecurity(props.DomainSecuritySettings)); err != nil {
			return fmt.Errorf("setting `security`: %+v", err)
		}

		replicaSets := flattenDomainServiceReplicaSets(props.ReplicaSets)
		if err := d.Set("replica_sets", replicaSets); err != nil {
			return fmt.Errorf("setting `replica_sets`: %+v", err)
		}
	}

	return nil
}
