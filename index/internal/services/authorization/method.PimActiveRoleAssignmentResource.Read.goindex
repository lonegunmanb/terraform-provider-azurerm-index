package github.com/hashicorp/terraform-provider-azurerm/internal/services/authorization
import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/authorization/2020-10-01/roleassignmentschedulerequests"
	"github.com/hashicorp/go-azure-sdk/resource-manager/authorization/2020-10-01/roleassignmentschedules"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/authorization/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/authorization/validate"
	billingValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/billing/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (r PimActiveRoleAssignmentResource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,

		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			schedulesClient := metadata.Client.Authorization.RoleAssignmentSchedulesClient
			requestsClient := metadata.Client.Authorization.RoleAssignmentScheduleRequestClient

			// Retrieve existing state as we may not be able to populate everything after the initial request has expired
			var state PimActiveRoleAssignmentModel
			if err := metadata.Decode(&state); err != nil {
				return err
			}

			id, err := parse.PimRoleAssignmentID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}

			// Look for a Schedule for this role assignment. Note that the Schedule ID changes each time the assignment is manipulated,
			// whilst still remaining valid for the configured role, scope and principal, so we must search for it.
			schedule, err := findRoleAssignmentSchedule(ctx, schedulesClient, *id)
			if err != nil {
				return err
			}
			if schedule == nil {
				return metadata.MarkAsGone(id)
			}

			// Look for the latest associated assignment request as this contains some fields we want
			request, err := findRoleAssignmentScheduleRequest(ctx, requestsClient, schedule, id)
			if err != nil {
				return err
			}

			state.Scope = id.Scope

			// PIM Role Assignments are represented by a Schedule object and one or more Request objects that comprise the audit history. Requests return
			// more information, but expire after 45 days, so after this time we can only partially populate the resource attributes from the Schedule.
			if request != nil && request.Properties != nil {
				// A request is still present and was found, so populate from the request
				state.Justification = pointer.From(request.Properties.Justification)
				state.PrincipalId = request.Properties.PrincipalId
				state.PrincipalType = string(pointer.From(request.Properties.PrincipalType))
				state.RoleDefinitionId = request.Properties.RoleDefinitionId

				if ticketInfo := request.Properties.TicketInfo; ticketInfo != nil {
					if len(state.TicketInfo) == 0 {
						state.TicketInfo = make([]PimActiveRoleAssignmentTicketInfo, 1)
					}

					if ticketInfo.TicketNumber != nil {
						state.TicketInfo[0].TicketNumber = *ticketInfo.TicketNumber
					}
					if ticketInfo.TicketSystem != nil {
						state.TicketInfo[0].TicketSystem = *ticketInfo.TicketSystem
					}
				}

				if scheduleInfo := request.Properties.ScheduleInfo; scheduleInfo != nil {
					if len(state.ScheduleInfo) == 0 {
						state.ScheduleInfo = make([]PimActiveRoleAssignmentScheduleInfo, 1)
					}

					// Only set the StartDateTime if not already present in state, because the value returned by the server advances
					// in short intervals until the request has been fully processed, causing unnecessary persistent diffs
					if state.ScheduleInfo[0].StartDateTime == "" && scheduleInfo.StartDateTime != nil {
						state.ScheduleInfo[0].StartDateTime = *scheduleInfo.StartDateTime
					}

					if expiration := scheduleInfo.Expiration; expiration != nil {
						if len(state.ScheduleInfo[0].Expiration) == 0 {
							state.ScheduleInfo[0].Expiration = make([]PimActiveRoleAssignmentScheduleInfoExpiration, 1)
						}

						// Only set the EndDateTime if not already present in state, because the value returned by the server advances
						// in short intervals until the request has been fully processed, causing unnecessary persistent diffs
						if state.ScheduleInfo[0].Expiration[0].EndDateTime == "" && expiration.EndDateTime != nil {
							state.ScheduleInfo[0].Expiration[0].EndDateTime = pointer.From(expiration.EndDateTime)
						}

						if expiration.Duration != nil && *expiration.Duration != "" {
							durationRaw := *expiration.Duration

							reHours := regexp.MustCompile(`PT(\d+)H`)
							matches := reHours.FindStringSubmatch(durationRaw)
							if len(matches) == 2 {
								hours, err := strconv.ParseInt(matches[1], 10, 0)
								if err != nil {
									return fmt.Errorf("parsing duration: %+v", err)
								}
								state.ScheduleInfo[0].Expiration[0].DurationHours = hours
							}

							reDays := regexp.MustCompile(`P(\d+)D`)
							matches = reDays.FindStringSubmatch(durationRaw)
							if len(matches) == 2 {
								days, err := strconv.ParseInt(matches[1], 10, 0)
								if err != nil {
									return fmt.Errorf("parsing duration: %+v", err)
								}
								state.ScheduleInfo[0].Expiration[0].DurationDays = days
							}
						}
					}
				}
			} else if props := schedule.Properties; props != nil {
				// The request has likely expired, so populate from the schedule (not all fields will be available)
				state.PrincipalId = pointer.From(props.PrincipalId)
				state.PrincipalType = string(pointer.From(props.PrincipalType))
				state.RoleDefinitionId = pointer.From(props.RoleDefinitionId)

				if props.StartDateTime != nil {
					if len(state.ScheduleInfo) == 0 {
						state.ScheduleInfo = make([]PimActiveRoleAssignmentScheduleInfo, 1)
					}

					// Only set the StartDateTime if not already present in state, because the value returned by the server advances
					// in short intervals until the request has been fully processed, causing unnecessary persistent diffs
					if state.ScheduleInfo[0].StartDateTime == "" {
						state.ScheduleInfo[0].StartDateTime = *props.StartDateTime
					}
				}

				if props.EndDateTime != nil {
					if len(state.ScheduleInfo) == 0 {
						state.ScheduleInfo = make([]PimActiveRoleAssignmentScheduleInfo, 1)
					}
					if len(state.ScheduleInfo[0].Expiration) == 0 {
						state.ScheduleInfo[0].Expiration = make([]PimActiveRoleAssignmentScheduleInfoExpiration, 1)
					}

					// Only set the EndDateTime if not already present in state, because the value returned by the server advances
					// in short intervals until the request has been fully processed, causing unnecessary persistent diffs
					if state.ScheduleInfo[0].Expiration[0].EndDateTime == "" {
						state.ScheduleInfo[0].Expiration[0].EndDateTime = *props.EndDateTime
					}
				}
			}

			return metadata.Encode(&state)
		},
	}
}
