package github.com/hashicorp/terraform-provider-azurerm/internal/services/authorization
import (
	"context"
	"fmt"
	"log"
	"regexp"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/authorization/2022-04-01/roleassignments"
	"github.com/hashicorp/go-azure-sdk/resource-manager/authorization/2022-05-01-preview/roledefinitions"
	"github.com/hashicorp/go-azure-sdk/resource-manager/resources/2022-12-01/subscriptions"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/authorization/parse"
	billingValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/billing/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceArmRoleAssignmentRead(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Authorization.ScopedRoleAssignmentsClient
	roleDefinitionsClient := meta.(*clients.Client).Authorization.ScopedRoleDefinitionsClient
	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := parse.ScopedRoleAssignmentID(d.Id())
	if err != nil {
		return err
	}

	options := roleassignments.DefaultGetOperationOptions()
	if id.TenantId != "" {
		options.TenantId = pointer.To(id.TenantId)
	}

	resp, err := client.Get(ctx, id.ScopedId, options)
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			log.Printf("[DEBUG] %s was not found - removing from state", *id)
			d.SetId("")
			return nil
		}

		return fmt.Errorf("retrieving %s: %+v", *id, err)
	}

	if model := resp.Model; model != nil {
		d.Set("name", model.Name)

		if props := model.Properties; props != nil {
			d.Set("scope", normalizeScopeValue(pointer.From(props.Scope)))
			d.Set("role_definition_id", props.RoleDefinitionId)
			d.Set("principal_id", props.PrincipalId)
			d.Set("principal_type", pointer.From(props.PrincipalType))
			d.Set("delegated_managed_identity_resource_id", props.DelegatedManagedIdentityResourceId)
			d.Set("description", props.Description)
			d.Set("condition", props.Condition)
			d.Set("condition_version", props.ConditionVersion)

			if roleDefResourceId := props.RoleDefinitionId; roleDefResourceId != "" {
				// Workaround for https://github.com/hashicorp/pandora/issues/3257
				// The role definition id returned does not contain scope when the role definition was on tenant level (management group or tenant).
				// And adding tenant id as scope will cause 404 response, so just adding a slash to parse that.
				if strings.HasPrefix(roleDefResourceId, "/providers") {
					roleDefResourceId = fmt.Sprintf("/%s", roleDefResourceId)
				}
				parsedRoleDefId, err := roledefinitions.ParseScopedRoleDefinitionID(roleDefResourceId)
				if err != nil {
					return fmt.Errorf("parsing %q: %+v", roleDefResourceId, err)
				}
				roleResp, err := roleDefinitionsClient.Get(ctx, *parsedRoleDefId)
				if err != nil {
					return fmt.Errorf("retrieving Role Definition %q: %+v", roleDefResourceId, err)
				}
				if roleResp.Model != nil && roleResp.Model.Properties != nil {
					d.Set("role_definition_name", pointer.From(roleResp.Model.Properties.RoleName))
				}
			}
		}
	}

	return nil
}
