package github.com/hashicorp/terraform-provider-azurerm/internal/services/authorization
import (
	"context"
	"fmt"
	"regexp"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/authorization/2020-10-01/rolemanagementpolicies"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	billingValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/billing/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (r RoleManagementPolicyDataSource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.Authorization.RoleManagementPoliciesClient

			var config RoleManagementPolicyModel
			if err := metadata.Decode(&config); err != nil {
				return fmt.Errorf("decoding %+v", err)
			}

			id, err := FindRoleManagementPolicyId(ctx, metadata.Client.Authorization.RoleManagementPoliciesClient, config.Scope, config.RoleDefinitionId)
			if err != nil {
				return err
			}

			resp, err := client.Get(ctx, *id)
			if err != nil {
				if response.WasNotFound(resp.HttpResponse) {
					return fmt.Errorf("could not find Role Management Policy for Role Definition %q and Scope %q", config.RoleDefinitionId, config.Scope)
				}

				return fmt.Errorf("retrieving Role Management Policy for Role Definition %q and Scope %q: %+v", config.RoleDefinitionId, config.Scope, err)
			}

			state := RoleManagementPolicyDataSourceModel{
				Scope:            config.Scope,
				RoleDefinitionId: config.RoleDefinitionId,
			}

			if model := resp.Model; model != nil {
				state.Name = pointer.From(model.Name)

				if prop := model.Properties; prop != nil {
					state.Description = pointer.From(prop.Description)

					// Create the rules structure so we can populate them
					if len(state.EligibleAssignmentRules) == 0 {
						state.EligibleAssignmentRules = make([]RoleManagementPolicyDataSourceEligibleAssignmentRules, 1)
					}
					if len(state.ActiveAssignmentRules) == 0 {
						state.ActiveAssignmentRules = make([]RoleManagementPolicyDataSourceActiveAssignmentRules, 1)
					}
					if len(state.ActivationRules) == 0 {
						state.ActivationRules = make([]RoleManagementPolicyDataSourceActivationRules, 1)
					}
					if len(state.NotificationRules) == 0 {
						state.NotificationRules = make([]RoleManagementPolicyDataSourceNotificationEvents, 1)
					}
					if len(state.NotificationRules[0].EligibleActivations) == 0 {
						state.NotificationRules[0].EligibleActivations = make([]RoleManagementPolicyDataSourceNotificationRule, 1)
					}
					if len(state.NotificationRules[0].ActiveAssignments) == 0 {
						state.NotificationRules[0].ActiveAssignments = make([]RoleManagementPolicyDataSourceNotificationRule, 1)
					}
					if len(state.NotificationRules[0].EligibleAssignments) == 0 {
						state.NotificationRules[0].EligibleAssignments = make([]RoleManagementPolicyDataSourceNotificationRule, 1)
					}

					for _, r := range *prop.Rules {
						switch rule := r.(type) {
						case rolemanagementpolicies.RoleManagementPolicyAuthenticationContextRule:
							if rule.Id != nil && *rule.Id == "AuthenticationContext_EndUser_Assignment" {
								if rule.ClaimValue != nil && *rule.ClaimValue != "" {
									state.ActivationRules[0].RequireConditionalAccessContext = *rule.ClaimValue
								}
							}
						case rolemanagementpolicies.RoleManagementPolicyApprovalRule:
							if rule.Id != nil && *rule.Id == "Approval_EndUser_Assignment" {
								if rule.Setting != nil {
									settings := *rule.Setting
									state.ActivationRules[0].RequireApproval = pointer.From(settings.IsApprovalRequired)
									if settings.ApprovalStages != nil {
										approvalStages := *settings.ApprovalStages
										state.ActivationRules[0].ApprovalStages = make([]RoleManagementPolicyDataSourceApprovalStage, 1)
										approvalStage := approvalStages[0]
										if primaryApprovers := approvalStage.PrimaryApprovers; primaryApprovers != nil && len(*primaryApprovers) > 0 {
											state.ActivationRules[0].ApprovalStages[0].PrimaryApprovers = make([]RoleManagementPolicyDataSourceApprover, len(*primaryApprovers))
											for ia, pa := range *primaryApprovers {
												state.ActivationRules[0].ApprovalStages[0].PrimaryApprovers[ia] = RoleManagementPolicyDataSourceApprover{
													ID:   pointer.From(pa.Id),
													Type: string(pointer.From(pa.UserType)),
												}
											}
										}
									}
								}
							}
						case rolemanagementpolicies.RoleManagementPolicyEnablementRule:
							if rule.Id != nil && *rule.Id == "Enablement_Admin_Assignment" {
								state.ActiveAssignmentRules[0].RequireMultiFactorAuth = false
								state.ActiveAssignmentRules[0].RequireJustification = false

								if rule.EnabledRules != nil {
									for _, enabledRule := range *rule.EnabledRules {
										switch enabledRule {
										case rolemanagementpolicies.EnablementRulesMultiFactorAuthentication:
											state.ActiveAssignmentRules[0].RequireMultiFactorAuth = true
										case rolemanagementpolicies.EnablementRulesJustification:
											state.ActiveAssignmentRules[0].RequireJustification = true
										}
									}
								}
							}

							if rule.Id != nil && *rule.Id == "Enablement_EndUser_Assignment" {
								state.ActivationRules[0].RequireMultiFactorAuth = false
								state.ActivationRules[0].RequireJustification = false
								state.ActivationRules[0].RequireTicketInfo = false

								if rule.EnabledRules != nil {
									for _, enabledRule := range *rule.EnabledRules {
										switch enabledRule {
										case rolemanagementpolicies.EnablementRulesMultiFactorAuthentication:
											state.ActivationRules[0].RequireMultiFactorAuth = true
										case rolemanagementpolicies.EnablementRulesJustification:
											state.ActivationRules[0].RequireJustification = true
										case rolemanagementpolicies.EnablementRulesTicketing:
											state.ActivationRules[0].RequireTicketInfo = true
										}
									}
								}
							}

						case rolemanagementpolicies.RoleManagementPolicyExpirationRule:
							if rule.Id != nil {
								switch *rule.Id {
								case "Expiration_Admin_Eligibility":
									state.EligibleAssignmentRules[0].ExpirationRequired = pointer.From(rule.IsExpirationRequired)
									state.EligibleAssignmentRules[0].ExpireAfter = pointer.From(rule.MaximumDuration)

								case "Expiration_Admin_Assignment":
									state.ActiveAssignmentRules[0].ExpirationRequired = pointer.From(rule.IsExpirationRequired)
									state.ActiveAssignmentRules[0].ExpireAfter = pointer.From(rule.MaximumDuration)

								case "Expiration_EndUser_Assignment":
									state.ActivationRules[0].MaximumDuration = pointer.From(rule.MaximumDuration)
								}
							}
						case rolemanagementpolicies.RoleManagementPolicyNotificationRule:
							if rule.Id != nil {
								switch *rule.Id {
								case "Notification_Admin_Admin_Assignment":
									state.NotificationRules[0].ActiveAssignments[0].AdminNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Admin_Admin_Eligibility":
									state.NotificationRules[0].EligibleAssignments[0].AdminNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Admin_EndUser_Assignment":
									state.NotificationRules[0].EligibleActivations[0].AdminNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Approver_Admin_Assignment":
									state.NotificationRules[0].ActiveAssignments[0].ApproverNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Approver_Admin_Eligibility":
									state.NotificationRules[0].EligibleAssignments[0].ApproverNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Approver_EndUser_Assignment":
									state.NotificationRules[0].EligibleActivations[0].ApproverNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Requestor_Admin_Assignment":
									state.NotificationRules[0].ActiveAssignments[0].AssigneeNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Requestor_Admin_Eligibility":
									state.NotificationRules[0].EligibleAssignments[0].AssigneeNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}

								case "Notification_Requestor_EndUser_Assignment":
									state.NotificationRules[0].EligibleActivations[0].AssigneeNotifications = []RoleManagementPolicyDataSourceNotificationSettings{
										*flattenNotificationDataSourceSettings(rule),
									}
								}
							}
						}
					}
				}
			}

			metadata.SetID(id)
			return metadata.Encode(&state)
		},
	}
}
