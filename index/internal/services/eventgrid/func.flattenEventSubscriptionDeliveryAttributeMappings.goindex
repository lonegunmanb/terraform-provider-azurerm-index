package github.com/hashicorp/terraform-provider-azurerm/internal/services/eventgrid
import (
	"fmt"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/resource-manager/eventgrid/2025-02-15/eventsubscriptions"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func flattenEventSubscriptionDeliveryAttributeMappings(input eventsubscriptions.EventSubscriptionDestination, mappingsFromState []eventsubscriptions.DeliveryAttributeMapping) []interface{} {
	mappings := make([]eventsubscriptions.DeliveryAttributeMapping, 0)

	if v, ok := input.(eventsubscriptions.AzureFunctionEventSubscriptionDestination); ok && v.Properties != nil && v.Properties.DeliveryAttributeMappings != nil {
		mappings = *v.Properties.DeliveryAttributeMappings
	}
	if v, ok := input.(eventsubscriptions.EventHubEventSubscriptionDestination); ok && v.Properties != nil && v.Properties.DeliveryAttributeMappings != nil {
		mappings = *v.Properties.DeliveryAttributeMappings
	}
	if v, ok := input.(eventsubscriptions.HybridConnectionEventSubscriptionDestination); ok && v.Properties != nil && v.Properties.DeliveryAttributeMappings != nil {
		mappings = *v.Properties.DeliveryAttributeMappings
	}
	if v, ok := input.(eventsubscriptions.ServiceBusQueueEventSubscriptionDestination); ok && v.Properties != nil && v.Properties.DeliveryAttributeMappings != nil {
		mappings = *v.Properties.DeliveryAttributeMappings
	}
	if v, ok := input.(eventsubscriptions.ServiceBusTopicEventSubscriptionDestination); ok && v.Properties != nil && v.Properties.DeliveryAttributeMappings != nil {
		mappings = *v.Properties.DeliveryAttributeMappings
	}
	// NOTE: `StorageQueueEventSubscriptionDestination` doesn't contain DeliveryAttributeMappings
	if v, ok := input.(eventsubscriptions.WebHookEventSubscriptionDestination); ok && v.Properties != nil && v.Properties.DeliveryAttributeMappings != nil {
		mappings = *v.Properties.DeliveryAttributeMappings
	}

	output := make([]interface{}, 0)
	for _, mapping := range mappings {
		if val, ok := mapping.(eventsubscriptions.StaticDeliveryAttributeMapping); ok {
			secret := false
			value := ""
			if val.Properties != nil {
				if val.Properties.IsSecret != nil {
					secret = *val.Properties.IsSecret
				}
				if val.Properties.Value != nil {
					value = *val.Properties.Value
				}
				if secret {
					// If this is a secret, the Azure API just returns a value of 'Hidden',
					// so we need to lookup the value that was provided from config to return
					for _, v := range mappingsFromState {
						mapping, ok := v.(eventsubscriptions.StaticDeliveryAttributeMapping)
						if ok && mapping.Name != nil && val.Name != nil && *mapping.Name == *val.Name && mapping.Properties != nil && mapping.Properties.Value != nil {
							value = *mapping.Properties.Value
							break
						}
					}
				}
			}
			output = append(output, map[string]interface{}{
				"header_name": pointer.From(val.Name),
				"secret":      secret,
				"type":        "Static",
				"value":       value,
			})
		}

		if val, ok := mapping.(eventsubscriptions.DynamicDeliveryAttributeMapping); ok {
			sourceField := ""
			if val.Properties != nil && val.Properties.SourceField != nil {
				sourceField = *val.Properties.SourceField
			}
			output = append(output, map[string]interface{}{
				"header_name":  pointer.From(val.Name),
				"source_field": sourceField,
				"type":         "Dynamic",
			})
		}
	}

	return output
}
