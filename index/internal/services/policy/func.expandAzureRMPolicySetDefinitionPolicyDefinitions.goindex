package github.com/hashicorp/terraform-provider-azurerm/internal/services/policy
import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"regexp"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/resource-manager/resources/2025-01-01/policysetdefinitions"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	mgmtGrpParse "github.com/hashicorp/terraform-provider-azurerm/internal/services/managementgroup/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/policy/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/policy/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/policy/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func expandAzureRMPolicySetDefinitionPolicyDefinitions(input []interface{}, resourceData *pluginsdk.ResourceData) ([]policysetdefinitions.PolicyDefinitionReference, error) {
	result := make([]policysetdefinitions.PolicyDefinitionReference, 0)

	for idx, item := range input {
		v := item.(map[string]interface{})

		var parameters map[string]policysetdefinitions.ParameterValuesValue
		if p, ok := v["parameter_values"].(string); ok && p != "" {
			parameters = make(map[string]policysetdefinitions.ParameterValuesValue)
			if err := json.Unmarshal([]byte(p), &parameters); err != nil {
				return nil, fmt.Errorf("unmarshalling `parameter_values`: %+v", err)
			}
		}

		reference := policysetdefinitions.PolicyDefinitionReference{
			PolicyDefinitionId:          v["policy_definition_id"].(string),
			Parameters:                  pointer.To(parameters),
			PolicyDefinitionReferenceId: pointer.To(v["reference_id"].(string)),
			GroupNames:                  utils.ExpandStringSlice(v["policy_group_names"].(*pluginsdk.Set).List()),
		}

		// The API returns an error if we send an empty string
		if version := v["version"].(string); version != "" {
			path := fmt.Sprintf("policy_definition_reference.%d.version", idx)

			// We need to check the version value using RawConfig due to how Terraform manages blocks with computed nested items.
			// E.g. in a list of 3 `policy_definition_reference` blocks, if the middle (index 1) block is removed
			// the `version` argument contains the value from state as it's considered unchanged. However, due to the "shifted"
			// indexes, the `version` previously computed/returned by Azure may be incorrect for the `policy_definition_id`
			// it is now associated with, leading to a 400 Bad Request error from Azure.
			rawVersion, diags := resourceData.GetRawConfigAt(sdk.ConstructCtyPath(path))
			if diags.HasError() {
				return nil, fmt.Errorf("retrieving value at path `%s`: %+v", path, diags)
			}

			if !rawVersion.IsNull() {
				reference.DefinitionVersion = pointer.To(v["version"].(string))
			}
		}

		result = append(result, reference)
	}

	return result, nil
}
