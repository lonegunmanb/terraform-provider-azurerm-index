package github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn
import (
	"fmt"
	"time"

	"github.com/Azure/azure-sdk-for-go/services/cdn/mgmt/2021-06-01/cdn" // nolint: staticcheck
	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-sdk/resource-manager/cdn/2024-02-01/profiles"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-11-01/privatelinkservices"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/azuresdkhacks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceCdnFrontDoorOriginUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Cdn.FrontDoorOriginsClient
	workaroundClient := azuresdkhacks.NewCdnFrontDoorOriginsWorkaroundClient(client)
	profileClient := meta.(*clients.Client).Cdn.FrontDoorProfilesClient
	ctx, cancel := timeouts.ForUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := parse.FrontDoorOriginID(d.Id())
	if err != nil {
		return err
	}

	params := &azuresdkhacks.AFDOriginUpdatePropertiesParameters{}

	if d.HasChange("certificate_name_check_enabled") {
		params.EnforceCertificateNameCheck = utils.Bool(d.Get("certificate_name_check_enabled").(bool))
	}

	if d.HasChange("enabled") {
		params.EnabledState = expandEnabledBool(d.Get("enabled").(bool))
	}

	if d.HasChange("host_name") {
		params.HostName = utils.String(d.Get("host_name").(string))
	}

	if d.HasChange("http_port") {
		params.HTTPPort = utils.Int32(int32(d.Get("http_port").(int)))
	}

	if d.HasChange("https_port") {
		params.HTTPSPort = utils.Int32(int32(d.Get("https_port").(int)))
	}

	// The API requires that an explicit null be passed as the 'origin_host_header' value to remove the origin host header, see issue #20617
	// Since null is a valid value, we now have to always pass the value during update else we will inadvertently clear the value, see issue #20866
	params.OriginHostHeader = nil
	if d.Get("origin_host_header").(string) != "" {
		params.OriginHostHeader = utils.String(d.Get("origin_host_header").(string))
	}

	if d.HasChange("private_link") {
		// I need to get the profile SKU so I know if it is valid or not to define a private link as
		// private links are only allowed in the premium sku...
		profileId := profiles.NewProfileID(id.SubscriptionId, id.ResourceGroup, id.ProfileName)

		profileResp, err := profileClient.Get(ctx, profileId)
		if err != nil {
			if response.WasNotFound(profileResp.HttpResponse) {
				return fmt.Errorf("retrieving parent %s: not found", profileId)
			}

			return fmt.Errorf("retrieving parent %s: %+v", profileId, err)
		}

		profileModel := profileResp.Model

		if profileModel == nil {
			return fmt.Errorf("profileModel is 'nil'")
		}

		if profileModel.Sku.Name == nil {
			return fmt.Errorf("retrieving parent %s: 'profileModel.Sku.Name' was 'nil'", profileId)
		}

		enableCertNameCheck := d.Get("certificate_name_check_enabled").(bool)
		privateLinkSettings, err := expandPrivateLinkSettings(d.Get("private_link").([]interface{}), pointer.From(profileModel.Sku.Name), enableCertNameCheck)
		if err != nil {
			return err
		}

		params.SharedPrivateLinkResource = privateLinkSettings
	}

	if d.HasChange("priority") {
		params.Priority = utils.Int32(int32(d.Get("priority").(int)))
	}

	if d.HasChange("weight") {
		params.Weight = utils.Int32(int32(d.Get("weight").(int)))
	}

	payload := &azuresdkhacks.AFDOriginUpdateParameters{
		AFDOriginUpdatePropertiesParameters: params,
	}

	future, err := workaroundClient.Update(ctx, id.ResourceGroup, id.ProfileName, id.OriginGroupName, id.OriginName, *payload)
	if err != nil {
		return fmt.Errorf("updating %s: %+v", *id, err)
	}

	if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
		return fmt.Errorf("waiting for the update of %s: %+v", *id, err)
	}

	return resourceCdnFrontDoorOriginRead(d, meta)
}
