package github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn
import (
	"fmt"
	"time"

	"github.com/Azure/azure-sdk-for-go/services/cdn/mgmt/2021-06-01/cdn" // nolint: staticcheck
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/azuresdkhacks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceCdnFrontDoorRouteUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Cdn.FrontDoorRoutesClient
	workaroundsClient := azuresdkhacks.NewCdnFrontDoorRoutesWorkaroundClient(client)
	ctx, cancel := timeouts.ForUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := parse.FrontDoorRouteID(d.Id())
	if err != nil {
		return err
	}

	existing, err := client.Get(ctx, id.ResourceGroup, id.ProfileName, id.AfdEndpointName, id.RouteName)
	if err != nil {
		return fmt.Errorf("retrieving existing %s: %+v", *id, err)
	}

	if existing.RouteProperties == nil {
		return fmt.Errorf("retrieving existing %s: 'properties' was nil", *id)
	}

	// we need to lock the route for update because the custom domain
	// association may also be trying to update the route as well...
	locks.ByName(id.RouteName, cdnFrontDoorRouteResourceName)
	defer locks.UnlockByName(id.RouteName, cdnFrontDoorRouteResourceName)

	httpsRedirect := d.Get("https_redirect_enabled").(bool)
	protocolsRaw := d.Get("supported_protocols").(*pluginsdk.Set).List()
	customDomainsRaw := d.Get("cdn_frontdoor_custom_domain_ids").(*pluginsdk.Set).List()
	originGroupRaw := d.Get("cdn_frontdoor_origin_group_id").(string)
	ruleSetIdsRaw := d.Get("cdn_frontdoor_rule_set_ids").(*pluginsdk.Set).List()
	linkToDefaultDomain := d.Get("link_to_default_domain").(bool)

	// NOTE: If HTTPS Redirect is enabled the Supported Protocols must support both HTTP and HTTPS
	// This configuration does not cause an error when provisioned, however the http requests that
	// are supposed to be redirected to https remain http requests
	if httpsRedirect {
		if err := validate.SupportsBothHttpAndHttps(protocolsRaw, "https_redirect_enabled"); err != nil {
			return err
		}
	}

	originGroup, err := parse.FrontDoorOriginGroupID(originGroupRaw)
	if err != nil {
		return err
	}

	customDomains, err := expandCustomDomains(customDomainsRaw)
	if err != nil {
		return err
	}

	if !linkToDefaultDomain && len(customDomains) == 0 {
		return fmt.Errorf("it is invalid to disable the 'LinkToDefaultDomain' for the CDN Front Door Route(Name: %s) since the route does not have any CDN Front Door Custom Domains associated with it", id.RouteName)
	} else if len(customDomains) != 0 {
		if err := sliceHasDuplicates(customDomains, "CDN FrontDoor Custom Domain"); err != nil {
			return err
		}

		if err := validateRoutesCustomDomainProfile(customDomains, id.ProfileName); err != nil {
			return err
		}
	}

	// NOTE: You need to always pass these three on update else you will
	// disable your cache, disassociate your custom domains or remove your origin path...
	updateProps := azuresdkhacks.RouteUpdatePropertiesParameters{
		CustomDomains:      existing.CustomDomains,
		CacheConfiguration: existing.CacheConfiguration,
		OriginPath:         existing.OriginPath,
	}

	if d.HasChange("cache") {
		updateProps.CacheConfiguration = expandCdnFrontdoorRouteCacheConfiguration(d.Get("cache").([]interface{}))
	}

	if d.HasChange("enabled") {
		updateProps.EnabledState = expandEnabledBool(d.Get("enabled").(bool))
	}

	if d.HasChange("forwarding_protocol") {
		updateProps.ForwardingProtocol = cdn.ForwardingProtocol(d.Get("forwarding_protocol").(string))
	}

	if d.HasChange("https_redirect_enabled") {
		updateProps.HTTPSRedirect = expandEnabledBoolToRouteHttpsRedirect(httpsRedirect)
	}

	if d.HasChange("link_to_default_domain") {
		updateProps.LinkToDefaultDomain = expandEnabledBoolToLinkToDefaultDomain(d.Get("link_to_default_domain").(bool))
	}

	if d.HasChange("cdn_frontdoor_custom_domain_ids") {
		updateProps.CustomDomains = expandCustomDomainActivatedResourceArray(customDomains)
	}

	if d.HasChange("cdn_frontdoor_origin_group_id") {
		updateProps.OriginGroup = expandResourceReference(originGroup.ID())
	}

	if d.HasChange("cdn_frontdoor_origin_path") {
		updateProps.OriginPath = nil

		originPath := d.Get("cdn_frontdoor_origin_path").(string)
		if originPath != "" {
			updateProps.OriginPath = utils.String(originPath)
		}
	}

	if d.HasChange("patterns_to_match") {
		updateProps.PatternsToMatch = utils.ExpandStringSlice(d.Get("patterns_to_match").([]interface{}))
	}

	if d.HasChange("cdn_frontdoor_rule_set_ids") {
		ruleSets, err := expandRuleSetIds(ruleSetIdsRaw)
		if err != nil {
			return err
		}

		updateProps.RuleSets = expandRuleSetReferenceArray(ruleSets)
	}

	if d.HasChange("supported_protocols") {
		updateProps.SupportedProtocols = expandEndpointProtocolsArray(protocolsRaw)
	}

	updateParams := azuresdkhacks.RouteUpdateParameters{
		RouteUpdatePropertiesParameters: &updateProps,
	}

	future, err := workaroundsClient.Update(ctx, id.ResourceGroup, id.ProfileName, id.AfdEndpointName, id.RouteName, updateParams)
	if err != nil {
		return fmt.Errorf("updating %s: %+v", *id, err)
	}

	if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
		return fmt.Errorf("waiting for the update of %s: %+v", *id, err)
	}

	// NOTE: These are not sent to the API, they are only here so Terraform
	// can provision/destroy the resources in the correct order.
	if originIds := d.Get("cdn_frontdoor_origin_ids").([]interface{}); len(originIds) > 0 {
		d.Set("cdn_frontdoor_origin_ids", utils.ExpandStringSlice(originIds))
	}

	return resourceCdnFrontDoorRouteRead(d, meta)
}
