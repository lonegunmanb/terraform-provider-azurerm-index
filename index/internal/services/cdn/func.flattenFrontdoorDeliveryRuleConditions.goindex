package github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn
import (
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/resource-manager/cdn/2024-02-01/rulesets"
	"github.com/hashicorp/go-azure-sdk/resource-manager/cdn/2024-09-01/rules"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	cdnFrontDoorRuleActions "github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/frontdoorruleactions"
	cdnFrontDoorRuleConditions "github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/frontdoorruleconditions"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/cdn/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func flattenFrontdoorDeliveryRuleConditions(input *[]rules.DeliveryRuleCondition) ([]interface{}, error) {
	results := make([]interface{}, 0)
	if input == nil {
		return results, nil
	}

	c := cdnFrontDoorRuleConditions.InitializeCdnFrontDoorConditionMappings()

	clientPortCondition := make([]interface{}, 0)
	cookiesCondition := make([]interface{}, 0)
	hostNameCondition := make([]interface{}, 0)
	httpVersionCondition := make([]interface{}, 0)
	isDeviceCondition := make([]interface{}, 0)
	postArgsCondition := make([]interface{}, 0)
	queryStringCondition := make([]interface{}, 0)
	remoteAddressCondition := make([]interface{}, 0)
	requestBodyCondition := make([]interface{}, 0)
	requestHeaderCondition := make([]interface{}, 0)
	requestMethodCondition := make([]interface{}, 0)
	requestSchemeCondition := make([]interface{}, 0)
	requestURICondition := make([]interface{}, 0)
	serverPortCondition := make([]interface{}, 0)
	socketAddressCondition := make([]interface{}, 0)
	sslProtocolCondition := make([]interface{}, 0)
	urlFileExtensionCondition := make([]interface{}, 0)
	urlFilenameCondition := make([]interface{}, 0)
	urlPathCondition := make([]interface{}, 0)

	// input here is the base wrapper object that has all of the data from the model...
	for _, deliveryRuleCondition := range *input {
		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.ClientPort.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleClientPortCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorClientPortCondition(condition)
			if err != nil {
				return nil, err
			}

			clientPortCondition = append(clientPortCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.Cookies.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleCookiesCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorCookiesCondition(condition)
			if err != nil {
				return nil, err
			}

			cookiesCondition = append(cookiesCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.HostName.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleHostNameCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorHostNameCondition(condition)
			if err != nil {
				return nil, err
			}

			hostNameCondition = append(hostNameCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.HttpVersion.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleHTTPVersionCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorHttpVersionCondition(condition)
			if err != nil {
				return nil, err
			}

			httpVersionCondition = append(httpVersionCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.IsDevice.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleIsDeviceCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorIsDeviceCondition(condition)
			if err != nil {
				return nil, err
			}

			isDeviceCondition = append(isDeviceCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.PostArgs.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRulePostArgsCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorPostArgsCondition(condition)
			if err != nil {
				return nil, err
			}

			postArgsCondition = append(postArgsCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.QueryString.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleQueryStringCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorQueryStringCondition(condition)
			if err != nil {
				return nil, err
			}

			queryStringCondition = append(queryStringCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.RemoteAddress.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleRemoteAddressCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorRemoteAddressCondition(condition)
			if err != nil {
				return nil, err
			}

			remoteAddressCondition = append(remoteAddressCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.RequestBody.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleRequestBodyCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorRequestBodyCondition(condition)
			if err != nil {
				return nil, err
			}

			requestBodyCondition = append(requestBodyCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.RequestHeader.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleRequestHeaderCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorRequestHeaderCondition(condition)
			if err != nil {
				return nil, err
			}

			requestHeaderCondition = append(requestHeaderCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.RequestMethod.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleRequestMethodCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorRequestMethodCondition(condition)
			if err != nil {
				return nil, err
			}

			requestMethodCondition = append(requestMethodCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.RequestScheme.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleRequestSchemeCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorRequestSchemeCondition(condition)
			if err != nil {
				return nil, err
			}

			requestSchemeCondition = append(requestSchemeCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.RequestUri.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleRequestUriCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorRequestUriCondition(condition)
			if err != nil {
				return nil, err
			}

			requestURICondition = append(requestURICondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.ServerPort.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleServerPortCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorServerPortCondition(condition)
			if err != nil {
				return nil, err
			}

			serverPortCondition = append(serverPortCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.SocketAddress.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleSocketAddrCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorSocketAddressCondition(condition)
			if err != nil {
				return nil, err
			}

			socketAddressCondition = append(socketAddressCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.SslProtocol.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleSslProtocolCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorSslProtocolCondition(condition)
			if err != nil {
				return nil, err
			}

			sslProtocolCondition = append(sslProtocolCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.UrlFileExtension.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleURLFileExtensionCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorUrlFileExtensionCondition(condition)
			if err != nil {
				return nil, err
			}

			urlFileExtensionCondition = append(urlFileExtensionCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.UrlFilename.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleURLFileNameCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorUrlFileNameCondition(condition)
			if err != nil {
				return nil, err
			}

			urlFilenameCondition = append(urlFilenameCondition, flattened)
			continue
		}

		if deliveryRuleCondition.DeliveryRuleCondition().Name == c.UrlPath.Name {
			condition := deliveryRuleCondition.(rules.DeliveryRuleURLPathCondition)

			flattened, err := cdnFrontDoorRuleConditions.FlattenFrontdoorUrlPathCondition(condition)
			if err != nil {
				return nil, err
			}

			urlPathCondition = append(urlPathCondition, flattened)
			continue
		}

		return nil, fmt.Errorf("unknown DeliveryRuleCondition %q encountered", deliveryRuleCondition.DeliveryRuleCondition().Name)
	}

	conditions := map[string]interface{}{
		c.ClientPort.ConfigName:       clientPortCondition,
		c.Cookies.ConfigName:          cookiesCondition,
		c.HostName.ConfigName:         hostNameCondition,
		c.HttpVersion.ConfigName:      httpVersionCondition,
		c.IsDevice.ConfigName:         isDeviceCondition,
		c.PostArgs.ConfigName:         postArgsCondition,
		c.QueryString.ConfigName:      queryStringCondition,
		c.RemoteAddress.ConfigName:    remoteAddressCondition,
		c.RequestBody.ConfigName:      requestBodyCondition,
		c.RequestHeader.ConfigName:    requestHeaderCondition,
		c.RequestMethod.ConfigName:    requestMethodCondition,
		c.RequestScheme.ConfigName:    requestSchemeCondition,
		c.RequestUri.ConfigName:       requestURICondition,
		c.ServerPort.ConfigName:       serverPortCondition,
		c.SocketAddress.ConfigName:    socketAddressCondition,
		c.SslProtocol.ConfigName:      sslProtocolCondition,
		c.UrlFileExtension.ConfigName: urlFileExtensionCondition,
		c.UrlFilename.ConfigName:      urlFilenameCondition,
		c.UrlPath.ConfigName:          urlPathCondition,
	}

	// NOTE: Since we are always returning something no matter what this causes
	// a perpetual diff during plan. Only return the conditions map if
	// it actually has a condition defined within it, else return an empty
	// slice
	output := []interface{}{conditions}
	if !ruleHasDeliveryRuleConditions(conditions) {
		output = results
	}

	return output, nil
}
