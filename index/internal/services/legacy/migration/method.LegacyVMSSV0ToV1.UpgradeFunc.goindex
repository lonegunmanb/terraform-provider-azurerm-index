package github.com/hashicorp/terraform-provider-azurerm/internal/services/legacy/migration
import (
	"bytes"
	"context"
	"crypto/sha1"
	"encoding/hex"
	"fmt"

	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2024-11-01/virtualmachinescalesets"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func (LegacyVMSSV0ToV1) UpgradeFunc() pluginsdk.StateUpgraderFunc {
	return func(ctx context.Context, rawState map[string]interface{}, meta interface{}) (map[string]interface{}, error) {
		// @tombuildsstuff: NOTE, this state migration is essentially pointless
		// however it existed in the legacy migration so even though this is
		//  essentially a noop there's no reason this shouldn't be the same I guess

		client := meta.(*clients.Client).Compute.VirtualMachineScaleSetsClient

		id, err := virtualmachinescalesets.ParseVirtualMachineScaleSetIDInsensitively(rawState["id"].(string))
		if err != nil {
			return rawState, err
		}

		read, err := client.Get(ctx, *id, virtualmachinescalesets.DefaultGetOperationOptions())
		if err != nil {
			return rawState, err
		}

		if read.Model != nil && read.Model.Id != nil {
			rawState["id"] = *read.Model.Id
		}

		return rawState, nil
	}
}
