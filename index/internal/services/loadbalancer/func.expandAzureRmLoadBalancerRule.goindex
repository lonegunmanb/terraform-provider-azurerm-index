package github.com/hashicorp/terraform-provider-azurerm/internal/services/loadbalancer
import (
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-09-01/loadbalancers"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	loadBalancerValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/loadbalancer/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func expandAzureRmLoadBalancerRule(d *pluginsdk.ResourceData, lb *loadbalancers.LoadBalancer) (*loadbalancers.LoadBalancingRule, error) {
	properties := loadbalancers.LoadBalancingRulePropertiesFormat{
		Protocol:            loadbalancers.TransportProtocol(d.Get("protocol").(string)),
		FrontendPort:        int64(d.Get("frontend_port").(int)),
		BackendPort:         pointer.To(int64(d.Get("backend_port").(int))),
		EnableFloatingIP:    pointer.To(d.Get("floating_ip_enabled").(bool)),
		DisableOutboundSnat: pointer.To(d.Get("disable_outbound_snat").(bool)),
	}
	if v, ok := d.GetOk("tcp_reset_enabled"); ok {
		properties.EnableTcpReset = pointer.To(v.(bool))
	}

	if !features.FivePointOh() {
		if v, ok := d.GetOk("enable_floating_ip"); ok {
			properties.EnableFloatingIP = pointer.To(v.(bool))
		}
		if v, ok := d.GetOk("enable_tcp_reset"); ok {
			properties.EnableTcpReset = pointer.To(v.(bool))
		}
	}

	if v, ok := d.GetOk("idle_timeout_in_minutes"); ok {
		properties.IdleTimeoutInMinutes = pointer.To(int64(v.(int)))
	}

	if v := d.Get("load_distribution").(string); v != "" {
		properties.LoadDistribution = pointer.To(loadbalancers.LoadDistribution(v))
	}

	// TODO: ensure these ID's are consistent
	if v := d.Get("frontend_ip_configuration_name").(string); v != "" {
		rule, exists := FindLoadBalancerFrontEndIpConfigurationByName(lb, v)
		if !exists {
			return nil, fmt.Errorf("[ERROR] Cannot find FrontEnd IP Configuration with the name %s", v)
		}

		properties.FrontendIPConfiguration = &loadbalancers.SubResource{
			Id: rule.Id,
		}
	}

	var isGateway bool
	if lb != nil && lb.Sku != nil && pointer.From(lb.Sku.Name) == loadbalancers.LoadBalancerSkuNameGateway {
		isGateway = true
	}

	if l := d.Get("backend_address_pool_ids").([]interface{}); len(l) != 0 {
		if isGateway {
			var baps []loadbalancers.SubResource
			for _, p := range l {
				p := p.(string)
				baps = append(baps, loadbalancers.SubResource{
					Id: &p,
				})
			}
			properties.BackendAddressPools = &baps
		} else {
			if len(l) > 1 {
				return nil, fmt.Errorf(`only Gateway SKU Load Balancer can have more than one "backend_address_pool_ids"`)
			}
			properties.BackendAddressPool = &loadbalancers.SubResource{
				Id: pointer.To(l[0].(string)),
			}
		}
	}

	if v := d.Get("probe_id").(string); v != "" {
		properties.Probe = &loadbalancers.SubResource{
			Id: &v,
		}
	}

	return &loadbalancers.LoadBalancingRule{
		Name:       pointer.To(d.Get("name").(string)),
		Properties: &properties,
	}, nil
}
