package github.com/hashicorp/terraform-provider-azurerm/internal/services/redis
import (
	"context"
	"fmt"
	"log"
	"slices"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/zones"
	"github.com/hashicorp/go-azure-sdk/resource-manager/redis/2024-11-01/patchschedules"
	"github.com/hashicorp/go-azure-sdk/resource-manager/redis/2024-11-01/redis"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	azValidate "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/network"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/redis/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/redis/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func expandRedisConfiguration(d *pluginsdk.ResourceData) (*redis.RedisCommonPropertiesRedisConfiguration, error) {
	output := &redis.RedisCommonPropertiesRedisConfiguration{}

	input := d.Get("redis_configuration").([]interface{})
	if len(input) == 0 || input[0] == nil {
		return output, nil
	}
	raw := input[0].(map[string]interface{})
	skuName := d.Get("sku_name").(string)

	if v := raw["maxclients"].(int); v > 0 {
		output.Maxclients = pointer.To(strconv.Itoa(v))
	}

	if d.Get("sku_name").(string) != string(redis.SkuNameBasic) {
		if v := raw["maxmemory_delta"].(int); v > 0 {
			output.MaxmemoryDelta = pointer.To(strconv.Itoa(v))
		}

		if v := raw["maxmemory_reserved"].(int); v > 0 {
			output.MaxmemoryReserved = pointer.To(strconv.Itoa(v))
		}

		if v := raw["maxfragmentationmemory_reserved"].(int); v > 0 {
			output.MaxfragmentationmemoryReserved = pointer.To(strconv.Itoa(v))
		}
	}

	if v := raw["maxmemory_policy"].(string); v != "" {
		output.MaxmemoryPolicy = pointer.To(v)
	}

	output.PreferredDataPersistenceAuthMethod = pointer.To(raw["data_persistence_authentication_method"].(string))

	// AAD/Entra support
	// nolint : staticcheck
	v, valExists := d.GetOkExists("redis_configuration.0.active_directory_authentication_enabled")
	if valExists {
		entraEnabled := v.(bool)
		output.AadEnabled = pointer.To(strconv.FormatBool(entraEnabled))
	}

	// RDB Backup
	// nolint : staticcheck
	v, valExists = d.GetOkExists("redis_configuration.0.rdb_backup_enabled")
	if valExists {
		rdbBackupEnabled := v.(bool)

		// rdb_backup_enabled is available when SKU is Premium
		if strings.EqualFold(skuName, string(redis.SkuNamePremium)) {
			if rdbBackupEnabled {
				if connStr := raw["rdb_storage_connection_string"].(string); connStr == "" {
					return nil, fmt.Errorf("the rdb_storage_connection_string property must be set when rdb_backup_enabled is true")
				}
			}
			output.RdbBackupEnabled = pointer.To(strconv.FormatBool(rdbBackupEnabled))
		} else if rdbBackupEnabled && !strings.EqualFold(skuName, string(redis.SkuNamePremium)) {
			return nil, fmt.Errorf("the `rdb_backup_enabled` property requires a `Premium` sku to be set")
		}
	}

	if v := raw["rdb_backup_frequency"].(int); v > 0 {
		output.RdbBackupFrequency = pointer.To(strconv.Itoa(v))
	}

	if v := raw["rdb_backup_max_snapshot_count"].(int); v > 0 {
		output.RdbBackupMaxSnapshotCount = pointer.To(strconv.Itoa(v))
	}

	if v := raw["rdb_storage_connection_string"].(string); v != "" {
		output.RdbStorageConnectionString = pointer.To(v)
	}

	if v := raw["notify_keyspace_events"].(string); v != "" {
		output.NotifyKeyspaceEvents = pointer.To(v)
	}

	// AOF Backup
	// nolint : staticcheck
	v, valExists = d.GetOkExists("redis_configuration.0.aof_backup_enabled")
	if valExists {
		// aof_backup_enabled is available when SKU is Premium
		if strings.EqualFold(skuName, string(redis.SkuNamePremium)) {
			output.AofBackupEnabled = pointer.To(strconv.FormatBool(v.(bool)))
		}
	}

	if v := raw["aof_storage_connection_string_0"].(string); v != "" {
		output.AofStorageConnectionString0 = pointer.To(v)
	}

	if v := raw["aof_storage_connection_string_1"].(string); v != "" {
		output.AofStorageConnectionString1 = pointer.To(v)
	}

	authEnabled := raw["authentication_enabled"].(bool)

	// Redis authentication can only be disabled if it is launched inside a VNET.
	if _, isPrivate := d.GetOk("subnet_id"); !isPrivate {
		if !authEnabled {
			return nil, fmt.Errorf("cannot set `authentication_enabled` or `enable_authentication` to `false` when `subnet_id` is not set")
		}
	} else {
		value := isAuthNotRequiredAsString(authEnabled)
		output.Authnotrequired = pointer.To(value)
	}

	if v := raw["storage_account_subscription_id"].(string); v != "" {
		output.StorageSubscriptionId = pointer.To(v)
	}
	return output, nil
}
