package github.com/hashicorp/terraform-provider-azurerm/internal/services/compute
import (
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/capacityreservationgroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/images"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/proximityplacementgroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2023-04-02/disks"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2024-03-01/virtualmachines"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	azValidate "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	computeValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/compute/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/base64"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceLinuxVirtualMachineDelete(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Compute.VirtualMachinesClient
	ctx, cancel := timeouts.ForDelete(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := virtualmachines.ParseVirtualMachineID(d.Id())
	if err != nil {
		return err
	}

	locks.ByName(id.VirtualMachineName, VirtualMachineResourceName)
	defer locks.UnlockByName(id.VirtualMachineName, VirtualMachineResourceName)

	log.Printf("[DEBUG] Retrieving Linux %s", id)
	options := virtualmachines.DefaultGetOperationOptions()
	options.Expand = pointer.To(virtualmachines.InstanceViewTypesUserData)
	existing, err := client.Get(ctx, *id, options)
	if err != nil {
		if response.WasNotFound(existing.HttpResponse) {
			return nil
		}

		return fmt.Errorf("retrieving Linux %s: %+v", id, err)
	}

	if !meta.(*clients.Client).Features.VirtualMachine.SkipShutdownAndForceDelete {
		// If the VM was in a Failed state we can skip powering off, since that'll fail
		if model := existing.Model; model != nil && model.Properties != nil && model.Properties.ProvisioningState != nil {
			if strings.EqualFold(*existing.Model.Properties.ProvisioningState, "failed") {
				log.Printf("[DEBUG] Powering Off Linux Virtual Machine was skipped because the VM was in %q state %s", *model.Properties.ProvisioningState, id)
			} else {
				// ISSUE: 4920
				// shutting down the Virtual Machine prior to removing it means users are no longer charged for some Azure resources
				// thus this can be a large cost-saving when deleting larger instances
				// https://docs.microsoft.com/en-us/azure/virtual-machines/states-lifecycle
				log.Printf("[DEBUG] Powering Off Linux %s", id)
				skipShutdown := !meta.(*clients.Client).Features.VirtualMachine.GracefulShutdown
				options := virtualmachines.PowerOffOperationOptions{
					SkipShutdown: pointer.To(skipShutdown),
				}
				if err := client.PowerOffThenPoll(ctx, *id, options); err != nil {
					return fmt.Errorf("powering off Linux %s: %+v", id, err)
				}
				log.Printf("[DEBUG] Powered Off Linux %s", id)
			}
		}
	}

	log.Printf("[DEBUG] Deleting Linux %s", id)

	// Force Delete is in an opt-in Preview and can only be specified (true/false) if the feature is enabled
	// as such we default this to `nil` which matches the previous behaviour (where this isn't sent) and
	// conditionally set this if required
	var forceDeletion *bool = nil
	if meta.(*clients.Client).Features.VirtualMachine.SkipShutdownAndForceDelete {
		forceDeletion = pointer.To(true)
	}
	deleteOptions := virtualmachines.DefaultDeleteOperationOptions()
	deleteOptions.ForceDeletion = forceDeletion
	if err := client.DeleteThenPoll(ctx, *id, deleteOptions); err != nil {
		return fmt.Errorf("deleting Linux %s: %+v", id, err)
	}

	log.Printf("[DEBUG] Deleted Linux %s", id)

	deleteOSDisk := meta.(*clients.Client).Features.VirtualMachine.DeleteOSDiskOnDeletion
	if deleteOSDisk {
		log.Printf("[DEBUG] Deleting OS Disk from Linux %s", id)
		disksClient := meta.(*clients.Client).Compute.DisksClient
		managedDiskId := ""
		if props := existing.Model.Properties; props != nil && props.StorageProfile != nil && props.StorageProfile.OsDisk != nil {
			if disk := props.StorageProfile.OsDisk.ManagedDisk; disk != nil && disk.Id != nil {
				managedDiskId = *disk.Id
			}
		}

		if managedDiskId != "" {
			diskId, err := commonids.ParseManagedDiskID(managedDiskId)
			if err != nil {
				return err
			}

			if err := disksClient.DeleteThenPoll(ctx, *diskId); err != nil {
				return fmt.Errorf("deleting %s for Linux %s: %+v", diskId, id, err)
			}

			log.Printf("[DEBUG] Deleted %s for Linux %s", diskId, id)
		} else {
			log.Printf("[DEBUG] Skipping Deleting OS Disk from Linux %s - cannot determine OS Disk ID.", id)
		}
	} else {
		log.Printf("[DEBUG] Skipping Deleting OS Disk from Linux %s", id)
	}

	// Need to add a get and a state wait to avoid bug in network API where the attached disk(s) are not actually deleted
	// Service team indicated that we need to do a get after VM delete call returns to verify that the VM and all attached
	// disks have actually been deleted.

	log.Printf("[INFO] verifying Linux %s has been deleted", id)
	virtualMachine, err := client.Get(ctx, *id, virtualmachines.DefaultGetOperationOptions())
	if err != nil && !response.WasNotFound(virtualMachine.HttpResponse) {
		return fmt.Errorf("verifying Linux %s has been deleted: %+v", id, err)
	}

	if !response.WasNotFound(virtualMachine.HttpResponse) {
		log.Printf("[INFO] %s still exists, waiting on vm to be deleted", id)

		deleteWait := &pluginsdk.StateChangeConf{
			Pending:    []string{"200"},
			Target:     []string{"404"},
			MinTimeout: 30 * time.Second,
			Timeout:    d.Timeout(pluginsdk.TimeoutDelete),
			Refresh: func() (interface{}, string, error) {
				log.Printf("[INFO] checking on state of Linux %s", id)
				resp, err := client.Get(ctx, *id, virtualmachines.DefaultGetOperationOptions())
				if err != nil {
					if response.WasNotFound(resp.HttpResponse) {
						return resp, strconv.Itoa(resp.HttpResponse.StatusCode), nil
					}
					return nil, "nil", fmt.Errorf("polling for the status of Linux %s: %v", id, err)
				}
				return resp, strconv.Itoa(resp.HttpResponse.StatusCode), nil
			},
		}

		if _, err := deleteWait.WaitForStateContext(ctx); err != nil {
			return fmt.Errorf("waiting for the deletion of Linux %s: %v", id, err)
		}
	}

	return nil
}
