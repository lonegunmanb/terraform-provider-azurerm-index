package github.com/hashicorp/terraform-provider-azurerm/internal/services/compute
import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2021-07-01/skus"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2023-04-02/disks"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2024-03-01/virtualmachines"
)
func determineIfVirtualMachineSkuSupportsNoDowntimeResize(ctx context.Context, virtualMachineIdRaw *string, virtualMachinesClient *virtualmachines.VirtualMachinesClient, skusClient *skus.SkusClient) (*bool, error) {
	if virtualMachineIdRaw == nil {
		return pointer.To(false), nil
	}

	virtualMachineId, err := virtualmachines.ParseVirtualMachineIDInsensitively(*virtualMachineIdRaw)
	if err != nil {
		log.Printf("[DEBUG] unable to parse Virtual Machine ID %q that the Managed Disk is attached too - skipping no-downtime-resize since we can't guarantee that's available", *virtualMachineIdRaw)
		return pointer.To(false), nil // lint:ignore nilerr this is not an error as we just want to skip the check in this situation since we can't guarantee it's available
	}

	log.Printf("[DEBUG] Retrieving %s..", *virtualMachineId)
	virtualMachine, err := virtualMachinesClient.Get(ctx, *virtualMachineId, virtualmachines.DefaultGetOperationOptions())
	if err != nil {
		return nil, fmt.Errorf("retrieving %s: %+v", *virtualMachineId, err)
	}

	vmLocation := ""
	vmSku := ""
	if model := virtualMachine.Model; model != nil {
		vmLocation = location.Normalize(model.Location)
		if model.Properties != nil && model.Properties.HardwareProfile != nil && model.Properties.HardwareProfile.VMSize != nil {
			vmSku = string(*model.Properties.HardwareProfile.VMSize)
		}
	}
	if vmLocation == "" || vmSku == "" {
		return pointer.To(false), nil
	}

	subscriptionId := commonids.NewSubscriptionID(virtualMachineId.SubscriptionId)
	opts := skus.DefaultResourceSkusListOperationOptions()
	// @tombuildsstuff: by default this API returns EVERY SKU in EVERY LOCATION meaning this will get
	// progressively larger each time - instead we filter to the current Location only.
	opts.Filter = pointer.To(fmt.Sprintf("location eq '%s'", vmLocation))
	skusResponse, err := skusClient.ResourceSkusListComplete(ctx, subscriptionId, opts)
	if err != nil {
		return nil, fmt.Errorf("retrieving information about the Resource SKUs to check if the Virtual Machine/Disk combination supports no-downtime-resizing: %+v", err)
	}

	supportsEphemeralOSDisks := false
	supportsHyperVGen2 := false
	supportsPremiumIO := false
	for _, sku := range skusResponse.Items {
		if sku.ResourceType == nil || !strings.EqualFold(*sku.ResourceType, "virtualMachines") {
			continue
		}
		if sku.Capabilities == nil {
			continue
		}

		for _, capability := range *sku.Capabilities {
			if capability.Name == nil || capability.Value == nil {
				continue
			}

			// this logic is based on:
			// if (($capability.Name -eq "EphemeralOSDiskSupported" -and $capability.Value -eq "True") -or ($capability.Name -eq "PremiumIO" -and $capability.Value -eq "True") -or ($capability.Name -eq "HyperVGenerations" -and $capability.Value -match "V2"))
			if strings.EqualFold(*capability.Name, "EphemeralOSDiskSupported") && strings.EqualFold(*capability.Value, "True") {
				supportsEphemeralOSDisks = true
			}
			if strings.EqualFold(*capability.Name, "HyperVGenerations") && strings.Contains(strings.ToLower(*capability.Value), "v2") {
				supportsHyperVGen2 = true
			}
			if strings.EqualFold(*capability.Name, "PremiumIO") && strings.EqualFold(*capability.Value, "True") {
				supportsPremiumIO = true
			}
		}
	}
	result := supportsEphemeralOSDisks || supportsPremiumIO || supportsHyperVGen2
	return pointer.To(result), nil
}
