package github.com/hashicorp/terraform-provider-azurerm/internal/services/compute
import (
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/capacityreservationgroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/images"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/proximityplacementgroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2023-04-02/disks"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2024-03-01/virtualmachines"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	azValidate "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	computeValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/compute/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceWindowsVirtualMachineRead(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Compute.VirtualMachinesClient
	disksClient := meta.(*clients.Client).Compute.DisksClient
	networkInterfacesClient := meta.(*clients.Client).Network.NetworkInterfacesClient
	publicIPAddressesClient := meta.(*clients.Client).Network.PublicIPAddresses
	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := virtualmachines.ParseVirtualMachineID(d.Id())
	if err != nil {
		return err
	}

	options := virtualmachines.DefaultGetOperationOptions()
	options.Expand = pointer.To(virtualmachines.InstanceViewTypesUserData)
	resp, err := client.Get(ctx, *id, options)
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			log.Printf("[DEBUG] Windows %s was not found - removing from state!", id)
			d.SetId("")
			return nil
		}

		return fmt.Errorf("retrieving Windows %s: %+v", id, err)
	}

	d.Set("name", id.VirtualMachineName)
	d.Set("resource_group_name", id.ResourceGroupName)

	if model := resp.Model; model != nil {
		d.Set("location", location.Normalize(model.Location))
		d.Set("edge_zone", flattenEdgeZone(model.ExtendedLocation))

		zone := ""
		if model.Zones != nil {
			if zones := *model.Zones; len(zones) > 0 {
				zone = zones[0]
			}
		}
		d.Set("zone", zone)

		identityFlattened, err := identity.FlattenSystemAndUserAssignedMap(model.Identity)
		if err != nil {
			return fmt.Errorf("flattening `identity`: %+v", err)
		}
		if err := d.Set("identity", identityFlattened); err != nil {
			return fmt.Errorf("setting `identity`: %+v", err)
		}

		if err := d.Set("plan", flattenPlan(model.Plan)); err != nil {
			return fmt.Errorf("setting `plan`: %+v", err)
		}

		if props := model.Properties; props != nil {
			d.Set("virtual_machine_id", props.VMId)
			if err := d.Set("additional_capabilities", flattenVirtualMachineAdditionalCapabilities(props.AdditionalCapabilities)); err != nil {
				return fmt.Errorf("setting `additional_capabilities`: %+v", err)
			}

			availabilitySetId := ""
			if props.AvailabilitySet != nil && props.AvailabilitySet.Id != nil {
				availabilitySetId = *props.AvailabilitySet.Id
			}
			d.Set("availability_set_id", availabilitySetId)

			capacityReservationGroupId := ""
			if props.CapacityReservation != nil && props.CapacityReservation.CapacityReservationGroup != nil && props.CapacityReservation.CapacityReservationGroup.Id != nil {
				capacityReservationGroupId = *props.CapacityReservation.CapacityReservationGroup.Id
			}
			d.Set("capacity_reservation_group_id", capacityReservationGroupId)

			if err := d.Set("boot_diagnostics", flattenBootDiagnostics(props.DiagnosticsProfile)); err != nil {
				return fmt.Errorf("setting `boot_diagnostics`: %+v", err)
			}

			d.Set("eviction_policy", pointer.From(props.EvictionPolicy))
			if profile := props.HardwareProfile; profile != nil {
				d.Set("size", pointer.From(profile.VMSize))
			}
			d.Set("license_type", props.LicenseType)

			extensionsTimeBudget := "PT1H30M"
			if props.ExtensionsTimeBudget != nil {
				extensionsTimeBudget = *props.ExtensionsTimeBudget
			}
			d.Set("extensions_time_budget", extensionsTimeBudget)

			if props.ApplicationProfile != nil && props.ApplicationProfile.GalleryApplications != nil {
				d.Set("gallery_application", flattenVirtualMachineGalleryApplication(props.ApplicationProfile.GalleryApplications))
			}

			// defaulted since BillingProfile isn't returned if it's unset
			maxBidPrice := float64(-1.0)
			if props.BillingProfile != nil && props.BillingProfile.MaxPrice != nil {
				maxBidPrice = *props.BillingProfile.MaxPrice
			}
			d.Set("max_bid_price", maxBidPrice)

			if profile := props.NetworkProfile; profile != nil {
				if err := d.Set("network_interface_ids", flattenVirtualMachineNetworkInterfaceIDs(props.NetworkProfile.NetworkInterfaces)); err != nil {
					return fmt.Errorf("setting `network_interface_ids`: %+v", err)
				}
			}

			dedicatedHostId := ""
			if props.Host != nil && props.Host.Id != nil {
				dedicatedHostId = *props.Host.Id
			}
			d.Set("dedicated_host_id", dedicatedHostId)

			dedicatedHostGroupId := ""
			if props.HostGroup != nil && props.HostGroup.Id != nil {
				dedicatedHostGroupId = *props.HostGroup.Id
			}
			d.Set("dedicated_host_group_id", dedicatedHostGroupId)

			virtualMachineScaleSetId := ""
			if props.VirtualMachineScaleSet != nil && props.VirtualMachineScaleSet.Id != nil {
				virtualMachineScaleSetId = *props.VirtualMachineScaleSet.Id
			}
			d.Set("virtual_machine_scale_set_id", virtualMachineScaleSetId)
			platformFaultDomain := -1
			if props.PlatformFaultDomain != nil {
				platformFaultDomain = int(*props.PlatformFaultDomain)
			}
			d.Set("platform_fault_domain", platformFaultDomain)

			if profile := props.OsProfile; profile != nil {
				d.Set("admin_username", profile.AdminUsername)
				d.Set("allow_extension_operations", profile.AllowExtensionOperations)
				d.Set("computer_name", profile.ComputerName)

				if config := profile.WindowsConfiguration; config != nil {
					if err := d.Set("additional_unattend_content", flattenAdditionalUnattendContent(config.AdditionalUnattendContent, d)); err != nil {
						return fmt.Errorf("setting `additional_unattend_content`: %+v", err)
					}

					d.Set("automatic_updates_enabled", config.EnableAutomaticUpdates)
					if !features.FivePointOh() {
						d.Set("enable_automatic_updates", config.EnableAutomaticUpdates)
					}
					d.Set("provision_vm_agent", config.ProvisionVMAgent)
					d.Set("vm_agent_platform_updates_enabled", config.EnableVMAgentPlatformUpdates)

					assessmentMode := string(virtualmachines.WindowsPatchAssessmentModeImageDefault)
					bypassPlatformSafetyChecksOnUserScheduleEnabled := false
					rebootSetting := ""
					if patchSettings := config.PatchSettings; patchSettings != nil {
						d.Set("patch_mode", pointer.From(patchSettings.PatchMode))
						d.Set("hotpatching_enabled", patchSettings.EnableHotpatching)

						if patchSettings.AutomaticByPlatformSettings != nil {
							bypassPlatformSafetyChecksOnUserScheduleEnabled = pointer.From(patchSettings.AutomaticByPlatformSettings.BypassPlatformSafetyChecksOnUserSchedule)
							rebootSetting = string(pointer.From(patchSettings.AutomaticByPlatformSettings.RebootSetting))
						}
						if patchSettings.AssessmentMode != nil {
							assessmentMode = string(pointer.From(patchSettings.AssessmentMode))
						}
					}

					d.Set("patch_assessment_mode", assessmentMode)
					d.Set("bypass_platform_safety_checks_on_user_schedule_enabled", bypassPlatformSafetyChecksOnUserScheduleEnabled)
					d.Set("reboot_setting", rebootSetting)

					d.Set("timezone", config.TimeZone)

					if err := d.Set("winrm_listener", flattenWinRMListener(config.WinRM)); err != nil {
						return fmt.Errorf("setting `winrm_listener`: %+v", err)
					}

					if err := d.Set("secret", flattenWindowsSecrets(profile.Secrets)); err != nil {
						return fmt.Errorf("setting `secret`: %+v", err)
					}
				}
			}

			// Resources created with azurerm_virtual_machine have priority set to ""
			// We need to treat "" as equal to "Regular" to allow migration azurerm_virtual_machine -> azurerm_linux_virtual_machine
			priority := string(virtualmachines.VirtualMachinePriorityTypesRegular)
			if props.Priority != nil && *props.Priority != "" {
				priority = string(pointer.From(props.Priority))
			}
			d.Set("priority", priority)

			proximityPlacementGroupId := ""
			if props.ProximityPlacementGroup != nil && props.ProximityPlacementGroup.Id != nil {
				proximityPlacementGroupId = *props.ProximityPlacementGroup.Id
			}
			d.Set("proximity_placement_group_id", proximityPlacementGroupId)

			if profile := props.StorageProfile; profile != nil {
				d.Set("disk_controller_type", pointer.From(props.StorageProfile.DiskControllerType))

				// the storage_account_type isn't returned so we need to look it up
				flattenedOSDisk, err := flattenVirtualMachineOSDisk(ctx, disksClient, profile.OsDisk)
				if err != nil {
					return fmt.Errorf("flattening `os_disk`: %+v", err)
				}

				if err := d.Set("os_disk", flattenedOSDisk); err != nil {
					return fmt.Errorf("settings `os_disk`: %+v", err)
				}
				osManagedDiskId := ""
				if profile.OsDisk != nil && profile.OsDisk.ManagedDisk != nil && profile.OsDisk.ManagedDisk.Id != nil {
					osDiskId, err := commonids.ParseManagedDiskID(*profile.OsDisk.ManagedDisk.Id)
					if err != nil {
						return err
					}
					osManagedDiskId = osDiskId.ID()
				}
				d.Set("os_managed_disk_id", osManagedDiskId)
				var storageImageId string
				if profile.ImageReference != nil && profile.ImageReference.Id != nil {
					storageImageId = *profile.ImageReference.Id
				}
				if profile.ImageReference != nil && profile.ImageReference.CommunityGalleryImageId != nil {
					storageImageId = *profile.ImageReference.CommunityGalleryImageId
				}
				if profile.ImageReference != nil && profile.ImageReference.SharedGalleryImageId != nil {
					storageImageId = *profile.ImageReference.SharedGalleryImageId
				}
				d.Set("source_image_id", storageImageId)

				if err := d.Set("source_image_reference", flattenSourceImageReference(profile.ImageReference, storageImageId != "")); err != nil {
					return fmt.Errorf("setting `source_image_reference`: %+v", err)
				}
			}
			if scheduleProfile := props.ScheduledEventsProfile; scheduleProfile != nil {
				if err := d.Set("os_image_notification", flattenOsImageNotificationProfile(scheduleProfile.OsImageNotificationProfile)); err != nil {
					return fmt.Errorf("setting `termination_notification`: %+v", err)
				}

				if err := d.Set("termination_notification", flattenTerminateNotificationProfile(scheduleProfile.TerminateNotificationProfile)); err != nil {
					return fmt.Errorf("setting `termination_notification`: %+v", err)
				}
			}

			encryptionAtHostEnabled := false
			vtpmEnabled := false
			secureBootEnabled := false
			if securityProfile := props.SecurityProfile; securityProfile != nil {
				if securityProfile.EncryptionAtHost != nil {
					encryptionAtHostEnabled = *securityProfile.EncryptionAtHost
				}
				if uefi := props.SecurityProfile.UefiSettings; uefi != nil {
					if uefi.VTpmEnabled != nil {
						vtpmEnabled = *uefi.VTpmEnabled
					}
					if uefi.SecureBootEnabled != nil {
						secureBootEnabled = *uefi.SecureBootEnabled
					}
				}
			}
			d.Set("encryption_at_host_enabled", encryptionAtHostEnabled)
			d.Set("vtpm_enabled", vtpmEnabled)
			d.Set("secure_boot_enabled", secureBootEnabled)
			d.Set("user_data", props.UserData)

			connectionInfo := retrieveConnectionInformation(ctx, networkInterfacesClient, publicIPAddressesClient, props)
			d.Set("private_ip_address", connectionInfo.primaryPrivateAddress)
			d.Set("private_ip_addresses", connectionInfo.privateAddresses)
			d.Set("public_ip_address", connectionInfo.primaryPublicAddress)
			d.Set("public_ip_addresses", connectionInfo.publicAddresses)
			isWindows := false
			setConnectionInformation(d, connectionInfo, isWindows)
		}
		return tags.FlattenAndSet(d, model.Tags)
	}
	return nil
}
