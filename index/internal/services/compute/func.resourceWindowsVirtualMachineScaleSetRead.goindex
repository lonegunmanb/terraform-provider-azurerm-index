package github.com/hashicorp/terraform-provider-azurerm/internal/services/compute
import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/zones"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/capacityreservationgroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/images"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2022-03-01/proximityplacementgroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2024-07-01/virtualmachinescalesets"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	computeValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/compute/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/base64"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceWindowsVirtualMachineScaleSetRead(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Compute.VirtualMachineScaleSetsClient
	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := virtualmachinescalesets.ParseVirtualMachineScaleSetID(d.Id())
	if err != nil {
		return err
	}

	options := virtualmachinescalesets.DefaultGetOperationOptions()
	options.Expand = pointer.To(virtualmachinescalesets.ExpandTypesForGetVMScaleSetsUserData)
	resp, err := client.Get(ctx, *id, options)
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			log.Printf("[DEBUG] Windows %s was not found - removing from state!", id)
			d.SetId("")
			return nil
		}

		return fmt.Errorf("retrieving Windows %s: %+v", id, err)
	}

	d.Set("name", id.VirtualMachineScaleSetName)
	d.Set("resource_group_name", id.ResourceGroupName)

	if model := resp.Model; model != nil {
		d.Set("location", location.Normalize(model.Location))
		d.Set("edge_zone", flattenEdgeZone(model.ExtendedLocation))
		d.Set("zones", zones.FlattenUntyped(model.Zones))

		var skuName *string
		var instances int
		if model.Sku != nil {
			skuName = model.Sku.Name
			if model.Sku.Capacity != nil {
				instances = int(*model.Sku.Capacity)
			}
		}
		d.Set("instances", instances)
		d.Set("sku", skuName)

		identityFlattened, err := identity.FlattenSystemAndUserAssignedMap(model.Identity)
		if err != nil {
			return err
		}
		if err := d.Set("identity", identityFlattened); err != nil {
			return fmt.Errorf("setting `identity`: %+v", err)
		}

		if err := d.Set("plan", flattenPlanVMSS(model.Plan)); err != nil {
			return fmt.Errorf("setting `plan`: %+v", err)
		}

		if props := model.Properties; props != nil {
			if err := d.Set("additional_capabilities", FlattenVirtualMachineScaleSetAdditionalCapabilities(props.AdditionalCapabilities)); err != nil {
				return fmt.Errorf("setting `additional_capabilities`: %+v", props.AdditionalCapabilities)
			}

			if err := d.Set("automatic_instance_repair", FlattenVirtualMachineScaleSetAutomaticRepairsPolicy(props.AutomaticRepairsPolicy)); err != nil {
				return fmt.Errorf("setting `automatic_instance_repair`: %+v", err)
			}

			d.Set("do_not_run_extensions_on_overprovisioned_machines", props.DoNotRunExtensionsOnOverprovisionedVMs)
			if props.HostGroup != nil && props.HostGroup.Id != nil {
				d.Set("host_group_id", props.HostGroup.Id)
			}
			d.Set("overprovision", props.Overprovision)
			proximityPlacementGroupId := ""
			if props.ProximityPlacementGroup != nil && props.ProximityPlacementGroup.Id != nil {
				proximityPlacementGroupId = *props.ProximityPlacementGroup.Id
			}
			d.Set("platform_fault_domain_count", props.PlatformFaultDomainCount)
			d.Set("proximity_placement_group_id", proximityPlacementGroupId)
			d.Set("single_placement_group", props.SinglePlacementGroup)
			d.Set("unique_id", props.UniqueId)
			d.Set("zone_balance", props.ZoneBalance)
			d.Set("scale_in", FlattenVirtualMachineScaleSetScaleInPolicy(props.ScaleInPolicy))

			if props.SpotRestorePolicy != nil {
				d.Set("spot_restore", FlattenVirtualMachineScaleSetSpotRestorePolicy(props.SpotRestorePolicy))
			}

			var upgradeMode virtualmachinescalesets.UpgradeMode
			if policy := props.UpgradePolicy; policy != nil && policy.Mode != nil {
				upgradeMode = *policy.Mode
				d.Set("upgrade_mode", string(upgradeMode))

				flattenedAutomatic := FlattenVirtualMachineScaleSetAutomaticOSUpgradePolicy(policy.AutomaticOSUpgradePolicy)
				if err := d.Set("automatic_os_upgrade_policy", flattenedAutomatic); err != nil {
					return fmt.Errorf("setting `automatic_os_upgrade_policy`: %+v", err)
				}

				flattenedRolling := FlattenVirtualMachineScaleSetRollingUpgradePolicy(policy.RollingUpgradePolicy)
				if err := d.Set("rolling_upgrade_policy", flattenedRolling); err != nil {
					return fmt.Errorf("setting `rolling_upgrade_policy`: %+v", err)
				}
			}

			if profile := props.VirtualMachineProfile; profile != nil {
				if err := d.Set("boot_diagnostics", flattenBootDiagnosticsVMSS(profile.DiagnosticsProfile)); err != nil {
					return fmt.Errorf("setting `boot_diagnostics`: %+v", err)
				}

				capacityReservationGroupId := ""
				if profile.CapacityReservation != nil && profile.CapacityReservation.CapacityReservationGroup != nil && profile.CapacityReservation.CapacityReservationGroup.Id != nil {
					capacityReservationGroupId = *profile.CapacityReservation.CapacityReservationGroup.Id
				}
				d.Set("capacity_reservation_group_id", capacityReservationGroupId)

				// defaulted since BillingProfile isn't returned if it's unset
				maxBidPrice := float64(-1.0)
				if profile.BillingProfile != nil && profile.BillingProfile.MaxPrice != nil {
					maxBidPrice = *profile.BillingProfile.MaxPrice
				}
				d.Set("max_bid_price", maxBidPrice)

				d.Set("eviction_policy", pointer.From(profile.EvictionPolicy))
				d.Set("license_type", profile.LicenseType)

				if profile.ApplicationProfile != nil && profile.ApplicationProfile.GalleryApplications != nil {
					d.Set("gallery_application", flattenVirtualMachineScaleSetGalleryApplication(profile.ApplicationProfile.GalleryApplications))
				}

				// the service just return empty when this is not assigned when provisioned
				// See discussion on https://github.com/Azure/azure-rest-api-specs/issues/10971
				priority := virtualmachinescalesets.VirtualMachinePriorityTypesRegular
				if profile.Priority != nil && *profile.Priority != "" {
					priority = *profile.Priority
				}
				d.Set("priority", priority)

				if storageProfile := profile.StorageProfile; storageProfile != nil {
					if err := d.Set("os_disk", FlattenVirtualMachineScaleSetOSDisk(storageProfile.OsDisk)); err != nil {
						return fmt.Errorf("setting `os_disk`: %+v", err)
					}

					if err := d.Set("data_disk", FlattenVirtualMachineScaleSetDataDisk(storageProfile.DataDisks)); err != nil {
						return fmt.Errorf("setting `data_disk`: %+v", err)
					}

					var storageImageId string
					if storageProfile.ImageReference != nil && storageProfile.ImageReference.Id != nil {
						storageImageId = *storageProfile.ImageReference.Id
					}
					if storageProfile.ImageReference != nil && storageProfile.ImageReference.CommunityGalleryImageId != nil {
						storageImageId = *storageProfile.ImageReference.CommunityGalleryImageId
					}
					if storageProfile.ImageReference != nil && storageProfile.ImageReference.SharedGalleryImageId != nil {
						storageImageId = *storageProfile.ImageReference.SharedGalleryImageId
					}
					d.Set("source_image_id", storageImageId)

					if err := d.Set("source_image_reference", flattenSourceImageReferenceVMSS(storageProfile.ImageReference, storageImageId != "")); err != nil {
						return fmt.Errorf("setting `source_image_reference`: %+v", err)
					}
				}

				extensionOperationsEnabled := true
				if osProfile := profile.OsProfile; osProfile != nil {
					// admin_password isn't returned, but it's a top level field so we can ignore it without consequence
					d.Set("admin_username", osProfile.AdminUsername)
					d.Set("computer_name_prefix", osProfile.ComputerNamePrefix)

					if osProfile.AllowExtensionOperations != nil {
						extensionOperationsEnabled = *osProfile.AllowExtensionOperations
					}

					if err := d.Set("secret", flattenWindowsSecretsVMSS(osProfile.Secrets)); err != nil {
						return fmt.Errorf("setting `secret`: %+v", err)
					}

					if windows := osProfile.WindowsConfiguration; windows != nil {
						if err := d.Set("additional_unattend_content", flattenAdditionalUnattendContentVMSS(windows.AdditionalUnattendContent, d)); err != nil {
							return fmt.Errorf("setting `additional_unattend_content`: %+v", err)
						}

						enableAutomaticUpdates := false
						if windows.EnableAutomaticUpdates != nil {
							enableAutomaticUpdates = *windows.EnableAutomaticUpdates
						}

						// the API requires this is set to 'true' on submission (since it's now required for Windows VMSS's with
						// an Automatic Upgrade Mode configured) however it actually returns false from the API..
						// after a bunch of testing the least bad option appears to be not to set this if it's an Automatic Upgrade Mode
						if upgradeMode != virtualmachinescalesets.UpgradeModeAutomatic {
							d.Set("enable_automatic_updates", enableAutomaticUpdates)
						}

						d.Set("provision_vm_agent", windows.ProvisionVMAgent)
						d.Set("timezone", windows.TimeZone)

						if err := d.Set("winrm_listener", flattenWinRMListenerVMSS(windows.WinRM)); err != nil {
							return fmt.Errorf("setting `winrm_listener`: %+v", err)
						}
					}
				}
				d.Set("extension_operations_enabled", extensionOperationsEnabled)

				if nwProfile := profile.NetworkProfile; nwProfile != nil {
					flattenedNics := FlattenVirtualMachineScaleSetNetworkInterface(nwProfile.NetworkInterfaceConfigurations)
					if err := d.Set("network_interface", flattenedNics); err != nil {
						return fmt.Errorf("setting `network_interface`: %+v", err)
					}

					healthProbeId := ""
					if nwProfile.HealthProbe != nil && nwProfile.HealthProbe.Id != nil {
						healthProbeId = *nwProfile.HealthProbe.Id
					}
					d.Set("health_probe_id", healthProbeId)
				}

				if scheduleProfile := profile.ScheduledEventsProfile; scheduleProfile != nil {
					if err := d.Set("termination_notification", FlattenVirtualMachineScaleSetScheduledEventsProfile(scheduleProfile)); err != nil {
						return fmt.Errorf("setting `termination_notification`: %+v", err)
					}
				}

				extensionProfile, err := flattenVirtualMachineScaleSetExtensions(profile.ExtensionProfile, d)
				if err != nil {
					return fmt.Errorf("failed flattening `extension`: %+v", err)
				}
				d.Set("extension", extensionProfile)

				extensionsTimeBudget := "PT1H30M"
				if profile.ExtensionProfile != nil && profile.ExtensionProfile.ExtensionsTimeBudget != nil {
					extensionsTimeBudget = *profile.ExtensionProfile.ExtensionsTimeBudget
				}
				d.Set("extensions_time_budget", extensionsTimeBudget)

				encryptionAtHostEnabled := false
				vtpmEnabled := false
				secureBootEnabled := false

				if securityProfile := profile.SecurityProfile; securityProfile != nil {
					if securityProfile.EncryptionAtHost != nil {
						encryptionAtHostEnabled = *securityProfile.EncryptionAtHost
					}
					if uefi := profile.SecurityProfile.UefiSettings; uefi != nil {
						if uefi.VTpmEnabled != nil {
							vtpmEnabled = *uefi.VTpmEnabled
						}
						if uefi.SecureBootEnabled != nil {
							secureBootEnabled = *uefi.SecureBootEnabled
						}
					}
				}

				d.Set("encryption_at_host_enabled", encryptionAtHostEnabled)
				d.Set("vtpm_enabled", vtpmEnabled)
				d.Set("secure_boot_enabled", secureBootEnabled)
				d.Set("user_data", profile.UserData)
			}
		}
		return tags.FlattenAndSet(d, model.Tags)
	}
	return nil
}
