package github.com/hashicorp/terraform-provider-azurerm/internal/services/compute
import (
	"context"
	"fmt"
	"log"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2021-07-01/skus"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2023-04-02/disks"
	"github.com/hashicorp/go-azure-sdk/resource-manager/compute/2024-03-01/virtualmachines"
)
func determineIfVirtualMachineSupportsNoDowntimeResize(ctx context.Context, disk *disks.Disk, virtualMachinesClient *virtualmachines.VirtualMachinesClient, skusClient *skus.SkusClient) (*bool, error) {
	if disk == nil || disk.ManagedBy == nil || disk.Sku == nil {
		return pointer.To(false), nil
	}

	virtualMachineIdRaw := disk.ManagedBy
	virtualMachineId, err := virtualmachines.ParseVirtualMachineIDInsensitively(*virtualMachineIdRaw)
	if err != nil {
		log.Printf("[DEBUG] unable to parse Virtual Machine ID %q that the Managed Disk is attached too - skipping no-downtime-resize since we can't guarantee that's available", *virtualMachineIdRaw)
		//nolint:nilerr // this is not an error as we just want to skip the check in this situation since we can't guarantee it's available
		return pointer.To(false), nil
	}

	log.Printf("[DEBUG] Retrieving %s..", *virtualMachineId)
	virtualMachine, err := virtualMachinesClient.Get(ctx, *virtualMachineId, virtualmachines.DefaultGetOperationOptions())
	if err != nil {
		return nil, fmt.Errorf("retrieving %s: %+v", *virtualMachineId, err)
	}

	vmLocation := ""
	vmSku := ""
	vmDiskControllerType := ""
	if model := virtualMachine.Model; model != nil {
		vmLocation = location.Normalize(model.Location)
		if props := model.Properties; props != nil {
			if props.HardwareProfile != nil && props.HardwareProfile.VMSize != nil {
				vmSku = string(*props.HardwareProfile.VMSize)
			}

			if props.StorageProfile != nil && props.StorageProfile.DiskControllerType != nil {
				vmDiskControllerType = string(*props.StorageProfile.DiskControllerType)
			}
		}
	}

	isUltraOrPremiumV2Disk := strings.EqualFold(string(*disk.Sku.Name), string(disks.DiskStorageAccountTypesPremiumVTwoLRS)) || strings.EqualFold(string(*disk.Sku.Name), string(disks.DiskStorageAccountTypesUltraSSDLRS))
	if isUltraOrPremiumV2Disk {
		// cannot expand a VM that's using NVMe controllers for Ultra or Premium SSD v2 disks without downtime
		return pointer.To(!strings.EqualFold(vmDiskControllerType, string(virtualmachines.DiskControllerTypesNVMe))), nil
	}

	// The following limitation doesn't apply to Premium SSD v2 or Ultra Disks
	if vmLocation == "" || vmSku == "" {
		return pointer.To(false), nil
	}

	subscriptionId := commonids.NewSubscriptionID(virtualMachineId.SubscriptionId)
	opts := skus.DefaultResourceSkusListOperationOptions()
	// @tombuildsstuff: by default this API returns EVERY SKU in EVERY LOCATION meaning this will get
	// progressively larger each time - instead we filter to the current Location only.
	opts.Filter = pointer.To(fmt.Sprintf("location eq '%s'", vmLocation))
	skusResponse, err := skusClient.ResourceSkusListComplete(ctx, subscriptionId, opts)
	if err != nil {
		return nil, fmt.Errorf("retrieving information about the Resource SKUs to check if the Virtual Machine/Disk combination supports no-downtime-resizing: %+v", err)
	}

	for _, sku := range skusResponse.Items {
		if !strings.EqualFold(pointer.From(sku.ResourceType), "virtualMachines") {
			continue
		}

		if sku.Capabilities == nil {
			continue
		}

		if !strings.EqualFold(pointer.From(sku.Name), vmSku) {
			continue
		}

		for _, capability := range *sku.Capabilities {
			if capability.Name == nil || capability.Value == nil {
				continue
			}

			supportsEphemeralOSDisks := false
			supportsHyperVGen2 := false
			supportsPremiumIO := false

			// this logic is based on:
			// if (($capability.Name -eq "EphemeralOSDiskSupported" -and $capability.Value -eq "True") -or ($capability.Name -eq "PremiumIO" -and $capability.Value -eq "True") -or ($capability.Name -eq "HyperVGenerations" -and $capability.Value -match "V2"))
			if strings.EqualFold(*capability.Name, "EphemeralOSDiskSupported") && strings.EqualFold(*capability.Value, "True") {
				supportsEphemeralOSDisks = true
			}
			if strings.EqualFold(*capability.Name, "HyperVGenerations") && strings.Contains(strings.ToLower(*capability.Value), "v2") {
				supportsHyperVGen2 = true
			}
			if strings.EqualFold(*capability.Name, "PremiumIO") && strings.EqualFold(*capability.Value, "True") {
				supportsPremiumIO = true
			}

			if supportsEphemeralOSDisks || supportsPremiumIO || supportsHyperVGen2 {
				return pointer.To(true), nil
			}
		}
	}

	return pointer.To(false), nil
}
