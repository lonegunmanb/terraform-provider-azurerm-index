package github.com/hashicorp/terraform-provider-azurerm/internal/services/resource
import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"regexp"
	"strings"
	"time"

	"github.com/Azure/azure-sdk-for-go/services/resources/mgmt/2020-06-01/resources" // nolint: staticcheck
	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/resource-manager/resources/2022-09-01/providers"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/resource/client"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
)
func deleteNestedResource(ctx context.Context, resourcesClient *resources.Client, resourceProviderApiVersions *map[string]string, nestedResource resources.Reference) error {
	parsedId, err := azure.ParseAzureResourceID(*nestedResource.ID)
	if err != nil {
		return fmt.Errorf("parsing ID %q from Template Output to delete it: %+v", *nestedResource.ID, err)
	}

	resourceProviderApiVersion, ok := (*resourceProviderApiVersions)[strings.ToLower(parsedId.Provider)]
	if !ok {
		resourceProviderApiVersion, ok = (*resourceProviderApiVersions)[strings.ToLower(parsedId.SecondaryProvider)]
		if !ok {
			return fmt.Errorf("API version information for RP %q (%q) was not found - nestedResource=%q", parsedId.Provider, parsedId.SecondaryProvider, *nestedResource.ID)
		}
	}

	log.Printf("[DEBUG] Deleting Nested Resource %q..", *nestedResource.ID)
	future, err := resourcesClient.DeleteByID(ctx, *nestedResource.ID, resourceProviderApiVersion)

	// NOTE: resourceProviderApiVersion is gotten from one of resource types of the provider.
	// When the provider has multiple resource types, it may cause API version mismatched.
	// For such error, try to get available API version from error code. Ugly but this seems sufficient for now
	if err != nil && strings.Contains(err.Error(), `Code="NoRegisteredProviderFound"`) {
		apiPat := regexp.MustCompile(`\d{4}-\d{2}-\d{2}(-preview)*`)
		matches := apiPat.FindAllStringSubmatch(err.Error(), -1)
		for _, match := range matches {
			if resourceProviderApiVersion != match[0] {
				future, err = resourcesClient.DeleteByID(ctx, *nestedResource.ID, match[0])
				break
			}
		}
	}

	if err != nil {
		if resp := future.Response(); resp != nil && resp.StatusCode == http.StatusNotFound {
			log.Printf("[DEBUG] Nested Resource %q has been deleted.. continuing..", *nestedResource.ID)
			return nil
		}

		return fmt.Errorf("deleting Nested Resource %q: %+v", *nestedResource.ID, err)
	}

	log.Printf("[DEBUG] Waiting for Deletion of Nested Resource %q..", *nestedResource.ID)
	if err := future.WaitForCompletionRef(ctx, resourcesClient.Client); err != nil {
		return fmt.Errorf("waiting for deletion of Nested Resource %q: %+v", *nestedResource.ID, err)
	}

	log.Printf("[DEBUG] Deleted Nested Resource %q.", *nestedResource.ID)
	return nil
}
