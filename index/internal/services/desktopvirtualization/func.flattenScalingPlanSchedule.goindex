package github.com/hashicorp/terraform-provider-azurerm/internal/services/desktopvirtualization
import (
	"fmt"
	"log"
	"regexp"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/desktopvirtualization/2022-02-10-preview/hostpool"
	"github.com/hashicorp/go-azure-sdk/resource-manager/desktopvirtualization/2022-02-10-preview/scalingplan"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func flattenScalingPlanSchedule(input *[]scalingplan.ScalingSchedule) []interface{} {
	results := make([]interface{}, 0)
	if input == nil {
		return results
	}

	for _, item := range *input {
		name := ""
		if item.Name != nil {
			name = *item.Name
		}
		rampUpStartTime := ""
		if item.RampUpStartTime != nil {
			rampUpStartTime = fmt.Sprintf("%02d:%02d", item.RampUpStartTime.Hour, item.RampUpStartTime.Minute)
		}
		rampUpMinimumHostsPct := int64(0)
		if item.RampUpMinimumHostsPct != nil {
			rampUpMinimumHostsPct = *item.RampUpMinimumHostsPct
		}
		rampUpCapacityThresholdPct := int64(0)
		if item.RampUpCapacityThresholdPct != nil {
			rampUpCapacityThresholdPct = *item.RampUpCapacityThresholdPct
		}
		peakStartTime := ""
		if item.PeakStartTime != nil {
			peakStartTime = fmt.Sprintf("%02d:%02d", item.PeakStartTime.Hour, item.PeakStartTime.Minute)
		}
		rampDownStartTime := ""
		if item.RampDownStartTime != nil {
			rampDownStartTime = fmt.Sprintf("%02d:%02d", item.RampDownStartTime.Hour, item.RampDownStartTime.Minute)
		}
		rampDownMinimumHostsPct := int64(0)
		if item.RampDownMinimumHostsPct != nil {
			rampDownMinimumHostsPct = *item.RampDownMinimumHostsPct
		}
		rampDownCapacityThresholdPct := int64(0)
		if item.RampDownCapacityThresholdPct != nil {
			rampDownCapacityThresholdPct = *item.RampDownCapacityThresholdPct
		}
		rampDownForceLogoffUsers := false
		if item.RampDownForceLogoffUsers != nil {
			rampDownForceLogoffUsers = *item.RampDownForceLogoffUsers
		}
		rampDownWaitTimeMinutes := int64(0)
		if item.RampDownWaitTimeMinutes != nil {
			rampDownWaitTimeMinutes = *item.RampDownWaitTimeMinutes
		}
		rampDownNotificationMessage := ""
		if item.RampDownNotificationMessage != nil {
			rampDownNotificationMessage = *item.RampDownNotificationMessage
		}
		offPeakStartTime := ""
		if item.OffPeakStartTime != nil {
			offPeakStartTime = fmt.Sprintf("%02d:%02d", item.OffPeakStartTime.Hour, item.OffPeakStartTime.Minute)
		}
		daysOfWeek := make([]string, 0)
		if item.DaysOfWeek != nil {
			for _, weekday := range *item.DaysOfWeek {
				daysOfWeek = append(daysOfWeek, string(weekday))
			}
		}

		results = append(results, map[string]interface{}{
			"name":                                 name,
			"days_of_week":                         daysOfWeek,
			"ramp_up_start_time":                   rampUpStartTime,
			"ramp_up_load_balancing_algorithm":     item.RampUpLoadBalancingAlgorithm,
			"ramp_up_minimum_hosts_percent":        rampUpMinimumHostsPct,
			"ramp_up_capacity_threshold_percent":   rampUpCapacityThresholdPct,
			"peak_start_time":                      peakStartTime,
			"peak_load_balancing_algorithm":        item.PeakLoadBalancingAlgorithm,
			"ramp_down_start_time":                 rampDownStartTime,
			"ramp_down_load_balancing_algorithm":   item.RampDownLoadBalancingAlgorithm,
			"ramp_down_minimum_hosts_percent":      rampDownMinimumHostsPct,
			"ramp_down_capacity_threshold_percent": rampDownCapacityThresholdPct,
			"ramp_down_force_logoff_users":         rampDownForceLogoffUsers,
			"ramp_down_stop_hosts_when":            item.RampDownStopHostsWhen,
			"ramp_down_wait_time_minutes":          rampDownWaitTimeMinutes,
			"ramp_down_notification_message":       rampDownNotificationMessage,
			"off_peak_start_time":                  offPeakStartTime,
			"off_peak_load_balancing_algorithm":    item.OffPeakLoadBalancingAlgorithm,
		})
	}
	return results
}
