package github.com/hashicorp/terraform-provider-azurerm/internal/services/kusto
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/zones"
	"github.com/hashicorp/go-azure-sdk/resource-manager/kusto/2024-04-13/clusters"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/kusto/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/kusto/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceKustoClusterUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Kusto.ClustersClient
	ctx, cancel := timeouts.ForUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := commonids.ParseKustoClusterID(d.Id())
	if err != nil {
		return err
	}

	locks.ByName(id.KustoClusterName, "azurerm_kusto_cluster")
	defer locks.UnlockByName(id.KustoClusterName, "azurerm_kusto_cluster")

	existing, err := client.Get(ctx, *id)
	if err != nil {
		return fmt.Errorf("retrieving %s: %+v", id, err)
	}

	if existing.Model == nil {
		return fmt.Errorf("retrieving %s: `model` was nil", *id)
	}

	if existing.Model.Properties == nil {
		return fmt.Errorf("retrieving %s: `properties` was nil", *id)
	}
	model := existing.Model
	props := model.Properties

	if d.HasChange("sku") || d.HasChange("optimized_auto_scale") {
		sku, err := expandKustoClusterSku(d.Get("sku").([]interface{}))
		if err != nil {
			return err
		}

		optimizedAutoScale := expandOptimizedAutoScale(d.Get("optimized_auto_scale").([]interface{}))

		if optimizedAutoScale != nil && optimizedAutoScale.IsEnabled {
			if sku.Capacity == nil {
				return fmt.Errorf("sku.capacity cannot be empty")
			}
			// Ensure that requested Capcity is always between min and max to support updating to not overlapping autoscale ranges
			if *sku.Capacity < optimizedAutoScale.Minimum {
				sku.Capacity = pointer.To(optimizedAutoScale.Minimum)
			}
			if *sku.Capacity > optimizedAutoScale.Maximum {
				sku.Capacity = pointer.To(optimizedAutoScale.Maximum)
			}
			if optimizedAutoScale.Minimum > optimizedAutoScale.Maximum {
				return fmt.Errorf("`optimized_auto_scaling.maximum_instances` must be >= `optimized_auto_scaling.minimum_instances`")
			}
		}
		model.Sku = *sku
		// optimized_auto_scale can't be updated when the sku is also being updated, so we'll update sku first and then optimized_auto_scale
		if d.HasChange("optimized_auto_scale") && d.HasChange("sku") {
			model.Properties.OptimizedAutoscale = nil
			if err := client.CreateOrUpdateThenPoll(ctx, *id, *model, clusters.CreateOrUpdateOperationOptions{}); err != nil {
				return fmt.Errorf("updating %s: %+v", id, err)
			}
		}
		props.OptimizedAutoscale = optimizedAutoScale
	}

	if d.HasChange("location") {
		model.Location = location.Normalize(d.Get("location").(string))
	}

	if d.HasChange("identity") {
		expandedIdentity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
		if err != nil {
			return fmt.Errorf("expanding `identity`: %+v", err)
		}
		model.Identity = expandedIdentity
	}

	if d.HasChange("allowed_fqdns") {
		props.AllowedFqdnList = expandKustoListString(d.Get("allowed_fqdns").([]interface{}))
	}

	if d.HasChange("allowed_ip_ranges") {
		props.AllowedIPRangeList = expandKustoListString(d.Get("allowed_ip_ranges").([]interface{}))
	}

	if d.HasChange("auto_stop_enabled") {
		props.EnableAutoStop = pointer.To(d.Get("auto_stop_enabled").(bool))
	}

	if d.HasChange("disk_encryption_enabled") {
		props.EnableDiskEncryption = pointer.To(d.Get("disk_encryption_enabled").(bool))
	}

	if d.HasChange("double_encryption_enabled") {
		props.EnableDoubleEncryption = pointer.To(d.Get("double_encryption_enabled").(bool))
	}

	if d.HasChange("language_extension") {
		props.LanguageExtensions = expandKustoClusterLanguageExtensionList(d.Get("language_extension").([]any))
	}

	if !features.FivePointOh() {
		if d.HasChange("language_extensions") {
			props.LanguageExtensions = expandKustoClusterLanguageExtensionList(d.Get("language_extensions").([]any))
		} else if len(d.Get("language_extensions").([]any)) > 0 || len(d.Get("language_extension").([]any)) > 0 {
			hasError := false
			rawLanguageExtensions, diags := d.GetRawConfigAt(sdk.ConstructCtyPath("language_extensions"))
			if diags.HasError() {
				hasError = true
			}

			rawLanguageExtension, diags := d.GetRawConfigAt(sdk.ConstructCtyPath("language_extension"))
			if diags.HasError() {
				hasError = true
			}

			// If RawConfig has a slice of len 0 for both blocks we want to ensure the API payload contains an empty slice to remove any language extensions.
			// This is a workaround to the O+C behaviour where removing all blocks from config doesn't trigger a change.
			// While the `CustomizeDiff` does update `*ResourceDiff` with the updated (empty) value, it doesn't seem to propagate through to the `*ResourceData` in `Update()`
			if !hasError && !rawLanguageExtensions.IsNull() && rawLanguageExtensions.IsKnown() && !rawLanguageExtension.IsNull() && rawLanguageExtension.IsKnown() {
				if len(rawLanguageExtensions.AsValueSlice()) == 0 && len(rawLanguageExtension.AsValueSlice()) == 0 {
					props.LanguageExtensions = expandKustoClusterLanguageExtensionList(make([]any, 0))
				}
			}
		}
	}

	if d.HasChange("outbound_network_access_restricted") {
		restrictOutboundNetworkAccess := clusters.ClusterNetworkAccessFlagDisabled
		if d.Get("outbound_network_access_restricted").(bool) {
			restrictOutboundNetworkAccess = clusters.ClusterNetworkAccessFlagEnabled
		}
		props.RestrictOutboundNetworkAccess = pointer.To(restrictOutboundNetworkAccess)
	}

	if d.HasChange("purge_enabled") {
		props.EnablePurge = pointer.To(d.Get("purge_enabled").(bool))
	}

	if d.HasChange("public_ip_type") {
		publicIPType := clusters.PublicIPType(d.Get("public_ip_type").(string))
		props.PublicIPType = pointer.To(publicIPType)
	}

	if d.HasChange("public_network_access_enabled") {
		publicNetworkAccess := clusters.PublicNetworkAccessEnabled
		if !d.Get("public_network_access_enabled").(bool) {
			publicNetworkAccess = clusters.PublicNetworkAccessDisabled
		}
		props.PublicNetworkAccess = pointer.To(publicNetworkAccess)
	}

	if d.HasChange("streaming_ingestion_enabled") {
		props.EnableStreamingIngest = pointer.To(d.Get("streaming_ingestion_enabled").(bool))
	}

	if d.HasChange("trusted_external_tenants") {
		props.TrustedExternalTenants = expandTrustedExternalTenants(d.Get("trusted_external_tenants").([]interface{}))
	}

	if !features.FivePointOh() {
		if d.HasChange("virtual_network_configuration") {
			if v, ok := d.GetOk("virtual_network_configuration"); ok {
				if vnetConfig := expandKustoClusterVNET(v.([]interface{})); vnetConfig != nil {
					props.VirtualNetworkConfiguration = vnetConfig
				}
			} else {
				// 'State' is hardcoded to 'Disabled' for the 'None' pattern.
				// If the vNet block is present it is enabled, if the vNet block is removed it is disabled.
				props.VirtualNetworkConfiguration.State = pointer.To(clusters.VnetStateDisabled)
			}
		}
	}

	if d.HasChange("zones") {
		zoneList := zones.ExpandUntyped(d.Get("zones").(*schema.Set).List())
		model.Zones = pointer.To(zoneList)
		if len(zoneList) > 0 {
			model.Zones = &zoneList
		} else {
			model.Zones = nil
		}
	}

	if d.HasChange("tags") {
		model.Tags = tags.Expand(d.Get("tags").(map[string]interface{}))
	}

	model.Properties = props

	if err := client.CreateOrUpdateThenPoll(ctx, *id, *model, clusters.CreateOrUpdateOperationOptions{}); err != nil {
		return fmt.Errorf("updating %s: %+v", id, err)
	}

	d.SetId(id.ID())
	return resourceKustoClusterRead(d, meta)
}
