package github.com/hashicorp/terraform-provider-azurerm/internal/services/network
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/zones"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-09-01/ddosprotectionplans"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-11-01/publicipprefixes"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2024-05-01/publicipaddresses"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/network/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourcePublicIpCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Network.PublicIPAddresses
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	log.Printf("[INFO] preparing arguments for AzureRM Public IP creation.")

	id := commonids.NewPublicIPAddressID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))

	existing, err := client.Get(ctx, id, publicipaddresses.DefaultGetOperationOptions())
	if err != nil {
		if !response.WasNotFound(existing.HttpResponse) {
			return fmt.Errorf("checking for presence of existing %s: %+v", id, err)
		}
	}

	if !response.WasNotFound(existing.HttpResponse) {
		return tf.ImportAsExistsError("azurerm_public_ip", id.ID())
	}

	sku := d.Get("sku").(string)
	ipAllocationMethod := d.Get("allocation_method").(string)

	if strings.EqualFold(sku, "standard") {
		if !strings.EqualFold(ipAllocationMethod, "static") {
			return fmt.Errorf("static IP allocation must be used when creating Standard SKU public IP addresses")
		}
	}

	ddosProtectionMode := d.Get("ddos_protection_mode").(string)

	publicIp := publicipaddresses.PublicIPAddress{
		Name:             pointer.To(id.PublicIPAddressesName),
		ExtendedLocation: expandEdgeZoneNew(d.Get("edge_zone").(string)),
		Location:         pointer.To(location.Normalize(d.Get("location").(string))),
		Sku: &publicipaddresses.PublicIPAddressSku{
			Name: pointer.To(publicipaddresses.PublicIPAddressSkuName(sku)),
			Tier: pointer.To(publicipaddresses.PublicIPAddressSkuTier(d.Get("sku_tier").(string))),
		},
		Properties: &publicipaddresses.PublicIPAddressPropertiesFormat{
			PublicIPAllocationMethod: pointer.To(publicipaddresses.IPAllocationMethod(ipAllocationMethod)),
			PublicIPAddressVersion:   pointer.To(publicipaddresses.IPVersion(d.Get("ip_version").(string))),
			IdleTimeoutInMinutes:     pointer.To(int64(d.Get("idle_timeout_in_minutes").(int))),
			DdosSettings: &publicipaddresses.DdosSettings{
				ProtectionMode: pointer.To(publicipaddresses.DdosSettingsProtectionMode(ddosProtectionMode)),
			},
		},
		Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	ddosProtectionPlanId, planOk := d.GetOk("ddos_protection_plan_id")
	if planOk {
		if !strings.EqualFold(ddosProtectionMode, "enabled") {
			return fmt.Errorf("ddos protection plan id can only be set when ddos protection is enabled")
		}
		publicIp.Properties.DdosSettings.DdosProtectionPlan = &publicipaddresses.SubResource{
			Id: pointer.To(ddosProtectionPlanId.(string)),
		}
	}

	zones := zones.ExpandUntyped(d.Get("zones").(*schema.Set).List())
	if len(zones) > 0 {
		publicIp.Zones = &zones
	}

	publicIpPrefixId, publicIpPrefixIdOk := d.GetOk("public_ip_prefix_id")

	if publicIpPrefixIdOk {
		publicIpPrefix := publicipaddresses.SubResource{}
		publicIpPrefix.Id = pointer.To(publicIpPrefixId.(string))
		publicIp.Properties.PublicIPPrefix = &publicIpPrefix
	}

	dnl, dnlOk := d.GetOk("domain_name_label")
	rfqdn, rfqdnOk := d.GetOk("reverse_fqdn")
	dnlc, dnlcOk := d.GetOk("domain_name_label_scope")

	if dnlOk || rfqdnOk || dnlcOk {
		dnsSettings := publicipaddresses.PublicIPAddressDnsSettings{}

		if rfqdnOk {
			dnsSettings.ReverseFqdn = pointer.To(rfqdn.(string))
		}

		if dnlOk {
			dnsSettings.DomainNameLabel = pointer.To(dnl.(string))
		}

		if dnlcOk {
			dnsSettings.DomainNameLabelScope = pointer.To(publicipaddresses.PublicIPAddressDnsSettingsDomainNameLabelScope(dnlc.(string)))
		}

		publicIp.Properties.DnsSettings = &dnsSettings
	}

	if v, ok := d.GetOk("ip_tags"); ok {
		ipTags := v.(map[string]interface{})
		newIpTags := []publicipaddresses.IPTag{}

		for key, val := range ipTags {
			ipTag := publicipaddresses.IPTag{
				IPTagType: pointer.To(key),
				Tag:       pointer.To(val.(string)),
			}
			newIpTags = append(newIpTags, ipTag)
		}

		publicIp.Properties.IPTags = &newIpTags
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, publicIp); err != nil {
		return fmt.Errorf("updating %s: %+v", id, err)
	}

	d.SetId(id.ID())
	return resourcePublicIpRead(d, meta)
}
