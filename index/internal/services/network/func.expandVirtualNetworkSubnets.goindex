package github.com/hashicorp/terraform-provider-azurerm/internal/services/network
import (
	"bytes"
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-09-01/ddosprotectionplans"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-11-01/networksecuritygroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-11-01/routetables"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-11-01/serviceendpointpolicies"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2023-11-01/subnets"
	"github.com/hashicorp/go-azure-sdk/resource-manager/network/2024-05-01/virtualnetworks"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/network/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func expandVirtualNetworkSubnets(ctx context.Context, client virtualnetworks.VirtualNetworksClient, input []interface{}, id commonids.VirtualNetworkId) (*[]virtualnetworks.Subnet, *[]string, error) {
	subnets := make([]virtualnetworks.Subnet, 0)
	routeTables := make([]string, 0)

	if len(input) == 0 {
		return &subnets, &routeTables, nil
	}

	for _, subnetRaw := range input {
		if subnetRaw == nil {
			continue
		}
		subnet := subnetRaw.(map[string]interface{})

		name := subnet["name"].(string)
		log.Printf("[INFO] setting subnets inside vNet, processing %q", name)
		// since subnets can also be created outside of vNet definition (as root objects)
		// do a GET on subnet properties from the server before setting them
		subnetObj, err := getExistingSubnet(ctx, client, id, name)
		if err != nil {
			return nil, nil, err
		}
		log.Printf("[INFO] Completed GET of Subnet props")

		// set the props from config and leave the rest intact
		subnetObj.Name = pointer.To(name)
		if subnetObj.Properties == nil {
			subnetObj.Properties = &virtualnetworks.SubnetPropertiesFormat{}
		}

		addressPrefixes := make([]string, 0)
		for _, prefix := range subnet["address_prefixes"].([]interface{}) {
			addressPrefixes = append(addressPrefixes, prefix.(string))
		}

		if len(addressPrefixes) == 1 {
			subnetObj.Properties.AddressPrefix = pointer.To(addressPrefixes[0])
			subnetObj.Properties.AddressPrefixes = nil
		} else {
			subnetObj.Properties.AddressPrefixes = pointer.To(addressPrefixes)
			subnetObj.Properties.AddressPrefix = nil
		}

		privateEndpointNetworkPolicies := virtualnetworks.VirtualNetworkPrivateEndpointNetworkPolicies(subnet["private_endpoint_network_policies"].(string))
		privateLinkServiceNetworkPolicies := virtualnetworks.VirtualNetworkPrivateLinkServiceNetworkPoliciesDisabled
		if subnet["private_link_service_network_policies_enabled"].(bool) {
			privateLinkServiceNetworkPolicies = virtualnetworks.VirtualNetworkPrivateLinkServiceNetworkPoliciesEnabled
		}
		subnetObj.Properties.DefaultOutboundAccess = pointer.To(subnet["default_outbound_access_enabled"].(bool))
		subnetObj.Properties.Delegations = expandVirtualNetworkSubnetDelegation(subnet["delegation"].([]interface{}))
		subnetObj.Properties.PrivateEndpointNetworkPolicies = pointer.To(privateEndpointNetworkPolicies)
		subnetObj.Properties.PrivateLinkServiceNetworkPolicies = pointer.To(privateLinkServiceNetworkPolicies)

		if routeTableId := subnet["route_table_id"].(string); routeTableId != "" {
			id, err := routetables.ParseRouteTableID(routeTableId)
			if err != nil {
				return nil, nil, err
			}

			// Collecting a list of route tables to lock on outside of this function
			routeTables = append(routeTables, id.RouteTableName)
			subnetObj.Properties.RouteTable = &virtualnetworks.RouteTable{
				Id: pointer.To(id.ID()),
			}
		} else {
			subnetObj.Properties.RouteTable = nil
		}

		subnetObj.Properties.ServiceEndpointPolicies = expandVirtualNetworkSubnetServiceEndpointPolicies(subnet["service_endpoint_policy_ids"].(*pluginsdk.Set).List())
		subnetObj.Properties.ServiceEndpoints = expandVirtualNetworkSubnetServiceEndpoints(subnet["service_endpoints"].(*pluginsdk.Set).List())

		if secGroup := subnet["security_group"].(string); secGroup != "" {
			subnetObj.Properties.NetworkSecurityGroup = &virtualnetworks.NetworkSecurityGroup{
				Id: &secGroup,
			}
		} else {
			subnetObj.Properties.NetworkSecurityGroup = nil
		}

		subnets = append(subnets, *subnetObj)
	}

	return &subnets, &routeTables, nil
}
