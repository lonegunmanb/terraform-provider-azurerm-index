package github.com/hashicorp/terraform-provider-azurerm/internal/services/containers
import (
	"context"
	"fmt"
	"log"
	"sort"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/containerregistry/2023-11-01-preview/operation"
	"github.com/hashicorp/go-azure-sdk/resource-manager/containerregistry/2023-11-01-preview/registries"
	"github.com/hashicorp/go-azure-sdk/resource-manager/containerregistry/2023-11-01-preview/replications"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/containers/migration"
	containerValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/containers/validate"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceContainerRegistryCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Containers.ContainerRegistryClient.Registries
	operationClient := meta.(*clients.Client).Containers.ContainerRegistryClient.Operation
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()
	log.Printf("[INFO] preparing arguments for  Container Registry creation.")

	id := registries.NewRegistryID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))

	if d.IsNewResource() {
		existing, err := client.Get(ctx, id)
		if err != nil {
			if !response.WasNotFound(existing.HttpResponse) {
				return fmt.Errorf("checking for presence of existing %s: %s", id, err)
			}
		}

		if !response.WasNotFound(existing.HttpResponse) {
			return tf.ImportAsExistsError("azurerm_container_registry", id.ID())
		}
	}

	sId := commonids.NewSubscriptionID(subscriptionId)
	availabilityRequest := operation.RegistryNameCheckRequest{
		Name: id.RegistryName,
		Type: "Microsoft.ContainerRegistry/registries",
	}
	resp, err := operationClient.RegistriesCheckNameAvailability(ctx, sId, availabilityRequest)
	if err != nil {
		return fmt.Errorf("checking if the name %q was available: %+v", id.RegistryName, err)
	}

	if resp.Model == nil && resp.Model.NameAvailable == nil {
		return fmt.Errorf("checking name availability for %s: model was nil", id)
	}

	if available := *resp.Model.NameAvailable; !available {
		return fmt.Errorf("the name %q used for the Container Registry needs to be globally unique and isn't available: %s", id.RegistryName, *resp.Model.Message)
	}

	sku := d.Get("sku").(string)

	networkRuleSet := expandNetworkRuleSet(d.Get("network_rule_set").([]interface{}))
	if networkRuleSet != nil && !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
		return fmt.Errorf("`network_rule_set_set` can only be specified for a Premium Sku. If you are reverting from a Premium to Basic SKU please set network_rule_set = []")
	}

	identity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
	if err != nil {
		return fmt.Errorf("expanding `identity`: %+v", err)
	}

	publicNetworkAccess := registries.PublicNetworkAccessEnabled
	if !d.Get("public_network_access_enabled").(bool) {
		if !strings.EqualFold(sku, string(registries.SkuNamePremium)) {
			return fmt.Errorf("`public_network_access_enabled` can only be disabled for a Premium Sku.")
		}

		publicNetworkAccess = registries.PublicNetworkAccessDisabled
	}

	zoneRedundancy := registries.ZoneRedundancyDisabled
	if d.Get("zone_redundancy_enabled").(bool) {
		zoneRedundancy = registries.ZoneRedundancyEnabled
	}

	retentionPolicy := &registries.RetentionPolicy{}
	if v, ok := d.GetOk("retention_policy_in_days"); ok && v.(int) > 0 {
		retentionPolicy.Days = pointer.To(int64(v.(int)))
		retentionPolicy.Status = pointer.To(registries.PolicyStatusEnabled)
	}

	trustPolicy := &registries.TrustPolicy{}
	if v, ok := d.GetOk("trust_policy_enabled"); ok && v.(bool) {
		trustPolicy.Status = pointer.To(registries.PolicyStatusEnabled)
	}

	parameters := registries.Registry{
		Location: location.Normalize(d.Get("location").(string)),
		Sku: registries.Sku{
			Name: registries.SkuName(sku),
			Tier: pointer.To(registries.SkuTier(sku)),
		},
		Identity: identity,
		Properties: &registries.RegistryProperties{
			AdminUserEnabled: pointer.To(d.Get("admin_enabled").(bool)),
			Encryption:       expandEncryption(d.Get("encryption").([]interface{})),
			NetworkRuleSet:   networkRuleSet,
			Policies: &registries.Policies{
				QuarantinePolicy: expandQuarantinePolicy(d.Get("quarantine_policy_enabled").(bool)),
				RetentionPolicy:  retentionPolicy,
				TrustPolicy:      trustPolicy,
				ExportPolicy:     expandExportPolicy(d.Get("export_policy_enabled").(bool)),
			},
			PublicNetworkAccess:      &publicNetworkAccess,
			ZoneRedundancy:           &zoneRedundancy,
			AnonymousPullEnabled:     pointer.To(d.Get("anonymous_pull_enabled").(bool)),
			DataEndpointEnabled:      pointer.To(d.Get("data_endpoint_enabled").(bool)),
			NetworkRuleBypassOptions: pointer.To(registries.NetworkRuleBypassOptions(d.Get("network_rule_bypass_option").(string))),
		},

		Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	if err := client.CreateThenPoll(ctx, id, parameters); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}

	// the ACR is being created so no previous geo-replication locations
	var oldGeoReplicationLocations, newGeoReplicationLocations []replications.Replication
	newGeoReplicationLocations = expandReplications(d.Get("georeplications").([]interface{}))
	// geo replications have been specified
	if len(newGeoReplicationLocations) > 0 {
		err = applyGeoReplicationLocations(ctx, meta, id, oldGeoReplicationLocations, newGeoReplicationLocations)
		if err != nil {
			return fmt.Errorf("applying geo replications for %s: %+v", id, err)
		}
	}

	d.SetId(id.ID())

	return resourceContainerRegistryRead(d, meta)
}
