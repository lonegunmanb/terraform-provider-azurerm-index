package github.com/hashicorp/terraform-provider-azurerm/internal/services/containers
import (
	"bytes"
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/zones"
	"github.com/hashicorp/go-azure-sdk/resource-manager/containerinstance/2023-05-01/containerinstance"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	keyVaultParse "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	keyVaultValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceContainerGroupRead(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).Containers.ContainerInstanceClient
	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := containerinstance.ParseContainerGroupID(d.Id())
	if err != nil {
		return err
	}

	resp, err := client.ContainerGroupsGet(ctx, *id)
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			log.Printf("[DEBUG] %s was not found - removing from state!", *id)
			d.SetId("")
			return nil
		}
		return err
	}

	d.Set("name", id.ContainerGroupName)
	d.Set("resource_group_name", id.ResourceGroupName)

	if model := resp.Model; model != nil {
		d.Set("location", location.NormalizeNilable(model.Location))
		identity, err := identity.FlattenSystemAndUserAssignedMap(model.Identity)
		if err != nil {
			return fmt.Errorf("flattening `identity`: %+v", err)
		}
		if err := d.Set("identity", identity); err != nil {
			return fmt.Errorf("setting `identity`: %+v", err)
		}

		if err := tags.FlattenAndSet(d, model.Tags); err != nil {
			return err
		}

		d.Set("zones", zones.FlattenUntyped(model.Zones))

		props := model.Properties

		var sku string
		if v := props.Sku; v != nil {
			sku = string(*v)
		}
		d.Set("sku", sku)

		var priority string
		if v := props.Priority; v != nil {
			priority = string(*v)
		}
		d.Set("priority", priority)

		containerConfigs := flattenContainerGroupContainers(d, &props.Containers, props.Volumes)
		if err := d.Set("container", containerConfigs); err != nil {
			return fmt.Errorf("setting `container`: %+v", err)
		}
		initContainerConfigs := flattenContainerGroupInitContainers(d, props.InitContainers, props.Volumes)
		if err := d.Set("init_container", initContainerConfigs); err != nil {
			return fmt.Errorf("setting `init_container`: %+v", err)
		}

		if err := d.Set("image_registry_credential", flattenContainerImageRegistryCredentials(d, props.ImageRegistryCredentials)); err != nil {
			return fmt.Errorf("setting `image_registry_credential`: %+v", err)
		}

		if address := props.IPAddress; address != nil {
			d.Set("ip_address_type", address.Type)
			d.Set("ip_address", address.IP)
			exposedPorts := make([]interface{}, len(address.Ports))
			for i := range address.Ports {
				exposedPorts[i] = (address.Ports)[i]
			}
			d.Set("exposed_port", flattenPorts(exposedPorts))
			d.Set("dns_name_label", address.DnsNameLabel)
			d.Set("fqdn", address.Fqdn)

			if address.AutoGeneratedDomainNameLabelScope != nil {
				d.Set("dns_name_label_reuse_policy", string(*address.AutoGeneratedDomainNameLabelScope))
			} else {
				d.Set("dns_name_label_reuse_policy", containerinstance.DnsNameLabelReusePolicyUnsecure)
			}
		} else {
			d.Set("dns_name_label_reuse_policy", pointer.To(string(containerinstance.DnsNameLabelReusePolicyUnsecure)))
		}

		restartPolicy := ""
		if props.RestartPolicy != nil {
			restartPolicy = string(*props.RestartPolicy)
		}
		d.Set("restart_policy", restartPolicy)

		d.Set("os_type", string(props.OsType))
		d.Set("dns_config", flattenContainerGroupDnsConfig(props.DnsConfig))

		if err := d.Set("diagnostics", flattenContainerGroupDiagnostics(d, props.Diagnostics)); err != nil {
			return fmt.Errorf("setting `diagnostics`: %+v", err)
		}

		subnets, err := flattenContainerGroupSubnets(props.SubnetIds)
		if err != nil {
			return err
		}
		if err := d.Set("subnet_ids", subnets); err != nil {
			return fmt.Errorf("setting `subnet_ids`: %+v", err)
		}

		if kvProps := props.EncryptionProperties; kvProps != nil {
			var keyVaultUri, keyName, keyVersion string
			if kvProps.VaultBaseURL != "" {
				keyVaultUri = kvProps.VaultBaseURL
			} else {
				return fmt.Errorf("empty value returned for Key Vault URI")
			}
			if kvProps.KeyName != "" {
				keyName = kvProps.KeyName
			} else {
				return fmt.Errorf("empty value returned for Key Vault Key Name")
			}
			keyVersion = kvProps.KeyVersion
			keyId, err := keyVaultParse.NewNestedItemID(keyVaultUri, keyVaultParse.NestedItemTypeKey, keyName, keyVersion)
			if err != nil {
				return err
			}
			d.Set("key_vault_key_id", keyId.ID())
			d.Set("key_vault_user_assigned_identity_id", pointer.From(kvProps.Identity))
		}
	}

	return nil
}
