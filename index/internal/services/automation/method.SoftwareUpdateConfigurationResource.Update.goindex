package github.com/hashicorp/terraform-provider-azurerm/internal/services/automation
import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/automation/2019-06-01/softwareupdateconfiguration"
	"github.com/hashicorp/go-azure-sdk/resource-manager/automation/2023-11-01/automationaccount"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	validate4 "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	validate2 "github.com/hashicorp/terraform-provider-azurerm/internal/services/resource/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (m SoftwareUpdateConfigurationResource) Update() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 30 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.Automation.SoftwareUpdateConfigClient

			id, err := softwareupdateconfiguration.ParseSoftwareUpdateConfigurationID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}

			var model SoftwareUpdateConfigurationModel
			if err = metadata.Decode(&model); err != nil {
				return fmt.Errorf("decoding: %+v", err)
			}

			resp, err := client.GetByName(ctx, *id, softwareupdateconfiguration.DefaultGetByNameOperationOptions())
			if err != nil {
				return fmt.Errorf("reading %s: %+v", *id, err)
			}

			existing := resp.Model

			if metadata.ResourceData.HasChange("linux") {
				if len(model.Linux) > 0 {
					existing.Properties.UpdateConfiguration.OperatingSystem = softwareupdateconfiguration.OperatingSystemTypeLinux
					v := model.Linux[0]
					existing.Properties.UpdateConfiguration.Linux = &softwareupdateconfiguration.LinuxProperties{
						ExcludedPackageNameMasks:       pointer.To(v.ExcludedPackages),
						IncludedPackageClassifications: pointer.To(softwareupdateconfiguration.LinuxUpdateClasses(strings.Join(v.Classifications, ","))),
						IncludedPackageNameMasks:       pointer.To(v.IncludedPackages),
						RebootSetting:                  pointer.To(v.Reboot),
					}
				} else {
					existing.Properties.UpdateConfiguration.Linux = &softwareupdateconfiguration.LinuxProperties{}
				}
			}

			if metadata.ResourceData.HasChange("windows") {
				if len(model.Windows) > 0 {
					existing.Properties.UpdateConfiguration.OperatingSystem = softwareupdateconfiguration.OperatingSystemTypeWindows
					v := model.Windows[0]
					existing.Properties.UpdateConfiguration.Windows = &softwareupdateconfiguration.WindowsProperties{
						ExcludedKbNumbers:             pointer.To(v.ExcludedKbs),
						IncludedKbNumbers:             pointer.To(v.IncludedKbs),
						IncludedUpdateClassifications: pointer.To(softwareupdateconfiguration.WindowsUpdateClasses(strings.Join(v.Classifications, ","))),
						RebootSetting:                 pointer.To(v.RebootSetting),
					}
				} else {
					existing.Properties.UpdateConfiguration.Windows = &softwareupdateconfiguration.WindowsProperties{}
				}
			}

			if metadata.ResourceData.HasChange("duration") {
				existing.Properties.UpdateConfiguration.Duration = pointer.To(model.Duration)
			}

			if metadata.ResourceData.HasChange("virtual_machine_ids") {
				existing.Properties.UpdateConfiguration.AzureVirtualMachines = pointer.To(model.VirtualMachines)
			}

			if metadata.ResourceData.HasChange("non_azure_computer_names") {
				existing.Properties.UpdateConfiguration.NonAzureComputerNames = pointer.To(model.NonAzureComputerNames)
			}

			if metadata.ResourceData.HasChange("target") {
				target := softwareupdateconfiguration.TargetProperties{}
				if len(model.Targets) > 0 {
					t := model.Targets[0]
					if len(t.AzureQueries) > 0 {
						aq := make([]softwareupdateconfiguration.AzureQueryProperties, 0)
						for _, v := range t.AzureQueries {
							q := softwareupdateconfiguration.AzureQueryProperties{}
							if len(v.Locations) > 0 {
								q.Locations = pointer.To(v.Locations)
							}
							if len(v.Scope) > 0 {
								q.Scope = pointer.To(v.Scope)
							}
							if len(v.Tags) > 0 || v.TagFilter != "" {
								q.TagSettings = &softwareupdateconfiguration.TagSettingsProperties{
									FilterOperator: pointer.To(softwareupdateconfiguration.TagOperators(v.TagFilter)),
								}
								tags := make(map[string][]string)
								for _, tag := range v.Tags {
									tags[tag.Tag] = tag.Values
								}
								q.TagSettings.Tags = pointer.To(tags)
							}

							aq = append(aq, q)
						}

						target.AzureQueries = pointer.To(aq)
					} else {
						target.AzureQueries = &[]softwareupdateconfiguration.AzureQueryProperties{}
					}

					if len(t.NonAzureQueries) > 0 {
						naqs := make([]softwareupdateconfiguration.NonAzureQueryProperties, 0)
						for _, v := range t.NonAzureQueries {
							naq := softwareupdateconfiguration.NonAzureQueryProperties{}
							if v.FunctionAlias != "" {
								naq.FunctionAlias = pointer.To(v.FunctionAlias)
							}
							if v.WorkspaceId != "" {
								naq.WorkspaceId = pointer.To(v.WorkspaceId)
							}
							naqs = append(naqs, naq)
						}

						target.NonAzureQueries = pointer.To(naqs)
					} else {
						target.NonAzureQueries = &[]softwareupdateconfiguration.NonAzureQueryProperties{}
					}
				} else {
					target.AzureQueries = &[]softwareupdateconfiguration.AzureQueryProperties{}
					target.NonAzureQueries = &[]softwareupdateconfiguration.NonAzureQueryProperties{}
				}
				existing.Properties.UpdateConfiguration.Targets = pointer.To(target)
			}

			if metadata.ResourceData.HasChange("schedule") {
				if len(model.Schedule) == 1 {
					v := model.Schedule[0]
					scheduleConfig := softwareupdateconfiguration.SUCScheduleProperties{
						Description:             pointer.To(v.Description),
						ExpiryTime:              pointer.To(v.ExpiryTime),
						ExpiryTimeOffsetMinutes: pointer.To(v.ExpiryTimeOffsetMinutes),
						Frequency:               pointer.To(softwareupdateconfiguration.ScheduleFrequency(v.Frequency)),
						Interval:                pointer.To(v.Interval),
						IsEnabled:               pointer.To(v.IsEnabled),
						NextRun:                 pointer.To(v.NextRun),
						NextRunOffsetMinutes:    pointer.To(v.NextRunOffsetMinutes),
						StartTime:               pointer.To(v.StartTime),
						StartTimeOffsetMinutes:  pointer.To(v.StartTimeOffsetMinutes),
						TimeZone:                pointer.To(v.TimeZone),
					}

					if len(v.AdvancedWeekDays) > 0 || len(v.AdvancedMonthDays) > 0 || len(v.MonthlyOccurrence) > 0 {
						advSchedule := &softwareupdateconfiguration.AdvancedSchedule{}
						if len(v.AdvancedWeekDays) > 0 {
							advSchedule.WeekDays = pointer.To(v.AdvancedWeekDays)
						}

						if len(v.AdvancedMonthDays) > 0 {
							advSchedule.MonthDays = pointer.To(v.AdvancedMonthDays)
						}

						if len(v.MonthlyOccurrence) > 0 {
							monthlyOccurrences := make([]softwareupdateconfiguration.AdvancedScheduleMonthlyOccurrence, 0)
							for _, mo := range v.MonthlyOccurrence {
								monthlyOccurrences = append(monthlyOccurrences, softwareupdateconfiguration.AdvancedScheduleMonthlyOccurrence{
									Day:        pointer.To(softwareupdateconfiguration.ScheduleDay(mo.Day)),
									Occurrence: pointer.To(mo.Occurrence),
								})
							}

							advSchedule.MonthlyOccurrences = pointer.To(monthlyOccurrences)
						}

						scheduleConfig.AdvancedSchedule = advSchedule
					}

					existing.Properties.ScheduleInfo = scheduleConfig
				} else {
					existing.Properties.ScheduleInfo = softwareupdateconfiguration.SUCScheduleProperties{}
				}
			}

			if metadata.ResourceData.HasChanges("pre_task", "post_task") {
				tasksConfig := &softwareupdateconfiguration.SoftwareUpdateConfigurationTasks{}
				if existing.Properties.Tasks != nil {
					tasksConfig = existing.Properties.Tasks
				}
				if len(model.PreTask) > 0 {
					v := model.PreTask[0]
					task := &softwareupdateconfiguration.TaskProperties{
						Parameters: pointer.To(v.Parameters),
						Source:     pointer.To(v.Source),
					}

					tasksConfig.PreTask = task
				} else {
					tasksConfig.PreTask = &softwareupdateconfiguration.TaskProperties{}
				}
				if len(model.PostTask) > 0 {
					v := model.PostTask[0]
					task := &softwareupdateconfiguration.TaskProperties{
						Parameters: pointer.To(v.Parameters),
						Source:     pointer.To(v.Source),
					}

					tasksConfig.PostTask = task
				} else {
					tasksConfig.PostTask = &softwareupdateconfiguration.TaskProperties{}
				}
			}

			if _, err = client.Create(ctx, *id, *existing, softwareupdateconfiguration.DefaultCreateOperationOptions()); err != nil {
				return fmt.Errorf("creating %s: %v", id, err)
			}

			return nil
		},
	}
}
