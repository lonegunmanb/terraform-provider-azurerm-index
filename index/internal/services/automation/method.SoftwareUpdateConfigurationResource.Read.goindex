package github.com/hashicorp/terraform-provider-azurerm/internal/services/automation
import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/automation/2019-06-01/softwareupdateconfiguration"
	"github.com/hashicorp/go-azure-sdk/resource-manager/automation/2023-11-01/automationaccount"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	validate4 "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	validate2 "github.com/hashicorp/terraform-provider-azurerm/internal/services/resource/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (m SoftwareUpdateConfigurationResource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, meta sdk.ResourceMetaData) error {
			id, err := softwareupdateconfiguration.ParseSoftwareUpdateConfigurationID(meta.ResourceData.Id())
			if err != nil {
				return err
			}
			client := meta.Client.Automation.SoftwareUpdateConfigClient
			resp, err := client.GetByName(ctx, *id, softwareupdateconfiguration.DefaultGetByNameOperationOptions())
			if err != nil {
				if response.WasNotFound(resp.HttpResponse) {
					return meta.MarkAsGone(id)
				}
				return err
			}

			state := SoftwareUpdateConfigurationModel{
				AutomationAccountID: softwareupdateconfiguration.NewAutomationAccountID(id.SubscriptionId, id.ResourceGroupName, id.AutomationAccountName).ID(),
				Name:                id.SoftwareUpdateConfigurationName,
			}

			if model := resp.Model; model != nil {
				props := resp.Model.Properties
				updateConfiguration := props.UpdateConfiguration
				scheduleConfiguration := props.ScheduleInfo

				state.Duration = pointer.From(updateConfiguration.Duration)
				if linux := updateConfiguration.Linux; linux != nil {
					l := Linux{
						Reboot:           pointer.From(linux.RebootSetting),
						Classifications:  strings.Split(string(pointer.From(linux.IncludedPackageClassifications)), ", "),
						ExcludedPackages: pointer.From(linux.ExcludedPackageNameMasks),
						IncludedPackages: pointer.From(linux.IncludedPackageNameMasks),
					}

					state.Linux = []Linux{l}
					state.OperatingSystem = string(softwareupdateconfiguration.OperatingSystemTypeLinux)
				}
				if windows := updateConfiguration.Windows; windows != nil {
					w := Windows{
						Classifications: strings.Split(strings.ReplaceAll(string(pointer.From(windows.IncludedUpdateClassifications)), " ", ""), ","),
						ExcludedKbs:     pointer.From(windows.ExcludedKbNumbers),
						IncludedKbs:     pointer.From(windows.IncludedKbNumbers),
						RebootSetting:   pointer.From(windows.RebootSetting),
					}

					state.Windows = []Windows{w}
					state.OperatingSystem = string(softwareupdateconfiguration.OperatingSystemTypeWindows)
				}
				if targets := updateConfiguration.Targets; targets != nil {
					t := Target{}
					aq := make([]AzureQuery, 0)
					for _, v := range pointer.From(targets.AzureQueries) {
						tagsList := make([]Tag, 0)
						tagFilter := ""
						if tags := v.TagSettings; tags != nil {
							for k, vals := range pointer.From(tags.Tags) {
								tagsList = append(tagsList, Tag{
									Tag:    k,
									Values: vals,
								})
							}
							tagFilter = string(pointer.From(tags.FilterOperator))
						}
						aq = append(aq, AzureQuery{
							Scope:     pointer.From(v.Scope),
							Locations: pointer.From(v.Locations),
							Tags:      tagsList,
							TagFilter: tagFilter,
						})
					}

					t.AzureQueries = aq

					naq := make([]NonAzureQuery, 0)
					for _, v := range pointer.From(targets.NonAzureQueries) {
						naq = append(naq, NonAzureQuery{
							FunctionAlias: pointer.From(v.FunctionAlias),
							WorkspaceId:   pointer.From(v.WorkspaceId),
						})
					}

					t.NonAzureQueries = naq
					state.Targets = []Target{t}
				}

				state.VirtualMachines = pointer.From(updateConfiguration.AzureVirtualMachines)
				state.NonAzureComputerNames = pointer.From(updateConfiguration.NonAzureComputerNames)

				schedule := Schedule{
					Description:             pointer.From(scheduleConfiguration.Description),
					StartTime:               pointer.From(scheduleConfiguration.StartTime),
					StartTimeOffsetMinutes:  pointer.From(scheduleConfiguration.StartTimeOffsetMinutes),
					ExpiryTime:              pointer.From(scheduleConfiguration.ExpiryTime),
					ExpiryTimeOffsetMinutes: pointer.From(scheduleConfiguration.ExpiryTimeOffsetMinutes),
					IsEnabled:               pointer.From(scheduleConfiguration.IsEnabled),
					NextRun:                 pointer.From(scheduleConfiguration.NextRun),
					NextRunOffsetMinutes:    pointer.From(scheduleConfiguration.NextRunOffsetMinutes),
					Interval:                pointer.From(scheduleConfiguration.Interval),
					Frequency:               string(pointer.From(scheduleConfiguration.Frequency)),
					CreationTime:            pointer.From(scheduleConfiguration.CreationTime),
					LastModifiedTime:        pointer.From(scheduleConfiguration.LastModifiedTime),
					TimeZone:                pointer.From(scheduleConfiguration.TimeZone),
				}

				// (@jackofallops) - Advanced Schedule info is never returned so we'll pull it in from Config until the tracked issue is resolved
				// Tracking Issue: https://github.com/Azure/azure-rest-api-specs/issues/24436
				if advSchedule := scheduleConfiguration.AdvancedSchedule; advSchedule != nil {
					schedule.AdvancedWeekDays = pointer.From(advSchedule.WeekDays)
					schedule.AdvancedMonthDays = pointer.From(advSchedule.MonthDays)
					if monthlyOccurrence := pointer.From(advSchedule.MonthlyOccurrences); len(monthlyOccurrence) > 0 {
						mo := make([]MonthlyOccurrence, 0)
						for _, v := range monthlyOccurrence {
							mo = append(mo, MonthlyOccurrence{
								Occurrence: pointer.From(v.Occurrence),
								Day:        string(pointer.From(v.Day)),
							})
						}
						schedule.MonthlyOccurrence = mo
					}
				} else {
					if weekDays, ok := meta.ResourceData.GetOk("schedule.0.advanced_week_days"); ok {
						wd := make([]string, 0)
						for _, v := range weekDays.([]interface{}) {
							wd = append(wd, v.(string))
						}
						schedule.AdvancedWeekDays = wd
					}
					if monthDays, ok := meta.ResourceData.GetOk("schedule.0.advanced_month_days"); ok {
						md := make([]int64, 0)
						for _, v := range monthDays.([]interface{}) {
							md = append(md, int64(v.(int)))
						}
						schedule.AdvancedMonthDays = md
					}
					if monthlyOccurrence, ok := meta.ResourceData.GetOk("schedule.0.monthly_occurrence"); ok {
						mos := make([]MonthlyOccurrence, 0)
						if moRaw, ok := monthlyOccurrence.([]interface{}); ok {
							for _, v := range moRaw {
								mo := v.(map[string]interface{})
								mos = append(mos, MonthlyOccurrence{
									Occurrence: int64(mo["occurrence"].(int)),
									Day:        mo["day"].(string),
								})
							}
						}
						schedule.MonthlyOccurrence = mos
					}
				}

				state.Schedule = []Schedule{schedule}

				if tasks := props.Tasks; tasks != nil {
					if pre := tasks.PreTask; pre != nil {
						state.PreTask = []UpdateTask{{
							Source:     pointer.From(pre.Source),
							Parameters: pointer.From(pre.Parameters),
						}}
					}
					if post := tasks.PostTask; post != nil {
						state.PostTask = []UpdateTask{{
							Source:     pointer.From(post.Source),
							Parameters: pointer.From(post.Parameters),
						}}
					}
				}

				if errorMessage := props.Error; errorMessage != nil {
					state.ErrorMessage = pointer.From(errorMessage.Message)
				}
			}

			return meta.Encode(&state)
		},
	}
}
