package github.com/hashicorp/terraform-provider-azurerm/internal/services/automation
import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/automation/2019-06-01/softwareupdateconfiguration"
	"github.com/hashicorp/go-azure-sdk/resource-manager/automation/2023-11-01/automationaccount"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	validate4 "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	validate2 "github.com/hashicorp/terraform-provider-azurerm/internal/services/resource/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/suppress"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func expandUpdateConfig(input SoftwareUpdateConfigurationModel) *softwareupdateconfiguration.SoftwareUpdateConfiguration {
	result := &softwareupdateconfiguration.SoftwareUpdateConfiguration{
		Properties: softwareupdateconfiguration.SoftwareUpdateConfigurationProperties{
			ScheduleInfo: softwareupdateconfiguration.SUCScheduleProperties{},
		},
	}

	if len(input.Schedule) == 1 {
		v := input.Schedule[0]
		scheduleConfig := softwareupdateconfiguration.SUCScheduleProperties{
			Description:             pointer.To(v.Description),
			ExpiryTime:              pointer.To(v.ExpiryTime),
			ExpiryTimeOffsetMinutes: pointer.To(v.ExpiryTimeOffsetMinutes),
			Frequency:               pointer.To(softwareupdateconfiguration.ScheduleFrequency(v.Frequency)),
			Interval:                pointer.To(v.Interval),
			IsEnabled:               pointer.To(v.IsEnabled),
			NextRun:                 pointer.To(v.NextRun),
			NextRunOffsetMinutes:    pointer.To(v.NextRunOffsetMinutes),
			StartTime:               pointer.To(v.StartTime),
			StartTimeOffsetMinutes:  pointer.To(v.StartTimeOffsetMinutes),
			TimeZone:                pointer.To(v.TimeZone),
		}

		if len(v.AdvancedWeekDays) > 0 || len(v.AdvancedMonthDays) > 0 || len(v.MonthlyOccurrence) > 0 {
			advSchedule := &softwareupdateconfiguration.AdvancedSchedule{}
			if len(v.AdvancedWeekDays) > 0 {
				advSchedule.WeekDays = pointer.To(v.AdvancedWeekDays)
			}

			if len(v.AdvancedMonthDays) > 0 {
				advSchedule.MonthDays = pointer.To(v.AdvancedMonthDays)
			}

			if len(v.MonthlyOccurrence) > 0 {
				monthlyOccurrences := make([]softwareupdateconfiguration.AdvancedScheduleMonthlyOccurrence, 0)
				for _, mo := range v.MonthlyOccurrence {
					monthlyOccurrences = append(monthlyOccurrences, softwareupdateconfiguration.AdvancedScheduleMonthlyOccurrence{
						Day:        pointer.To(softwareupdateconfiguration.ScheduleDay(mo.Day)),
						Occurrence: pointer.To(mo.Occurrence),
					})
				}

				advSchedule.MonthlyOccurrences = pointer.To(monthlyOccurrences)
			}

			scheduleConfig.AdvancedSchedule = advSchedule
		}

		result.Properties.ScheduleInfo = scheduleConfig
	}

	if len(input.PreTask) > 0 || len(input.PostTask) > 0 {
		tasksConfig := &softwareupdateconfiguration.SoftwareUpdateConfigurationTasks{}

		if len(input.PreTask) > 0 {
			v := input.PreTask[0]
			task := &softwareupdateconfiguration.TaskProperties{
				Parameters: pointer.To(v.Parameters),
				Source:     pointer.To(v.Source),
			}

			tasksConfig.PreTask = task
		}

		if len(input.PostTask) > 0 {
			v := input.PostTask[0]
			task := &softwareupdateconfiguration.TaskProperties{
				Parameters: pointer.To(v.Parameters),
				Source:     pointer.To(v.Source),
			}

			tasksConfig.PostTask = task
		}

		result.Properties.Tasks = tasksConfig
	}

	updateConfig := softwareupdateconfiguration.UpdateConfiguration{}

	if len(input.VirtualMachines) > 0 {
		updateConfig.AzureVirtualMachines = pointer.To(input.VirtualMachines)
	}
	if input.Duration != "" {
		updateConfig.Duration = pointer.To(input.Duration)
	}

	if len(input.NonAzureComputerNames) > 0 {
		updateConfig.NonAzureComputerNames = pointer.To(input.NonAzureComputerNames)
	}

	if len(input.Targets) == 1 {
		t := input.Targets[0]
		target := softwareupdateconfiguration.TargetProperties{}
		if len(t.AzureQueries) > 0 {
			aq := make([]softwareupdateconfiguration.AzureQueryProperties, 0)
			for _, v := range t.AzureQueries {
				q := softwareupdateconfiguration.AzureQueryProperties{}
				if len(v.Locations) > 0 {
					q.Locations = pointer.To(v.Locations)
				}
				if len(v.Scope) > 0 {
					q.Scope = pointer.To(v.Scope)
				}
				if len(v.Tags) > 0 || v.TagFilter != "" {
					q.TagSettings = &softwareupdateconfiguration.TagSettingsProperties{
						FilterOperator: pointer.To(softwareupdateconfiguration.TagOperators(v.TagFilter)),
					}
					tags := make(map[string][]string)
					for _, tag := range v.Tags {
						tags[tag.Tag] = tag.Values
					}
					q.TagSettings.Tags = pointer.To(tags)
				}

				aq = append(aq, q)
			}

			target.AzureQueries = pointer.To(aq)
		}

		if len(t.NonAzureQueries) > 0 {
			naqs := make([]softwareupdateconfiguration.NonAzureQueryProperties, 0)
			for _, v := range t.NonAzureQueries {
				naq := softwareupdateconfiguration.NonAzureQueryProperties{}
				if v.FunctionAlias != "" {
					naq.FunctionAlias = pointer.To(v.FunctionAlias)
				}
				if v.WorkspaceId != "" {
					naq.WorkspaceId = pointer.To(v.WorkspaceId)
				}
				naqs = append(naqs, naq)
			}

			target.NonAzureQueries = pointer.To(naqs)
		}
		updateConfig.Targets = pointer.To(target)
	}

	if len(input.Linux) == 1 {
		v := input.Linux[0]
		updateConfig.OperatingSystem = softwareupdateconfiguration.OperatingSystemTypeLinux
		updateConfig.Linux = &softwareupdateconfiguration.LinuxProperties{
			ExcludedPackageNameMasks: pointer.To(v.ExcludedPackages),
			IncludedPackageNameMasks: pointer.To(v.IncludedPackages),
		}
		if v.Reboot != "" {
			updateConfig.Linux.RebootSetting = pointer.To(v.Reboot)
		}
		if len(v.Classifications) > 0 {
			updateConfig.Linux.IncludedPackageClassifications = pointer.To(softwareupdateconfiguration.LinuxUpdateClasses(strings.Join(v.Classifications, ",")))
		}
	}

	if len(input.Windows) == 1 {
		v := input.Windows[0]
		updateConfig.OperatingSystem = softwareupdateconfiguration.OperatingSystemTypeWindows
		w := &softwareupdateconfiguration.WindowsProperties{}
		if v.RebootSetting != "" {
			w.RebootSetting = pointer.To(v.RebootSetting)
		}

		if len(v.ExcludedKbs) > 0 {
			w.ExcludedKbNumbers = pointer.To(v.ExcludedKbs)
		}

		if len(v.IncludedKbs) > 0 {
			w.IncludedKbNumbers = pointer.To(v.IncludedKbs)
		}

		if len(v.Classifications) > 0 {
			w.IncludedUpdateClassifications = pointer.To(softwareupdateconfiguration.WindowsUpdateClasses(strings.Join(v.Classifications, ",")))
		}

		updateConfig.Windows = w
	}

	result.Properties.UpdateConfiguration = updateConfig

	return result
}
