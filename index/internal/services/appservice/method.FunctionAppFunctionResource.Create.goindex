package github.com/hashicorp/terraform-provider-azurerm/internal/services/appservice
import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/web/2023-12-01/webapps"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/appservice/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (r FunctionAppFunctionResource) Create() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 30 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.AppService.WebAppsClient

			appFunction := FunctionAppFunctionModel{}
			if err := metadata.Decode(&appFunction); err != nil {
				return err
			}

			appId, err := commonids.ParseFunctionAppID(appFunction.AppID)
			if err != nil {
				return err
			}

			id := webapps.NewFunctionID(appId.SubscriptionId, appId.ResourceGroupName, appId.SiteName, appFunction.Name)

			existing, err := client.GetFunction(ctx, id)
			if err != nil && !response.WasNotFound(existing.HttpResponse) {
				if !response.WasBadRequest(existing.HttpResponse) {
					return fmt.Errorf("checking for presence of %s: %+v", id, err)
				}
			}
			if !response.WasNotFound(existing.HttpResponse) && !response.WasBadRequest(existing.HttpResponse) {
				return metadata.ResourceRequiresImport(r.ResourceType(), id)
			}

			var confJSON interface{}
			err = json.Unmarshal([]byte(appFunction.ConfigJSON), &confJSON)
			if err != nil {
				return fmt.Errorf("error preparing config data to send: %+v", err)
			}

			fnEnvelope := webapps.FunctionEnvelope{
				Properties: &webapps.FunctionEnvelopeProperties{
					Config:     pointer.To(confJSON),
					TestData:   pointer.To(appFunction.TestData),
					Language:   pointer.To(appFunction.Language),
					IsDisabled: pointer.To(!appFunction.Enabled),
					Files:      expandFunctionFiles(appFunction.Files),
				},
			}

			// Check and wait for the Function to have no in flight operations
			deadline, ok := ctx.Deadline()
			if !ok {
				return fmt.Errorf("internal-error: context had no deadline")
			}

			createWait := &pluginsdk.StateChangeConf{
				Pending: []string{"busy", "unknown"},
				Target:  []string{"ready"},
				Refresh: func() (result interface{}, state string, err error) {
					function, err := client.Get(ctx, *appId)
					if err != nil || function.Model == nil || function.Model.Properties == nil {
						return "unknown", "unknown", err
					}
					if function.Model.Properties.InProgressOperationId != nil {
						return "busy", "busy", nil
					}
					return "ready", "ready", nil
				},
				MinTimeout:                30 * time.Second,
				ContinuousTargetOccurence: 2,
				Timeout:                   time.Until(deadline),
			}

			if _, err = createWait.WaitForStateContext(ctx); err != nil {
				return fmt.Errorf("waiting for %s to be ready", *appId)
			}

			locks.ByID(appId.ID())
			defer locks.UnlockByID(appId.ID())

			if err := client.CreateFunctionThenPoll(ctx, id, fnEnvelope); err != nil {
				return fmt.Errorf("creating %s: %+v", id, err)
			}

			metadata.SetID(id)
			return nil
		},
	}
}
