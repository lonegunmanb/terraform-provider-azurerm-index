package github.com/hashicorp/terraform-provider-azurerm/internal/services/springcloud
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/springcloud/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/springcloud/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/springcloud/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tags"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
	"github.com/jackofallops/kermit/sdk/appplatform/2023-05-01-preview/appplatform"
)
func resourceSpringCloudServiceCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).AppPlatform.ServicesClient
	configServersClient := meta.(*clients.Client).AppPlatform.ConfigServersClient
	monitoringSettingsClient := meta.(*clients.Client).AppPlatform.MonitoringSettingsClient
	serviceRegistryClient := meta.(*clients.Client).AppPlatform.ServiceRegistryClient
	agentPoolClient := meta.(*clients.Client).AppPlatform.BuildServiceAgentPoolClient
	buildServiceClient := meta.(*clients.Client).AppPlatform.BuildServiceClient
	containerRegistryClient := meta.(*clients.Client).AppPlatform.ContainerRegistryClient
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	name := d.Get("name").(string)
	resourceGroup := d.Get("resource_group_name").(string)

	id := parse.NewSpringCloudServiceID(subscriptionId, resourceGroup, name)
	existing, err := client.Get(ctx, id.ResourceGroup, id.SpringName)
	if err != nil {
		if !utils.ResponseWasNotFound(existing.Response) {
			return fmt.Errorf("checking for presence of existing %s: %+v", id, err)
		}
	}
	if !utils.ResponseWasNotFound(existing.Response) {
		return tf.ImportAsExistsError("azurerm_spring_cloud_service", id.ID())
	}

	location := azure.NormalizeLocation(d.Get("location").(string))
	resource := appplatform.ServiceResource{
		Location: utils.String(location),
		Properties: &appplatform.ClusterResourceProperties{
			NetworkProfile:      expandSpringCloudNetwork(d.Get("network").([]interface{})),
			ZoneRedundant:       utils.Bool(d.Get("zone_redundant").(bool)),
			MarketplaceResource: expandSpringCloudMarketplaceResource(d.Get("marketplace").([]interface{})),
		},
		Sku: &appplatform.Sku{
			Name: utils.String(d.Get("sku_name").(string)),
		},
		Tags: tags.Expand(d.Get("tags").(map[string]interface{})),
	}

	if enabled := d.Get("log_stream_public_endpoint_enabled").(bool); enabled {
		resource.Properties.VnetAddons = &appplatform.ServiceVNetAddons{
			LogStreamPublicEndpoint: utils.Bool(enabled),
		}
	}

	// we set sku_tier only when managed_environment_id is set
	// otherwise we break the existing flows where sku_name is set to E0/Basic etc.,
	if v, ok := d.GetOk("managed_environment_id"); ok {
		resource.Properties.ManagedEnvironmentID = utils.String(v.(string))
		resource.Sku.Tier = utils.String(d.Get("sku_tier").(string))
	}

	gitProperty, err := expandSpringCloudConfigServerGitProperty(d.Get("config_server_git_setting").([]interface{}))
	if err != nil {
		return err
	}

	// current create api doesn't take care parameters of config server.
	// so we need to invoke create api first and then update api
	future, err := client.CreateOrUpdate(ctx, id.ResourceGroup, id.SpringName, resource)
	if err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}
	if err = future.WaitForCompletionRef(ctx, client.Client); err != nil {
		return fmt.Errorf("waiting for creation of %s: %+v", id, err)
	}
	d.SetId(id.ID())

	skuName := d.Get("sku_name").(string)
	if skuName == "E0" && gitProperty != nil {
		return fmt.Errorf("`config_server_git_setting` is not supported for sku `E0`")
	}

	if skuName != "E0" {
		log.Printf("[DEBUG] Updating Config Server Settings for %s..", id)
		if err := updateConfigServerSettings(ctx, configServersClient, id, gitProperty); err != nil {
			return err
		}
		log.Printf("[DEBUG] Updated Config Server Settings for %s.", id)
	}

	log.Printf("[DEBUG] Updating Monitor Settings for %s..", id)
	monitorSettings := appplatform.MonitoringSettingResource{
		Properties: expandSpringCloudTrace(d.Get("trace").([]interface{})),
	}
	updateFuture, err := monitoringSettingsClient.UpdatePut(ctx, id.ResourceGroup, id.SpringName, monitorSettings)
	if err != nil {
		return fmt.Errorf("updating monitor settings for %s: %+v", id, err)
	}
	if err = updateFuture.WaitForCompletionRef(ctx, client.Client); err != nil {
		return fmt.Errorf("waiting for update of monitor settings for %s: %+v", id, err)
	}
	log.Printf("[DEBUG] Updated Monitor Settings for %s.", id)

	if d.Get("service_registry_enabled").(bool) {
		future, err := serviceRegistryClient.CreateOrUpdate(ctx, id.ResourceGroup, id.SpringName, "default")
		if err != nil {
			return fmt.Errorf("creating service registry %s: %+v", id, err)
		}

		if err := future.WaitForCompletionRef(ctx, client.Client); err != nil {
			return fmt.Errorf("waiting for creation service registry of %s: %+v", id, err)
		}
	}

	if skuName == "E0" {
		new := expandSpringCloudContainerRegistries(d.Get("container_registry").([]interface{}))
		if err = applyContainerRegistries(ctx, containerRegistryClient, id, nil, new); err != nil {
			return fmt.Errorf("applying container registries for %s: %+v", id, err)
		}
		buildResource := appplatform.BuildService{
			Properties: pointer.To(expandSpringCloudBuildService(d.Get("default_build_service").([]interface{}), id)),
		}
		buildServiceCreateFuture, err := buildServiceClient.CreateOrUpdate(ctx, id.ResourceGroup, id.SpringName, "default", buildResource)
		if err != nil {
			return fmt.Errorf("creating build service %s: %+v", id, err)
		}
		if err := buildServiceCreateFuture.WaitForCompletionRef(ctx, client.Client); err != nil {
			return fmt.Errorf("waiting for creation build service of %s: %+v", id, err)
		}
	}

	if size := d.Get("build_agent_pool_size").(string); len(size) > 0 {
		agentPoolResource := appplatform.BuildServiceAgentPoolResource{
			Properties: &appplatform.BuildServiceAgentPoolProperties{
				PoolSize: &appplatform.BuildServiceAgentPoolSizeProperties{
					Name: utils.String(size),
				},
			},
		}
		future, err := agentPoolClient.UpdatePut(ctx, id.ResourceGroup, id.SpringName, "default", "default", agentPoolResource)
		if err != nil {
			return fmt.Errorf("creating default build agent of %s: %+v", id, err)
		}

		if err := future.WaitForCompletionRef(ctx, client.Client); err != nil {
			return fmt.Errorf("waiting for creation default build agent of %s: %+v", id, err)
		}
	}

	return resourceSpringCloudServiceRead(d, meta)
}
