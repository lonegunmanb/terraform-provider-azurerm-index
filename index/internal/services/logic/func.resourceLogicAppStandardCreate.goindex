package github.com/hashicorp/terraform-provider-azurerm/internal/services/logic
import (
	"fmt"
	"log"
	"math"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/web/2023-01-01/resourceproviders"
	"github.com/hashicorp/go-azure-sdk/resource-manager/web/2023-12-01/webapps"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/appservice/helpers"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/logic/validate"
	storageValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/storage/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceLogicAppStandardCreate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).AppService.WebAppsClient
	subscriptionId := meta.(*clients.Client).Account.SubscriptionId
	ctx, cancel := timeouts.ForCreate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	resourcesClient := meta.(*clients.Client).AppService.ResourceProvidersClient

	env := meta.(*clients.Client).Account.Environment
	storageAccountDomainSuffix, ok := env.Storage.DomainSuffix()
	if !ok {
		return fmt.Errorf("could not determine the domain suffix for storage accounts in environment %q: %+v", env.Name, env.Storage)
	}

	log.Printf("[INFO] preparing arguments for AzureRM Logic App Standard creation.")

	id := commonids.NewAppServiceID(subscriptionId, d.Get("resource_group_name").(string), d.Get("name").(string))
	existing, err := client.Get(ctx, id)
	if err != nil {
		if !response.WasNotFound(existing.HttpResponse) {
			return fmt.Errorf("checking for presence of existing %s: %+v", id, err)
		}
	}

	if !response.WasNotFound(existing.HttpResponse) {
		return tf.ImportAsExistsError("azurerm_logic_app_standard", id.ID())
	}

	availabilityRequest := resourceproviders.ResourceNameAvailabilityRequest{
		Name: id.SiteName,
		Type: resourceproviders.CheckNameResourceTypesMicrosoftPointWebSites,
	}

	available, err := resourcesClient.CheckNameAvailability(ctx, commonids.NewSubscriptionID(subscriptionId), availabilityRequest)
	if err != nil {
		return fmt.Errorf("checking if name %q was available: %+v", id.SiteName, err)
	}

	if available.Model == nil || available.Model.NameAvailable == nil {
		return fmt.Errorf("checking if name %q was available: `model` was nil", id.SiteName)
	}

	if !*available.Model.NameAvailable {
		return fmt.Errorf("the name %q used for the Logic App Standard needs to be globally unique and isn't available: %+v", id.SiteName, pointer.From(available.Model.Message))
	}

	clientCertMode := d.Get("client_certificate_mode").(string)
	clientCertEnabled := clientCertMode != ""

	basicAppSettings, err := getBasicLogicAppSettings(d, *storageAccountDomainSuffix)
	if err != nil {
		return err
	}

	siteConfig, err := expandLogicAppStandardSiteConfig(d)
	if err != nil {
		return fmt.Errorf("expanding `site_config`: %+v", err)
	}

	kind := "functionapp,workflowapp"
	if siteConfig.LinuxFxVersion != nil && len(*siteConfig.LinuxFxVersion) > 0 {
		kind = "functionapp,linux,container,workflowapp"
	}

	// Some appSettings declared by user are required at creation time so we will combine both settings
	appSettings := expandAppSettings(d)
	appSettings = append(appSettings, basicAppSettings...)

	siteConfig.AppSettings = &appSettings

	siteEnvelope := webapps.Site{
		Kind:     &kind,
		Location: location.Normalize(d.Get("location").(string)),
		Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
		Properties: &webapps.SiteProperties{
			ServerFarmId:            pointer.To(d.Get("app_service_plan_id").(string)),
			Enabled:                 pointer.To(d.Get("enabled").(bool)),
			ClientAffinityEnabled:   pointer.To(d.Get("client_affinity_enabled").(bool)),
			ClientCertEnabled:       pointer.To(clientCertEnabled),
			HTTPSOnly:               pointer.To(d.Get("https_only").(bool)),
			SiteConfig:              &siteConfig,
			VnetContentShareEnabled: pointer.To(d.Get("vnet_content_share_enabled").(bool)),
		},
	}

	publicNetworkAccess := d.Get("public_network_access").(string)
	if !features.FivePointOh() {
		// if a user is still using `site_config.public_network_access_enabled` we should be setting `public_network_access` for them
		publicNetworkAccess = reconcilePNA(d)
		if v := siteEnvelope.Properties.SiteConfig.PublicNetworkAccess; v != nil && *v == helpers.PublicNetworkAccessDisabled {
			publicNetworkAccess = helpers.PublicNetworkAccessDisabled
		}
	}

	// conversely if `public_network_access` has been set it should take precedence, and we should be propagating the value for that to `site_config.public_network_access_enabled`
	if publicNetworkAccess == helpers.PublicNetworkAccessDisabled {
		siteEnvelope.Properties.SiteConfig.PublicNetworkAccess = pointer.To(helpers.PublicNetworkAccessDisabled)
	} else if publicNetworkAccess == helpers.PublicNetworkAccessEnabled {
		siteEnvelope.Properties.SiteConfig.PublicNetworkAccess = pointer.To(helpers.PublicNetworkAccessEnabled)
	}

	siteEnvelope.Properties.PublicNetworkAccess = pointer.To(publicNetworkAccess)

	if clientCertEnabled {
		siteEnvelope.Properties.ClientCertMode = pointer.To(webapps.ClientCertMode(clientCertMode))
	}

	if v := d.Get("virtual_network_subnet_id").(string); v != "" {
		siteEnvelope.Properties.VirtualNetworkSubnetId = pointer.To(v)
	}

	if _, ok := d.GetOk("identity"); ok {
		expandedIdentity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
		if err != nil {
			return fmt.Errorf("expanding `identity`: %+v", err)
		}
		siteEnvelope.Identity = expandedIdentity
	}

	if err := client.CreateOrUpdateThenPoll(ctx, id, siteEnvelope); err != nil {
		return fmt.Errorf("creating %s: %+v", id, err)
	}

	d.SetId(id.ID())

	// This setting is enabled by default on creation of a logic app, we only need to update if config sets this as `false`
	if ftpAuth := d.Get("ftp_publish_basic_authentication_enabled").(bool); !ftpAuth {
		policy := webapps.CsmPublishingCredentialsPoliciesEntity{
			Properties: &webapps.CsmPublishingCredentialsPoliciesEntityProperties{
				Allow: ftpAuth,
			},
		}

		if _, err := client.UpdateFtpAllowed(ctx, id, policy); err != nil {
			return fmt.Errorf("updating FTP publish basic authentication policy for %s: %+v", id, err)
		}
	}

	// This setting is enabled by default on creation of a logic app, we only need to update if config sets this as `false`
	if scmAuth := d.Get("scm_publish_basic_authentication_enabled").(bool); !scmAuth {
		policy := webapps.CsmPublishingCredentialsPoliciesEntity{
			Properties: &webapps.CsmPublishingCredentialsPoliciesEntityProperties{
				Allow: scmAuth,
			},
		}

		if _, err := client.UpdateScmAllowed(ctx, id, policy); err != nil {
			return fmt.Errorf("updating SCM publish basic authentication policy for %s: %+v", id, err)
		}
	}

	return resourceLogicAppStandardUpdate(d, meta)
}
