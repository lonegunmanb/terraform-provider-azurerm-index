package github.com/hashicorp/terraform-provider-azurerm/internal/services/logic
import (
	"fmt"
	"log"
	"math"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/web/2023-01-01/resourceproviders"
	"github.com/hashicorp/go-azure-sdk/resource-manager/web/2023-12-01/webapps"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/appservice/helpers"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/logic/validate"
	storageValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/storage/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceLogicAppStandardUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).AppService.WebAppsClient
	ctx, cancel := timeouts.ForUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	env := meta.(*clients.Client).Account.Environment
	storageAccountDomainSuffix, ok := env.Storage.DomainSuffix()
	if !ok {
		return fmt.Errorf("could not determine the domain suffix for storage accounts in environment %q: %+v", env.Name, env.Storage)
	}

	id, err := commonids.ParseLogicAppId(d.Id())
	if err != nil {
		return err
	}

	clientCertMode := d.Get("client_certificate_mode").(string)
	clientCertEnabled := clientCertMode != ""

	basicAppSettings, err := getBasicLogicAppSettings(d, *storageAccountDomainSuffix)
	if err != nil {
		return err
	}

	siteConfig, err := expandLogicAppStandardSiteConfig(d)
	if err != nil {
		return fmt.Errorf("expanding `site_config`: %+v", err)
	}

	kind := "functionapp,workflowapp"
	if siteConfig.LinuxFxVersion != nil && len(*siteConfig.LinuxFxVersion) > 0 {
		kind = "functionapp,linux,container,workflowapp"
	}

	siteConfig.AppSettings = &basicAppSettings

	// WEBSITE_VNET_ROUTE_ALL is superseded by a setting in site_config that defaults to false from 2021-02-01
	appSettings, err := expandLogicAppStandardSettings(d, *storageAccountDomainSuffix)
	if err != nil {
		return fmt.Errorf("expanding `app_settings`: %+v", err)
	}
	if vnetRouteAll, ok := appSettings["WEBSITE_VNET_ROUTE_ALL"]; ok {
		if !d.HasChange("site_config.0.vnet_route_all_enabled") {
			vnetRouteAllEnabled, _ := strconv.ParseBool(vnetRouteAll)
			siteConfig.VnetRouteAllEnabled = &vnetRouteAllEnabled
		}
	}

	siteEnvelope := webapps.Site{
		Kind:     &kind,
		Location: location.Normalize(d.Get("location").(string)),
		Tags:     tags.Expand(d.Get("tags").(map[string]interface{})),
		Properties: &webapps.SiteProperties{
			ServerFarmId:          pointer.To(d.Get("app_service_plan_id").(string)),
			Enabled:               pointer.To(d.Get("enabled").(bool)),
			ClientAffinityEnabled: pointer.To(d.Get("client_affinity_enabled").(bool)),
			ClientCertEnabled:     pointer.To(clientCertEnabled),
			HTTPSOnly:             pointer.To(d.Get("https_only").(bool)),
			PublicNetworkAccess:   pointer.To(d.Get("public_network_access").(string)),
			SiteConfig:            &siteConfig,
		},
	}

	if d.HasChange("public_network_access") {
		publicNetworkAccess := d.Get("public_network_access").(string)
		siteEnvelope.Properties.PublicNetworkAccess = pointer.To(publicNetworkAccess)
		if publicNetworkAccess == helpers.PublicNetworkAccessEnabled {
			siteEnvelope.Properties.SiteConfig.PublicNetworkAccess = pointer.To(helpers.PublicNetworkAccessEnabled)
		} else {
			siteEnvelope.Properties.SiteConfig.PublicNetworkAccess = pointer.To(helpers.PublicNetworkAccessDisabled)
		}
	}

	if !features.FivePointOh() { // Until 5.0 the site_config value of this must be reflected back into the top-level property if not set there
		siteConfig.PublicNetworkAccess = pointer.To(reconcilePNA(d))
	}

	if clientCertEnabled {
		siteEnvelope.Properties.ClientCertMode = pointer.To(webapps.ClientCertMode(clientCertMode))
	}

	if d.HasChange("virtual_network_subnet_id") {
		subnetId := d.Get("virtual_network_subnet_id").(string)
		if subnetId == "" {
			if _, err := client.DeleteSwiftVirtualNetwork(ctx, *id); err != nil {
				return fmt.Errorf("removing `virtual_network_subnet_id` association for %s: %+v", *id, err)
			}
			var empty *string
			siteEnvelope.Properties.VirtualNetworkSubnetId = empty
		} else {
			siteEnvelope.Properties.VirtualNetworkSubnetId = pointer.To(subnetId)
		}
	}

	if _, ok := d.GetOk("identity"); ok {
		expandedIdentity, err := identity.ExpandSystemAndUserAssignedMap(d.Get("identity").([]interface{}))
		if err != nil {
			return fmt.Errorf("expanding `identity`: %+v", err)
		}
		siteEnvelope.Identity = expandedIdentity
	}

	if err := client.CreateOrUpdateThenPoll(ctx, *id, siteEnvelope); err != nil {
		return fmt.Errorf("updating %s: %+v", *id, err)
	}

	if d.HasChange("site_config") || (d.HasChange("public_network_access") && !features.FivePointOh()) { // update siteConfig before appSettings in case the appSettings get covered by basicAppSettings
		siteConfigResource := webapps.SiteConfigResource{
			Properties: &siteConfig,
		}

		if _, err := client.CreateOrUpdateConfiguration(ctx, *id, siteConfigResource); err != nil {
			return fmt.Errorf("updating Configuration for %s: %+v", *id, err)
		}
	}

	settings := webapps.StringDictionary{
		Properties: pointer.To(appSettings),
	}

	if _, err = client.UpdateApplicationSettings(ctx, *id, settings); err != nil {
		return fmt.Errorf("updating Application Settings for %s: %+v", *id, err)
	}

	if d.HasChange("connection_string") {
		connectionStrings := expandLogicAppStandardConnectionStrings(d)
		properties := webapps.ConnectionStringDictionary{
			Properties: pointer.To(connectionStrings),
		}

		if _, err := client.UpdateConnectionStrings(ctx, *id, properties); err != nil {
			return fmt.Errorf("updating Connection Strings for %s: %+v", *id, err)
		}
	}

	// HasChange will return `true` when config specifies this argument as `true` during initial creation.
	// To avoid unnecessary updates, check if the resource is new.
	if d.HasChange("ftp_publish_basic_authentication_enabled") && !d.IsNewResource() {
		policy := webapps.CsmPublishingCredentialsPoliciesEntity{
			Properties: &webapps.CsmPublishingCredentialsPoliciesEntityProperties{
				Allow: d.Get("ftp_publish_basic_authentication_enabled").(bool),
			},
		}

		if _, err := client.UpdateFtpAllowed(ctx, *id, policy); err != nil {
			return fmt.Errorf("updating FTP publish basic authentication policy for %s: %+v", id, err)
		}
	}

	// HasChange will return `true` when config specifies this argument as `true` during initial creation.
	// To avoid unnecessary updates, check if the resource is new.
	if d.HasChange("scm_publish_basic_authentication_enabled") && !d.IsNewResource() {
		policy := webapps.CsmPublishingCredentialsPoliciesEntity{
			Properties: &webapps.CsmPublishingCredentialsPoliciesEntityProperties{
				Allow: d.Get("scm_publish_basic_authentication_enabled").(bool),
			},
		}

		if _, err := client.UpdateScmAllowed(ctx, *id, policy); err != nil {
			return fmt.Errorf("updating SCM publish basic authentication policy for %s: %+v", id, err)
		}
	}

	return resourceLogicAppStandardRead(d, meta)
}
