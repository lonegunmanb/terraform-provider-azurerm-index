package github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel
import (
	"context"
	"fmt"
	"regexp"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/resource-manager/operationalinsights/2020-08-01/workspaces"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel/azuresdkhacks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
	securityinsight "github.com/jackofallops/kermit/sdk/securityinsights/2022-10-01-preview/securityinsights"
)
func (r ThreatIntelligenceIndicator) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := azuresdkhacks.ThreatIntelligenceIndicatorClient{
				BaseClient: metadata.Client.Sentinel.ThreatIntelligenceClient.BaseClient,
			}
			id, err := parse.ThreatIntelligenceIndicatorID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}
			workspaceId := workspaces.NewWorkspaceID(id.SubscriptionId, id.ResourceGroup, id.WorkspaceName)
			resp, err := client.Get(ctx, id.ResourceGroup, id.WorkspaceName, id.IndicatorName)
			if err != nil {
				if utils.ResponseWasNotFound(resp.Response) {
					return metadata.MarkAsGone(id)
				}

				return fmt.Errorf("retrieving %s: %+v", *id, err)
			}

			model, ok := resp.Value.AsThreatIntelligenceIndicatorModel()
			if !ok {
				return fmt.Errorf("retrieving %s: type mismatch", id)
			}

			state := IndicatorModel{
				Name:        pointer.From(model.Name),
				CreatedOn:   pointer.From(model.Created),
				WorkspaceId: workspaceId.ID(),
				PatternType: pointer.From(model.PatternType),
				Revoked:     pointer.From(model.Revoked),
			}

			patternValue, err := flattenIndicatorPattern(*model.Pattern)
			if err != nil {
				return err
			}
			state.Pattern = patternValue

			if model.Confidence != nil {
				state.Confidence = int64(*model.Confidence)
			} else {
				state.Confidence = -1
			}

			if model.CreatedByRef != nil {
				state.CreatedByRef = *model.CreatedByRef
			}

			if model.Description != nil {
				state.Description = *model.Description
			}

			if model.DisplayName != nil {
				state.DisplayName = *model.DisplayName
			}

			if len(model.Extensions) > 0 {
				extensionsValue, err := pluginsdk.FlattenJsonToString(model.Extensions)
				if err != nil {
					return err
				}
				state.Extensions = extensionsValue
			}

			state.ExternalRefrence = flattenThreatIntelligenceExternalReferenceModel(model.ExternalReferences)

			state.GranularMarkings = flattenThreatIntelligenceGranularMarkingModelModel(model.GranularMarkings)

			state.KillChainPhases = flattenThreatIntelligenceKillChainPhaseModel(model.KillChainPhases)

			if model.IndicatorTypes != nil && len(*model.IndicatorTypes) > 0 {
				state.IndicatorTypes = *model.IndicatorTypes
			}

			if model.Language != nil {
				state.Language = *model.Language
			}

			if model.PatternVersion != nil {
				state.PatternVersion = *model.PatternVersion
			}

			if model.Source != nil {
				state.Source = *model.Source
			}

			if model.ObjectMarkingRefs != nil && len(*model.ObjectMarkingRefs) > 0 {
				state.ObjectMarking = *model.ObjectMarkingRefs
			}

			if model.Labels != nil && len(*model.Labels) > 0 {
				state.Labels = *model.Labels
			}

			if model.ThreatTypes != nil && len(*model.ThreatTypes) > 0 {
				state.ThreatTypes = *model.ThreatTypes
			}

			if model.ValidFrom != nil && *model.ValidFrom != "" {
				t, err := time.Parse(time.RFC3339, *model.ValidFrom)
				if err != nil {
					return err
				}
				state.ValidFrom = t.Format(time.RFC3339)
			}

			if model.ValidUntil != nil && *model.ValidUntil != "" {
				t, err := time.Parse(time.RFC3339, *model.ValidUntil)
				if err != nil {
					return err
				}
				state.ValidUntil = t.Format(time.RFC3339)
			}

			if model.Defanged != nil {
				state.Defanged = *model.Defanged
			}

			if model.ExternalID != nil {
				state.ExternalId = *model.ExternalID
			}

			if model.ExternalLastUpdatedTimeUtc != nil {
				state.ExternalLastUpdatedTimeUtc = *model.ExternalLastUpdatedTimeUtc
			}

			if model.LastUpdatedTimeUtc != nil {
				state.LastUpdatedTimeUtc = *model.LastUpdatedTimeUtc
			}

			state.ParsedPattern = flattenIndicatorParsedPattern(model.ParsedPattern)

			return metadata.Encode(&state)
		},
	}
}
