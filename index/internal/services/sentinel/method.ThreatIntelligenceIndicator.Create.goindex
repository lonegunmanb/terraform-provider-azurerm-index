package github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel
import (
	"context"
	"fmt"
	"regexp"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/resource-manager/operationalinsights/2020-08-01/workspaces"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel/azuresdkhacks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/sentinel/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
	securityinsight "github.com/jackofallops/kermit/sdk/securityinsights/2022-10-01-preview/securityinsights"
)
func (r ThreatIntelligenceIndicator) Create() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 30 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			var model IndicatorModel
			if err := metadata.Decode(&model); err != nil {
				return fmt.Errorf("decoding: %+v", err)
			}

			client := azuresdkhacks.ThreatIntelligenceIndicatorClient{
				BaseClient: metadata.Client.Sentinel.ThreatIntelligenceClient.BaseClient,
			}
			workspaceId, err := workspaces.ParseWorkspaceID(model.WorkspaceId)
			if err != nil {
				return fmt.Errorf("parsing Workspace id %s: %+v", model.WorkspaceId, err)
			}

			patternValue, err := expandIndicatorPattern(model.PatternType, model.Pattern)
			if err != nil {
				return err
			}

			// it could not get the indicator by name before it has been created, because the name is generated by service side.
			// but we can not create duplicated indicator with same values, so list the values and find the existing one.
			existingIndicators, err := queryIndicatorsList(ctx, client, workspaceId)
			if err != nil {
				return fmt.Errorf("listing indicators: %+v", err)
			}
			for _, indicator := range existingIndicators {
				if indicator.PatternType != nil && *indicator.PatternType == model.PatternType {
					if indicator.Pattern != nil && *indicator.Pattern == patternValue {
						if indicator.ID != nil && *indicator.ID != "" {
							return tf.ImportAsExistsError("azurerm_sentinel_threat_intelligence_indicator", *indicator.ID)
						}
						return fmt.Errorf("checking existing indicator: `id` is nil")
					}
				}
			}

			properties := azuresdkhacks.ThreatIntelligenceIndicatorModel{
				Kind: securityinsight.KindBasicThreatIntelligenceInformationKindIndicator,
				ThreatIntelligenceIndicatorProperties: &azuresdkhacks.ThreatIntelligenceIndicatorProperties{
					PatternType: &model.PatternType,
					Revoked:     &model.Revoked,
				},
			}

			props := properties.ThreatIntelligenceIndicatorProperties

			props.Pattern = &patternValue

			if model.Confidence != -1 {
				props.Confidence = pointer.To(int32(model.Confidence))
			}

			if model.CreatedByRef != "" {
				props.CreatedByRef = &model.CreatedByRef
			}

			if model.Description != "" {
				props.Description = &model.Description
			}

			if model.DisplayName != "" {
				props.DisplayName = &model.DisplayName
			}

			if model.Extensions != "" {
				extensionsValue, err := pluginsdk.ExpandJsonFromString(model.Extensions)
				if err != nil {
					return err
				}
				props.Extensions = extensionsValue
			}

			props.ExternalReferences = expandThreatIntelligenceExternalReferenceModel(model.ExternalRefrence)

			props.GranularMarkings = expandThreatIntelligenceGranularMarkingModelModel(model.GranularMarkings)

			props.KillChainPhases = expandThreatIntelligenceKillChainPhaseModel(model.KillChainPhases)

			if model.Language != "" {
				props.Language = &model.Language
			}

			if model.PatternVersion != "" {
				props.PatternVersion = &model.PatternVersion
			}

			if model.Source != "" {
				props.Source = &model.Source
			}

			if len(model.ObjectMarking) > 0 {
				props.ObjectMarkingRefs = &model.ObjectMarking
			}

			if len(model.Labels) > 0 {
				props.Labels = &model.Labels
			}

			if len(model.ThreatTypes) > 0 {
				props.ThreatTypes = &model.ThreatTypes
			}

			if model.ValidFrom != "" {
				gmtLoc, _ := time.LoadLocation("GMT")
				t, err := time.Parse(time.RFC3339, model.ValidFrom)
				if err != nil {
					return err
				}
				validFromValue := t.In(gmtLoc).Format(time.RFC1123Z)
				props.ValidFrom = &validFromValue
			}

			if model.ValidUntil != "" {
				gmtLoc, _ := time.LoadLocation("GMT")
				t, err := time.Parse(time.RFC3339, model.ValidUntil)
				if err != nil {
					return err
				}
				validUntilValue := t.In(gmtLoc).Format(time.RFC1123Z)
				props.ValidUntil = &validUntilValue
			}

			resp, err := client.CreateIndicator(ctx, workspaceId.ResourceGroupName, workspaceId.WorkspaceName, properties)
			if err != nil {
				return fmt.Errorf("creating threaten intelligence indicator in workspace %s: %+v", workspaceId, err)
			}

			info, ok := resp.Value.AsThreatIntelligenceIndicatorModel()
			if !ok {
				return fmt.Errorf("creating threaten intelligence indicator in workspace %s: `model` type mismatch", workspaceId)
			}

			id, err := parse.ThreatIntelligenceIndicatorID(*info.ID)
			if err != nil {
				return fmt.Errorf("parsing threat intelligence indicator id %s: %+v", *info.ID, err)
			}

			metadata.SetID(id)
			return nil
		},
	}
}
