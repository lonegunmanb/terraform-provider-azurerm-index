package github.com/hashicorp/terraform-provider-azurerm/internal/services/nginx
import (
	"context"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-sdk/resource-manager/nginx/2024-11-01-preview/nginxdeployment"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (m DeploymentResource) Create() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 30 * time.Minute,
		Func: func(ctx context.Context, meta sdk.ResourceMetaData) error {
			client := meta.Client.Nginx.NginxDeployment

			var model DeploymentModel
			if err := meta.Decode(&model); err != nil {
				return err
			}

			subscriptionID := meta.Client.Account.SubscriptionId
			id := nginxdeployment.NewNginxDeploymentID(subscriptionID, model.ResourceGroupName, model.Name)
			existing, err := client.DeploymentsGet(ctx, id)

			if !response.WasNotFound(existing.HttpResponse) {
				if err != nil {
					return fmt.Errorf("retrieving %s: %v", id, err)
				}
				return meta.ResourceRequiresImport(m.ResourceType(), id)
			}

			req := nginxdeployment.NginxDeployment{}
			req.Name = pointer.To(model.Name)
			req.Location = pointer.To(model.Location)
			req.Tags = pointer.FromMapOfStringStrings(model.Tags)

			if model.Sku != "" {
				sku := nginxdeployment.ResourceSku{Name: model.Sku}
				req.Sku = &sku
			}

			prop := &nginxdeployment.NginxDeploymentProperties{}

			if !features.FivePointOh() {
				if len(model.LoggingStorageAccount) > 0 {
					prop.Logging = &nginxdeployment.NginxLogging{
						StorageAccount: &nginxdeployment.NginxStorageAccount{
							AccountName:   pointer.FromString(model.LoggingStorageAccount[0].Name),
							ContainerName: pointer.FromString(model.LoggingStorageAccount[0].ContainerName),
						},
					}
				}
			}

			prop.EnableDiagnosticsSupport = pointer.FromBool(model.DiagnoseSupportEnabled)
			prop.NetworkProfile = expandNetworkProfile(model.FrontendPublic, model.FrontendPrivate, model.NetworkInterface)

			isBasicSKU := strings.HasPrefix(model.Sku, "basic")
			hasScaling := (model.Capacity > 0 || len(model.AutoScaleProfile) > 0)
			if isBasicSKU && hasScaling {
				return fmt.Errorf("basic SKUs are incompatible with `capacity` or `auto_scale_profiles`")
			}
			if !isBasicSKU && !hasScaling {
				return fmt.Errorf("scaling is required for `sku` '%s', please provide `capacity` or `auto_scale_profiles`", model.Sku)
			}

			if model.Capacity > 0 {
				prop.ScalingProperties = &nginxdeployment.NginxDeploymentScalingProperties{
					Capacity: pointer.FromInt64(model.Capacity),
				}
			}

			if autoScaleProfile := model.AutoScaleProfile; len(autoScaleProfile) > 0 {
				var autoScaleProfiles []nginxdeployment.ScaleProfile
				for _, profile := range autoScaleProfile {
					autoScaleProfiles = append(autoScaleProfiles, nginxdeployment.ScaleProfile{
						Name: profile.Name,
						Capacity: nginxdeployment.ScaleProfileCapacity{
							Min: profile.Min,
							Max: profile.Max,
						},
					})
				}
				prop.ScalingProperties = &nginxdeployment.NginxDeploymentScalingProperties{
					AutoScaleSettings: &nginxdeployment.NginxDeploymentScalingPropertiesAutoScaleSettings{
						Profiles: autoScaleProfiles,
					},
				}
			}

			if model.Email != "" {
				prop.UserProfile = &nginxdeployment.NginxDeploymentUserProfile{
					PreferredEmail: pointer.To(model.Email),
				}
			}

			if model.UpgradeChannel != "" {
				prop.AutoUpgradeProfile = &nginxdeployment.AutoUpgradeProfile{
					UpgradeChannel: model.UpgradeChannel,
				}
			}

			req.Properties = prop

			req.Identity, err = identity.ExpandSystemAndUserAssignedMapFromModel(model.Identity)
			if err != nil {
				return fmt.Errorf("expanding identities: %+v", err)
			}

			err = client.DeploymentsCreateOrUpdateThenPoll(ctx, id, req)
			if err != nil {
				return fmt.Errorf("creating %s: %v", id, err)
			}

			meta.SetID(id)
			return nil
		},
	}
}
