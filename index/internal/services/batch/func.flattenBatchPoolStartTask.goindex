package github.com/hashicorp/terraform-provider-azurerm/internal/services/batch
import (
	"encoding/json"
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/resource-manager/batch/2024-07-01/pool"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func flattenBatchPoolStartTask(oldConfig *pluginsdk.ResourceData, startTask *pool.StartTask) []interface{} {
	results := make([]interface{}, 0)

	if startTask == nil {
		log.Printf("[DEBUG] startTask is nil")
		return results
	}

	result := make(map[string]interface{})
	commandLine := ""
	if startTask.CommandLine != nil {
		commandLine = *startTask.CommandLine
	}
	result["command_line"] = commandLine

	if startTask.ContainerSettings != nil {
		containerSettings := make(map[string]interface{})
		containerSettings["image_name"] = startTask.ContainerSettings.ImageName
		if startTask.ContainerSettings.WorkingDirectory != nil {
			containerSettings["working_directory"] = string(*startTask.ContainerSettings.WorkingDirectory)
		}
		if startTask.ContainerSettings.ContainerRunOptions != nil {
			containerSettings["run_options"] = *startTask.ContainerSettings.ContainerRunOptions
		}
		if startTask.ContainerSettings.Registry != nil {
			tmpReg := flattenBatchPoolContainerRegistry(oldConfig, startTask.ContainerSettings.Registry)
			containerSettings["registry"] = []interface{}{
				tmpReg,
			}
		}

		result["container"] = []interface{}{
			containerSettings,
		}
	}

	waitForSuccess := false
	if startTask.WaitForSuccess != nil {
		waitForSuccess = *startTask.WaitForSuccess
	}
	result["wait_for_success"] = waitForSuccess

	maxTaskRetryCount := int64(0)
	if startTask.MaxTaskRetryCount != nil {
		maxTaskRetryCount = *startTask.MaxTaskRetryCount
	}

	result["task_retry_maximum"] = maxTaskRetryCount

	if startTask.UserIdentity != nil {
		userIdentity := make(map[string]interface{})
		if startTask.UserIdentity.AutoUser != nil {
			autoUser := make(map[string]interface{})

			if startTask.UserIdentity.AutoUser.ElevationLevel != nil {
				autoUser["elevation_level"] = string(*startTask.UserIdentity.AutoUser.ElevationLevel)
			}

			if startTask.UserIdentity.AutoUser.Scope != nil {
				autoUser["scope"] = string(*startTask.UserIdentity.AutoUser.Scope)
			}
			userIdentity["auto_user"] = []interface{}{autoUser}
		} else {
			userIdentity["user_name"] = *startTask.UserIdentity.UserName
		}

		result["user_identity"] = []interface{}{userIdentity}
	}

	resourceFiles := make([]interface{}, 0)
	if startTask.ResourceFiles != nil {
		for _, armResourceFile := range *startTask.ResourceFiles {
			resourceFile := make(map[string]interface{})
			if armResourceFile.AutoStorageContainerName != nil {
				resourceFile["auto_storage_container_name"] = *armResourceFile.AutoStorageContainerName
			}
			if armResourceFile.StorageContainerURL != nil {
				resourceFile["storage_container_url"] = *armResourceFile.StorageContainerURL
			}
			if armResourceFile.HTTPURL != nil {
				resourceFile["http_url"] = *armResourceFile.HTTPURL
			}
			if armResourceFile.BlobPrefix != nil {
				resourceFile["blob_prefix"] = *armResourceFile.BlobPrefix
			}
			if armResourceFile.FilePath != nil {
				resourceFile["file_path"] = *armResourceFile.FilePath
			}
			if armResourceFile.FileMode != nil {
				resourceFile["file_mode"] = *armResourceFile.FileMode
			}
			if armResourceFile.IdentityReference != nil {
				resourceFile["user_assigned_identity_id"] = *armResourceFile.IdentityReference.ResourceId
			}
			resourceFiles = append(resourceFiles, resourceFile)
		}
	}

	environment := make(map[string]interface{})
	if startTask.EnvironmentSettings != nil {
		for _, envSetting := range *startTask.EnvironmentSettings {
			environment[envSetting.Name] = *envSetting.Value
		}
	}

	result["common_environment_properties"] = environment

	result["resource_file"] = resourceFiles

	return append(results, result)
}
