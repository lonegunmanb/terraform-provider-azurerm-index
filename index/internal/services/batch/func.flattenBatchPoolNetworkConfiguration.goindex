package github.com/hashicorp/terraform-provider-azurerm/internal/services/batch
import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	pool "github.com/hashicorp/go-azure-sdk/resource-manager/batch/2024-07-01/pools"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func flattenBatchPoolNetworkConfiguration(input *pool.NetworkConfiguration) []interface{} {
	if input == nil {
		return []interface{}{}
	}

	subnetId := ""
	if input.SubnetId != nil {
		subnetId = *input.SubnetId
	}

	publicIPAddressIds := make([]interface{}, 0)
	publicAddressProvisioningType := ""
	if config := input.PublicIPAddressConfiguration; config != nil {
		publicIPAddressIds = utils.FlattenStringSlice(config.IPAddressIds)
		if config.Provision != nil {
			publicAddressProvisioningType = string(*config.Provision)
		}
	}

	endpointConfigs := make([]interface{}, 0)
	if config := input.EndpointConfiguration; config != nil && config.InboundNatPools != nil {
		for _, inboundNatPool := range config.InboundNatPools {
			name := inboundNatPool.Name

			backendPort := inboundNatPool.BackendPort

			frontendPortRange := fmt.Sprintf("%d-%d", inboundNatPool.FrontendPortRangeStart, inboundNatPool.FrontendPortRangeEnd)

			networkSecurities := make([]interface{}, 0)
			if sgRules := inboundNatPool.NetworkSecurityGroupRules; sgRules != nil {
				for _, networkSecurity := range *sgRules {
					priority := networkSecurity.Priority

					sourceAddressPrefix := networkSecurity.SourceAddressPrefix

					sourcePortRanges := make([]interface{}, 0)
					if networkSecurity.SourcePortRanges != nil {
						for _, sourcePortRange := range *networkSecurity.SourcePortRanges {
							sourcePortRanges = append(sourcePortRanges, sourcePortRange)
						}
					}
					networkSecurities = append(networkSecurities, map[string]interface{}{
						"access":                string(networkSecurity.Access),
						"priority":              priority,
						"source_address_prefix": sourceAddressPrefix,
						"source_port_ranges":    sourcePortRanges,
					})
				}
			}

			endpointConfigs = append(endpointConfigs, map[string]interface{}{
				"backend_port":                 backendPort,
				"frontend_port_range":          frontendPortRange,
				"name":                         name,
				"network_security_group_rules": networkSecurities,
				"protocol":                     string(inboundNatPool.Protocol),
			})
		}
	}

	dynamicVNetAssignmentScope := ""
	if input.DynamicVnetAssignmentScope != nil {
		dynamicVNetAssignmentScope = string(*input.DynamicVnetAssignmentScope)
	}

	return []interface{}{
		map[string]interface{}{
			"dynamic_vnet_assignment_scope":    dynamicVNetAssignmentScope,
			"accelerated_networking_enabled":   pointer.From(input.EnableAcceleratedNetworking),
			"endpoint_configuration":           endpointConfigs,
			"public_address_provisioning_type": publicAddressProvisioningType,
			"public_ips":                       pluginsdk.NewSet(pluginsdk.HashString, publicIPAddressIds),
			"subnet_id":                        subnetId,
		},
	}
}
