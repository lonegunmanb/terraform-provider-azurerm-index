package github.com/hashicorp/terraform-provider-azurerm/internal/services/batch
import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"strconv"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	pool "github.com/hashicorp/go-azure-sdk/resource-manager/batch/2024-07-01/pools"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func expandBatchPoolVirtualMachineConfig(d *pluginsdk.ResourceData) (*pool.VirtualMachineConfiguration, error) {
	var result pool.VirtualMachineConfiguration

	result.NodeAgentSkuId = d.Get("node_agent_sku_id").(string)

	storageImageReferenceSet := d.Get("storage_image_reference").([]interface{})
	if imageReference, err := ExpandBatchPoolImageReference(storageImageReferenceSet); err == nil {
		if imageReference != nil {
			// if an image reference ID is specified, the user wants use a custom image. This property is mutually exclusive with other properties.
			if imageReference.Id != nil && (imageReference.Offer != nil || imageReference.Publisher != nil || imageReference.Sku != nil || imageReference.Version != nil) {
				return nil, fmt.Errorf("properties version, offer, publish cannot be defined when using a custom image id")
			} else if imageReference.Id == nil && (imageReference.Offer == nil || imageReference.Publisher == nil || imageReference.Sku == nil || imageReference.Version == nil) {
				return nil, fmt.Errorf("properties version, offer, publish and sku are mandatory when not using a custom image")
			}
			result.ImageReference = *imageReference
		}
	} else {
		return nil, fmt.Errorf("storage_image_reference either is empty or contains parsing errors")
	}

	if v, ok := d.GetOk("container_configuration"); ok {
		if containerConfiguration, err := ExpandBatchPoolContainerConfiguration(v.([]interface{})); err == nil {
			result.ContainerConfiguration = containerConfiguration
		} else {
			return nil, fmt.Errorf("container_configuration either is empty or contains parsing errors")
		}
	}

	if v, ok := d.GetOk("data_disks"); ok {
		result.DataDisks = expandBatchPoolDataDisks(v.([]interface{}))
	}

	if diskEncryptionConfig, diskEncryptionErr := expandBatchPoolDiskEncryptionConfiguration(d.Get("disk_encryption").([]interface{})); diskEncryptionErr == nil {
		result.DiskEncryptionConfiguration = diskEncryptionConfig
	} else {
		return nil, diskEncryptionErr
	}

	if extensions, extErr := expandBatchPoolExtensions(d.Get("extensions").([]interface{})); extErr == nil {
		result.Extensions = extensions
	} else {
		return nil, extErr
	}

	if licenseType, ok := d.GetOk("license_type"); ok {
		result.LicenseType = pointer.To(licenseType.(string))
	}

	if v, ok := d.GetOk("node_placement"); ok {
		result.NodePlacementConfiguration = expandBatchPoolNodeReplacementConfig(v.([]interface{}))
	}

	if v, ok := d.GetOk("os_disk_placement"); ok {
		result.OsDisk = expandBatchPoolOSDisk(v)
	}

	if v, ok := d.GetOk("security_profile"); ok {
		result.SecurityProfile = expandBatchPoolSecurityProfile(v.([]interface{}))
	}

	if v, ok := d.GetOk("windows"); ok {
		result.WindowsConfiguration = expandBatchPoolWindowsConfiguration(v.([]interface{}))
	}

	return &result, nil
}
