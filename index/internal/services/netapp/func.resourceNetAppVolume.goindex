package github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/backups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/poolchange"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/snapshots"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumes"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumesreplication"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	netAppValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceNetAppVolume() *pluginsdk.Resource {
	resource := &pluginsdk.Resource{
		Create: resourceNetAppVolumeCreate,
		Read:   resourceNetAppVolumeRead,
		Update: resourceNetAppVolumeUpdate,
		Delete: resourceNetAppVolumeDelete,

		Timeouts: &pluginsdk.ResourceTimeout{
			Create: pluginsdk.DefaultTimeout(60 * time.Minute),
			Read:   pluginsdk.DefaultTimeout(5 * time.Minute),
			Update: pluginsdk.DefaultTimeout(60 * time.Minute),
			Delete: pluginsdk.DefaultTimeout(60 * time.Minute),
		},
		Importer: pluginsdk.ImporterValidatingResourceId(func(id string) error {
			_, err := volumes.ParseVolumeID(id)
			return err
		}),

		Schema: map[string]*pluginsdk.Schema{
			"resource_group_name": commonschema.ResourceGroupName(),

			"name": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: netAppValidate.VolumeName,
			},

			"location": commonschema.Location(),

			"zone": commonschema.ZoneSingleOptionalForceNew(),

			"account_name": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: netAppValidate.AccountName,
			},

			"pool_name": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ValidateFunc: netAppValidate.PoolName,
			},

			"volume_path": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: netAppValidate.VolumePath,
			},

			"service_level": {
				Type:     pluginsdk.TypeString,
				Required: true,
				ValidateFunc: validation.StringInSlice([]string{
					string(volumes.ServiceLevelPremium),
					string(volumes.ServiceLevelStandard),
					string(volumes.ServiceLevelUltra),
					string(volumes.ServiceLevelFlexible),
				}, false),
			},

			"subnet_id": {
				Type:         pluginsdk.TypeString,
				Required:     true,
				ForceNew:     true,
				ValidateFunc: commonids.ValidateSubnetID,
			},

			"create_from_snapshot_resource_id": {
				Type:         pluginsdk.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: snapshots.ValidateSnapshotID,
			},

			"accept_grow_capacity_pool_for_short_term_clone_split": {
				Type:         pluginsdk.TypeString,
				Optional:     true,
				ForceNew:     true,
				ValidateFunc: validation.StringInSlice(volumes.PossibleValuesForAcceptGrowCapacityPoolForShortTermCloneSplit(), false),
				Description:  "While auto splitting the short term clone volume, if the parent pool does not have enough space to accommodate the volume after split, it will be automatically resized, which will lead to increased billing. To accept capacity pool size auto grow and create a short term clone volume, set the property as accepted. Can only be used in conjunction with `create_from_snapshot_resource_id`.",
			},

			"network_features": {
				Type:     pluginsdk.TypeString,
				Optional: true,
				Computed: true, // O+C - This is Optional/Computed because the service team is changing network features on the backend to upgrade everyone from Basic to Standard and there is a feature that allows customers to change network features from portal but not the API. This could cause drift that forces data loss that we want to avoid
				ValidateFunc: validation.StringInSlice([]string{
					string(volumes.NetworkFeaturesBasic),
					string(volumes.NetworkFeaturesStandard),
				}, false),
			},

			"protocols": {
				Type:     pluginsdk.TypeSet,
				Optional: true,
				Computed: true,
				MaxItems: 2,
				Elem: &pluginsdk.Schema{
					Type: pluginsdk.TypeString,
					ValidateFunc: validation.StringInSlice([]string{
						"NFSv3",
						"NFSv4.1",
						"CIFS",
					}, false),
				},
			},

			"kerberos_enabled": {
				// Due to large infrastructure requirements, there is not a reliable way to test Kerberos volumes in a shared environment at this time
				Type:        pluginsdk.TypeBool,
				Optional:    true,
				ForceNew:    true,
				Description: "Enable to allow Kerberos secured volumes. Requires appropriate export rules as well as the parent `azurerm_netapp_account` having a defined AD connection.",
			},

			"smb_continuous_availability_enabled": {
				Type:        pluginsdk.TypeBool,
				Optional:    true,
				Description: "Continuous availability option should be used only for SQL and FSLogix workloads. Using it for any other SMB workloads is not supported.",
				ForceNew:    true,
			},

			"smb3_protocol_encryption_enabled": {
				Type:        pluginsdk.TypeBool,
				Optional:    true,
				Description: "SMB3 encryption option should be used only for SMB/DualProtocol volumes. Using it for any other workloads is not supported.",
				ForceNew:    true,
			},

			"security_style": {
				Type:         pluginsdk.TypeString,
				Optional:     true,
				ForceNew:     true,
				Computed:     true,
				ValidateFunc: validation.StringInSlice(volumes.PossibleValuesForSecurityStyle(), false),
			},

			"storage_quota_in_gb": {
				Type:         pluginsdk.TypeInt,
				Required:     true,
				ValidateFunc: validation.IntBetween(50, 1048576),
			},

			"throughput_in_mibps": {
				Type:         pluginsdk.TypeFloat,
				Optional:     true,
				Computed:     true,
				ValidateFunc: validation.FloatAtLeast(1.0),
			},

			"export_policy_rule": {
				Type:     pluginsdk.TypeList,
				Optional: true,
				MaxItems: 5,
				Elem: &pluginsdk.Resource{
					Schema: map[string]*pluginsdk.Schema{
						"rule_index": {
							Type:         pluginsdk.TypeInt,
							Required:     true,
							ValidateFunc: validation.IntBetween(1, 5),
						},

						"allowed_clients": {
							Type:     pluginsdk.TypeSet,
							Required: true,
							Elem: &pluginsdk.Schema{
								Type:         pluginsdk.TypeString,
								ValidateFunc: validate.CIDR,
							},
						},

						"protocol": {
							Type:     pluginsdk.TypeList,
							Optional: true,
							MaxItems: 1,
							MinItems: 1,
							Elem: &pluginsdk.Schema{
								Type: pluginsdk.TypeString,
								ValidateFunc: validation.StringInSlice([]string{
									"NFSv3",
									"NFSv4.1",
									"CIFS",
								}, false),
							},
						},

						"unix_read_only": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},

						"unix_read_write": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},

						"root_access_enabled": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},

						"kerberos_5_read_only_enabled": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},
						"kerberos_5_read_write_enabled": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},
						"kerberos_5i_read_only_enabled": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},
						"kerberos_5i_read_write_enabled": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},
						"kerberos_5p_read_only_enabled": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},
						"kerberos_5p_read_write_enabled": {
							Type:     pluginsdk.TypeBool,
							Optional: true,
						},
					},
				},
			},

			"tags": commonschema.Tags(),

			"mount_ip_addresses": {
				Type:     pluginsdk.TypeList,
				Computed: true,
				Elem: &pluginsdk.Schema{
					Type: pluginsdk.TypeString,
				},
			},

			"snapshot_directory_visible": {
				Type:     pluginsdk.TypeBool,
				Optional: true,
				Default:  true,
			},

			"data_protection_replication": {
				Type:     pluginsdk.TypeList,
				Optional: true,
				MaxItems: 1,
				ForceNew: true,
				Elem: &pluginsdk.Resource{
					Schema: map[string]*pluginsdk.Schema{
						"endpoint_type": {
							Type:     pluginsdk.TypeString,
							Optional: true,
							Default:  "dst",
							ValidateFunc: validation.StringInSlice([]string{
								"dst",
							}, false),
						},

						"remote_volume_location": commonschema.Location(),

						"remote_volume_resource_id": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: azure.ValidateResourceID,
						},

						"replication_frequency": {
							Type:     pluginsdk.TypeString,
							Required: true,
							ValidateFunc: validation.StringInSlice([]string{
								"10minutes",
								"daily",
								"hourly",
							}, false),
						},
					},
				},
			},

			"data_protection_snapshot_policy": {
				Type:     pluginsdk.TypeList,
				Optional: true,
				MaxItems: 1,
				Elem: &pluginsdk.Resource{
					Schema: map[string]*pluginsdk.Schema{
						"snapshot_policy_id": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: azure.ValidateResourceID,
						},
					},
				},
			},

			"data_protection_backup_policy": {
				Type:     pluginsdk.TypeList,
				Optional: true,
				MaxItems: 1,
				Elem: &pluginsdk.Resource{
					Schema: map[string]*pluginsdk.Schema{
						"backup_policy_id": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: azure.ValidateResourceID,
							Description:  "The ID of the backup policy to associate with this volume.",
						},

						"policy_enabled": {
							Type:        pluginsdk.TypeBool,
							Optional:    true,
							Default:     true,
							Description: "If set to false, the backup policy will not be enabled on this volume, thus disabling scheduled backups.",
						},

						"backup_vault_id": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: azure.ValidateResourceID,
							Description:  "The ID of the backup vault to associate with this volume.",
						},
					},
				},
			},

			"azure_vmware_data_store_enabled": {
				Type:     pluginsdk.TypeBool,
				ForceNew: true,
				Optional: true,
				Default:  false,
			},

			"encryption_key_source": {
				Type:         pluginsdk.TypeString,
				Optional:     true,
				ForceNew:     true,
				Computed:     true,
				ValidateFunc: validation.StringInSlice(volumes.PossibleValuesForEncryptionKeySource(), false),
			},

			"key_vault_private_endpoint_id": {
				Type:         pluginsdk.TypeString,
				Optional:     true,
				ForceNew:     true,
				Computed:     true,
				ValidateFunc: azure.ValidateResourceID,
				RequiredWith: []string{"encryption_key_source"},
			},

			"smb_non_browsable_enabled": {
				Type:        pluginsdk.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Enable non browsable share setting for SMB/Dual Protocol volume. When enabled, it restricts windows clients to browse the share",
			},

			"smb_access_based_enumeration_enabled": {
				Type:        pluginsdk.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Enable access based enumeration setting for SMB/Dual Protocol volume. When enabled, users who do not have permission to access a shared folder or file underneath it, do not see that shared resource displayed in their environment.",
			},

			"large_volume_enabled": {
				Type:        pluginsdk.TypeBool,
				Optional:    true,
				Default:     false,
				Description: "Indicates whether the volume is a large volume.",
			},

			"cool_access": {
				Type:     pluginsdk.TypeList,
				Optional: true,
				MaxItems: 1,
				Elem: &pluginsdk.Resource{
					Schema: map[string]*pluginsdk.Schema{
						"retrieval_policy": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: validation.StringInSlice(volumes.PossibleValuesForCoolAccessRetrievalPolicy(), false),
						},

						"tiering_policy": {
							Type:         pluginsdk.TypeString,
							Required:     true,
							ValidateFunc: validation.StringInSlice(volumes.PossibleValuesForCoolAccessTieringPolicy(), false),
						},

						"coolness_period_in_days": {
							Type:         pluginsdk.TypeInt,
							Required:     true,
							ValidateFunc: validation.IntBetween(2, 183),
						},
					},
				},
			},
		},
		CustomizeDiff: func(ctx context.Context, d *pluginsdk.ResourceDiff, i interface{}) error {
			// Validate large volume and storage_quota_in_gb based on Azure NetApp Files requirements
			isLargeVolume := d.Get("large_volume_enabled").(bool)
			storageQuotaInGB := d.Get("storage_quota_in_gb").(int)

			switch {
			case isLargeVolume && storageQuotaInGB < 51200:
				// Large volumes must be at least 50 TiB (51,200 GB)
				return fmt.Errorf("when `large_volume_enabled` is true, `storage_quota_in_gb` must be at least 51,200 GB (50 TiB)")
			case isLargeVolume && storageQuotaInGB > 1048576:
				// Validate against the maximum (1 PiB / 1,048,576 GB)
				return fmt.Errorf("`storage_quota_in_gb` must not exceed 1,048,576 GB (1 PiB); larger sizes require requesting special quota")
			case !isLargeVolume && storageQuotaInGB > 102400:
				// Non-large volumes cannot be larger than 100 TiB (102,400 GB)
				return fmt.Errorf("when `large_volume_enabled` is false, `storage_quota_in_gb` must not exceed 102,400 GB (100 TiB); set `large_volume_enabled` to true for larger volumes")
			default:
				// All validations passed - no action needed
			}

			// Validate short-term clone properties
			acceptGrowCapacityPool := d.Get("accept_grow_capacity_pool_for_short_term_clone_split").(string)

			// Only validate if accept_grow_capacity_pool_for_short_term_clone_split is set
			if acceptGrowCapacityPool != "" {
				rawConfig := d.GetRawConfig().AsValueMap()
				// Check if create_from_snapshot_resource_id is explicitly null or empty
				// Allow computed values (where value is empty but raw config is not null)
				if rawConfig["create_from_snapshot_resource_id"].IsNull() {
					return fmt.Errorf("`accept_grow_capacity_pool_for_short_term_clone_split` can only be used in conjunction with `create_from_snapshot_resource_id`")
				}
			}

			// Validate that short-term clones are not supported on large volumes
			if acceptGrowCapacityPool != "" && isLargeVolume {
				return fmt.Errorf("short-term clones are not supported on large volumes; `accept_grow_capacity_pool_for_short_term_clone_split` cannot be used when `large_volume_enabled` is true")
			}

			// Validate that short-term clones are not supported with cool access
			coolAccessConfig := d.Get("cool_access").([]interface{})
			if acceptGrowCapacityPool != "" && len(coolAccessConfig) > 0 {
				return fmt.Errorf("short-term clones are not supported on volumes enabled for cool access; `accept_grow_capacity_pool_for_short_term_clone_split` cannot be used when `cool_access` is configured")
			}

			if d.HasChanges("service_level", "pool_name") {
				serviceLevelChange := d.HasChange("service_level")
				poolNameChange := d.HasChange("pool_name")

				// `service_level` and `pool_name` must be updated together or we ForceNew the resource
				// https://learn.microsoft.com/en-us/azure/azure-netapp-files/dynamic-change-volume-service-level
				if serviceLevelChange && !poolNameChange {
					return d.ForceNew("service_level")
				}
				if !serviceLevelChange && poolNameChange {
					return d.ForceNew("pool_name")
				}
			}

			if !features.FivePointOh() {
				// export_policy_rule.protocol conflicts with export_policy_rule.protocols_enabled
				// Can't use the sdk's ConflictsWith because the properties are nested under a
				// TypeList with a MaxItems != 1
				for _, rule := range d.GetRawConfig().AsValueMap()["export_policy_rule"].AsValueSlice() {
					ruleMap := rule.AsValueMap()
					if !ruleMap["protocols_enabled"].IsNull() && !ruleMap["protocol"].IsNull() {
						return fmt.Errorf("conflicting configuration arguments. export_policy_rule.protocol conflicts with export_policy_rule.protocols_enabled")
					}
				}
			}

			// Validate NFSv3 to NFSv4.1 protocol conversion restrictions
			if d.HasChange("protocols") {
				old, new := d.GetChange("protocols")
				oldProtocols := old.(*pluginsdk.Set).List()
				newProtocols := new.(*pluginsdk.Set).List()

				// Convert to string slices for validation
				oldProtocolsStr := make([]string, len(oldProtocols))
				newProtocolsStr := make([]string, len(newProtocols))

				for i, v := range oldProtocols {
					oldProtocolsStr[i] = v.(string)
				}
				for i, v := range newProtocols {
					newProtocolsStr[i] = v.(string)
				}

				kerberosEnabled := d.Get("kerberos_enabled").(bool)
				dataReplication := d.Get("data_protection_replication").([]interface{})

				// Get the new export policy rules configuration to validate against new protocols
				// Always use the new configuration when protocols are changing to ensure validation against intended state
				exportPolicyRules := d.Get("export_policy_rule").([]interface{})

				validationErrors := netAppValidate.ValidateNetAppVolumeProtocolConversion(oldProtocolsStr, newProtocolsStr, kerberosEnabled, dataReplication, exportPolicyRules)
				for _, err := range validationErrors {
					return err
				}
			}

			return nil
		},
	}

	if !features.FivePointOh() {
		resource.Schema["export_policy_rule"].Elem.(*pluginsdk.Resource).Schema["protocols_enabled"] = &pluginsdk.Schema{
			Type:       pluginsdk.TypeList,
			Optional:   true,
			Computed:   true,
			MaxItems:   1,
			MinItems:   1,
			Deprecated: "this property has been deprecated in favour of `export_policy_rule.protocol` and will be removed in version 5.0 of the Provider.",
			Elem: &pluginsdk.Schema{
				Type: pluginsdk.TypeString,
				ValidateFunc: validation.StringInSlice([]string{
					"NFSv3",
					"NFSv4.1",
					"CIFS",
				}, false),
			},
		}

		resource.Schema["export_policy_rule"].Elem.(*pluginsdk.Resource).Schema["protocol"] = &pluginsdk.Schema{
			Type:     pluginsdk.TypeList,
			Optional: true,
			Computed: true,
			MinItems: 1,
			MaxItems: 1,
			Elem: &pluginsdk.Schema{
				Type: pluginsdk.TypeString,
				ValidateFunc: validation.StringInSlice([]string{
					"NFSv3",
					"NFSv4.1",
					"CIFS",
				}, false),
			},
		}
	}

	return resource
}
