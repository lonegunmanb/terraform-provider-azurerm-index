package github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp
import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/backups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/capacitypools"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumegroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumes"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumesreplication"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	netAppModels "github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp/models"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func expandNetAppVolumeGroupOracleVolumes(input []netAppModels.NetAppVolumeGroupOracleVolume) (*[]volumegroups.VolumeGroupVolumeProperties, error) {
	if len(input) == 0 {
		return &[]volumegroups.VolumeGroupVolumeProperties{}, fmt.Errorf("received empty NetAppVolumeGroupSAPHanaVolume slice")
	}

	results := make([]volumegroups.VolumeGroupVolumeProperties, 0)

	for _, item := range input {
		storageQuotaInGB := item.StorageQuotaInGB * 1073741824

		dataProtectionReplication := expandNetAppVolumeGroupDataProtectionReplication(item.DataProtectionReplication)
		dataProtectionSnapshotPolicy := expandNetAppVolumeGroupDataProtectionSnapshotPolicy(item.DataProtectionSnapshotPolicy)

		dataProtection := &volumegroups.VolumePropertiesDataProtection{}
		if dataProtectionReplication != nil && dataProtectionReplication.Replication != nil {
			dataProtection.Replication = dataProtectionReplication.Replication
		}
		if dataProtectionSnapshotPolicy != nil && dataProtectionSnapshotPolicy.Snapshot != nil {
			dataProtection.Snapshot = dataProtectionSnapshotPolicy.Snapshot
		}

		volumeProperties := &volumegroups.VolumeGroupVolumeProperties{
			Name: pointer.To(item.Name),
			Properties: volumegroups.VolumeProperties{
				CapacityPoolResourceId:   pointer.To(item.CapacityPoolId),
				CreationToken:            item.VolumePath,
				ServiceLevel:             pointer.To(volumegroups.ServiceLevel(item.ServiceLevel)),
				SubnetId:                 item.SubnetId,
				ProtocolTypes:            pointer.To(item.Protocols),
				SecurityStyle:            pointer.To(volumegroups.SecurityStyle(item.SecurityStyle)),
				UsageThreshold:           storageQuotaInGB,
				ExportPolicy:             expandNetAppVolumeGroupVolumeExportPolicyRule(item.ExportPolicy),
				SnapshotDirectoryVisible: pointer.To(item.SnapshotDirectoryVisible),
				ThroughputMibps:          utils.Float(item.ThroughputInMibps),
				VolumeSpecName:           utils.String(item.VolumeSpecName),
				NetworkFeatures:          pointer.To(volumegroups.NetworkFeatures(item.NetworkFeatures)),
				DataProtection:           dataProtection,
			},
			Tags: &item.Tags,
		}

		if v := item.ProximityPlacementGroupId; v != "" {
			volumeProperties.Properties.ProximityPlacementGroup = pointer.To(v)
		}

		if v := item.Zone; v != "" {
			volumeProperties.Zones = pointer.To([]string{v})
		}

		if v := item.EncryptionKeySource; v != "" {
			volumeProperties.Properties.EncryptionKeySource = pointer.To(volumegroups.EncryptionKeySource(v))
		}

		if v := item.KeyVaultPrivateEndpointId; v != "" {
			volumeProperties.Properties.KeyVaultPrivateEndpointResourceId = pointer.To(v)
		}

		if dataProtectionReplication != nil && dataProtectionReplication.Replication != nil &&
			dataProtectionReplication.Replication.EndpointType != nil &&
			strings.EqualFold(string(pointer.From(dataProtectionReplication.Replication.EndpointType)), string(volumegroups.EndpointTypeDst)) {
			volumeProperties.Properties.VolumeType = utils.String("DataProtection")
		}

		results = append(results, *volumeProperties)
	}

	return &results, nil
}
