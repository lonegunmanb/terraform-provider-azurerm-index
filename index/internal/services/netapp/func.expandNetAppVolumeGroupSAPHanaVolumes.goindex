package github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp
import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/capacitypools"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumegroups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumes"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	netAppModels "github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp/models"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func expandNetAppVolumeGroupSAPHanaVolumes(input []netAppModels.NetAppVolumeGroupSAPHanaVolume) (*[]volumegroups.VolumeGroupVolumeProperties, error) {
	if len(input) == 0 {
		return &[]volumegroups.VolumeGroupVolumeProperties{}, fmt.Errorf("received empty NetAppVolumeGroupSAPHanaVolume slice")
	}

	results := make([]volumegroups.VolumeGroupVolumeProperties, 0)

	for _, item := range input {
		name := item.Name
		volumePath := item.VolumePath
		serviceLevel := volumegroups.ServiceLevel(item.ServiceLevel)
		subnetID := item.SubnetId
		capacityPoolID := item.CapacityPoolId
		protocols := item.Protocols
		snapshotDirectoryVisible := item.SnapshotDirectoryVisible
		securityStyle := volumegroups.SecurityStyle(item.SecurityStyle)
		storageQuotaInGB := item.StorageQuotaInGB * 1073741824
		exportPolicyRule := expandNetAppVolumeGroupVolumeExportPolicyRule(item.ExportPolicy)
		dataProtectionReplication := expandNetAppVolumeGroupDataProtectionReplication(item.DataProtectionReplication)
		dataProtectionSnapshotPolicy := expandNetAppVolumeGroupDataProtectionSnapshotPolicy(item.DataProtectionSnapshotPolicy)

		dataProtection := &volumegroups.VolumePropertiesDataProtection{}
		if dataProtectionReplication != nil && dataProtectionReplication.Replication != nil {
			dataProtection.Replication = dataProtectionReplication.Replication
		}
		if dataProtectionSnapshotPolicy != nil && dataProtectionSnapshotPolicy.Snapshot != nil {
			dataProtection.Snapshot = dataProtectionSnapshotPolicy.Snapshot
		}

		volumeProperties := &volumegroups.VolumeGroupVolumeProperties{
			Name: pointer.To(name),
			Properties: volumegroups.VolumeProperties{
				CapacityPoolResourceId:   pointer.To(capacityPoolID),
				CreationToken:            volumePath,
				ServiceLevel:             &serviceLevel,
				SubnetId:                 subnetID,
				ProtocolTypes:            &protocols,
				SecurityStyle:            &securityStyle,
				UsageThreshold:           storageQuotaInGB,
				ExportPolicy:             exportPolicyRule,
				SnapshotDirectoryVisible: pointer.To(snapshotDirectoryVisible),
				ThroughputMibps:          pointer.To(item.ThroughputInMibps),
				VolumeSpecName:           pointer.To(item.VolumeSpecName),
				DataProtection:           dataProtection,
			},
			Tags: &item.Tags,
		}

		if v := item.ProximityPlacementGroupId; v != "" {
			volumeProperties.Properties.ProximityPlacementGroup = pointer.To(pointer.From(pointer.To(v)))
		}

		if dataProtectionReplication != nil &&
			dataProtectionReplication.Replication != nil &&
			dataProtectionReplication.Replication.EndpointType != nil &&
			strings.EqualFold(string(pointer.From(dataProtectionReplication.Replication.EndpointType)), string(volumegroups.EndpointTypeDst)) {
			volumeProperties.Properties.VolumeType = pointer.To("DataProtection")
		}

		results = append(results, *volumeProperties)
	}

	return &results, nil
}
