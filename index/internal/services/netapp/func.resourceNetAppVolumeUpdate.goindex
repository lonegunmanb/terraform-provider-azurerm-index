package github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp
import (
	"context"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/backups"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/poolchange"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/snapshots"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumes"
	"github.com/hashicorp/go-azure-sdk/resource-manager/netapp/2025-06-01/volumesreplication"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	netAppValidate "github.com/hashicorp/terraform-provider-azurerm/internal/services/netapp/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func resourceNetAppVolumeUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).NetApp.VolumeClient
	poolChangeClient := meta.(*clients.Client).NetApp.PoolChangeClient
	ctx, cancel := timeouts.ForCreateUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := volumes.ParseVolumeID(d.Id())
	if err != nil {
		return err
	}

	update := volumes.VolumePatch{
		Properties: &volumes.VolumePatchProperties{},
	}

	if d.HasChange("zones") {
		return fmt.Errorf("zone changes are not supported after volume is already created, %s", id)
	}

	if d.HasChange("snapshot_directory_visible") {
		snapshotDirectoryVisible := d.Get("snapshot_directory_visible").(bool)
		update.Properties.SnapshotDirectoryVisible = pointer.To(snapshotDirectoryVisible)
	}

	if d.HasChange("storage_quota_in_gb") {
		storageQuotaInBytes := int64(d.Get("storage_quota_in_gb").(int) * 1073741824)
		update.Properties.UsageThreshold = pointer.To(storageQuotaInBytes)
	}

	if d.HasChange("export_policy_rule") {
		exportPolicyRuleRaw := d.Get("export_policy_rule").([]interface{})
		var protocolOverride []string
		// Only override export policy protocols if we're also changing volume protocols
		if d.HasChange("protocols") {
			protocols := d.Get("protocols").(*pluginsdk.Set).List()
			protocolOverride = *utils.ExpandStringSlice(protocols)
		}
		exportPolicyRule := expandNetAppVolumeExportPolicyRulePatch(exportPolicyRuleRaw, protocolOverride)
		update.Properties.ExportPolicy = exportPolicyRule
	}

	if d.HasChange("protocols") {
		protocols := d.Get("protocols").(*pluginsdk.Set).List()
		update.Properties.ProtocolTypes = utils.ExpandStringSlice(protocols)
	}

	if d.HasChange("data_protection_snapshot_policy") {
		// Validating that snapshot policies are not being created in a data protection volume
		dataProtectionReplicationRaw := d.Get("data_protection_replication").([]interface{})
		dataProtectionReplication := expandNetAppVolumeDataProtectionReplication(dataProtectionReplicationRaw)

		if dataProtectionReplication != nil && dataProtectionReplication.Replication != nil && dataProtectionReplication.Replication.EndpointType != nil && strings.EqualFold(string(*dataProtectionReplication.Replication.EndpointType), "dst") {
			return fmt.Errorf("snapshot policy cannot be enabled on a data protection volume, %s", id)
		}

		dataProtectionSnapshotPolicyRaw := d.Get("data_protection_snapshot_policy").([]interface{})
		dataProtectionSnapshotPolicy := expandNetAppVolumeDataProtectionSnapshotPolicyPatch(dataProtectionSnapshotPolicyRaw)

		update.Properties.DataProtection = &volumes.VolumePatchPropertiesDataProtection{}
		update.Properties.DataProtection.Snapshot = dataProtectionSnapshotPolicy.Snapshot
	}

	if d.HasChange("data_protection_backup_policy") {
		// Validate applicability of backup policies
		dataProtectionReplicationRaw := d.Get("data_protection_replication").([]interface{})
		dataProtectionReplication := expandNetAppVolumeDataProtectionReplication(dataProtectionReplicationRaw)

		if dataProtectionReplication != nil && dataProtectionReplication.Replication != nil && dataProtectionReplication.Replication.EndpointType != nil && strings.EqualFold(string(*dataProtectionReplication.Replication.EndpointType), "dst") {
			return fmt.Errorf("snapshot policy cannot be enabled on a data protection volume, %s", id)
		}

		dataProtectionBackupPolicyRaw := d.Get("data_protection_backup_policy").([]interface{})
		dataProtectionBackupPolicy := expandNetAppVolumeDataProtectionBackupPolicyPatch(dataProtectionBackupPolicyRaw)

		if update.Properties.DataProtection == nil {
			update.Properties.DataProtection = &volumes.VolumePatchPropertiesDataProtection{}
		}
		update.Properties.DataProtection.Backup = dataProtectionBackupPolicy.Backup
	}

	if d.HasChange("throughput_in_mibps") {
		throughputMibps := d.Get("throughput_in_mibps")
		update.Properties.ThroughputMibps = pointer.To(throughputMibps.(float64))
	}

	if d.HasChange("smb_non_browsable_enabled") {
		smbNonBrowsable := volumes.SmbNonBrowsableDisabled
		update.Properties.SmbNonBrowsable = &smbNonBrowsable
		if d.Get("smb_non_browsable_enabled").(bool) {
			smbNonBrowsable := volumes.SmbNonBrowsableEnabled
			update.Properties.SmbNonBrowsable = &smbNonBrowsable
		}
	}

	if d.HasChange("smb_access_based_enumeration_enabled") {
		smbAccessBasedEnumeration := volumes.SmbAccessBasedEnumerationDisabled
		update.Properties.SmbAccessBasedEnumeration = &smbAccessBasedEnumeration
		if d.Get("smb_access_based_enumeration_enabled").(bool) {
			smbAccessBasedEnumeration := volumes.SmbAccessBasedEnumerationEnabled
			update.Properties.SmbAccessBasedEnumeration = &smbAccessBasedEnumeration
		}
	}

	if d.HasChange("cool_access") {
		if len(d.Get("cool_access").([]interface{})) > 0 {
			coolAccess := d.Get("cool_access").([]interface{})[0].(map[string]interface{})
			update.Properties.CoolAccess = pointer.To(true)

			if d.HasChange("cool_access.0.retrieval_policy") {
				update.Properties.CoolAccessRetrievalPolicy = pointer.To(volumes.CoolAccessRetrievalPolicy(coolAccess["retrieval_policy"].(string)))
			}

			if d.HasChange("cool_access.0.tiering_policy") {
				update.Properties.CoolAccessTieringPolicy = pointer.To(volumes.CoolAccessTieringPolicy(coolAccess["tiering_policy"].(string)))
			}

			if d.HasChange("cool_access.0.coolness_period_in_days") {
				update.Properties.CoolnessPeriod = pointer.To(int64(coolAccess["coolness_period_in_days"].(int)))
			}
		} else {
			update.Properties.CoolAccess = pointer.To(false)
		}
	}

	if d.HasChange("tags") {
		tagsRaw := d.Get("tags").(map[string]interface{})
		update.Tags = tags.Expand(tagsRaw)
	}

	if err = client.UpdateThenPoll(ctx, *id, update); err != nil {
		return fmt.Errorf("updating %s: %+v", id, err)
	}

	// Wait for volume to complete update
	if err := waitForVolumeCreateOrUpdate(ctx, client, *id); err != nil {
		return err
	}

	if d.HasChanges("service_level", "pool_name") {
		poolName := d.Get("pool_name").(string)
		poolId := volumes.NewCapacityPoolID(id.SubscriptionId, id.ResourceGroupName, id.NetAppAccountName, poolName)
		volumeId, err := poolchange.ParseVolumeID(id.ID())
		if err != nil {
			return err
		}
		poolChangeInput := poolchange.PoolChangeRequest{
			NewPoolResourceId: poolId.ID(),
		}
		if _, err = poolChangeClient.VolumesPoolChange(ctx, *volumeId, poolChangeInput); err != nil {
			return fmt.Errorf("updating `service_level` for %s: %+v", id, err)
		}

		// the id needs to be updated as the pool is different
		newId := volumes.NewVolumeID(id.SubscriptionId, id.ResourceGroupName, id.NetAppAccountName, poolName, id.VolumeName)

		if err = waitForVolumeCreateOrUpdate(ctx, client, newId); err != nil {
			return err
		}

		d.SetId(newId.ID())
	}

	return resourceNetAppVolumeRead(d, meta)
}
