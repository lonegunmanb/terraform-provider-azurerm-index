package github.com/hashicorp/terraform-provider-azurerm/internal/services/containerapps
import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/location"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/tags"
	"github.com/hashicorp/go-azure-sdk/resource-manager/containerapps/2023-05-01/managedenvironments"
	"github.com/hashicorp/go-azure-sdk/resource-manager/containerapps/2024-03-01/containerapps"
	"github.com/hashicorp/terraform-provider-azurerm/internal/sdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/containerapps/helpers"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
)
func (r ContainerAppDataSource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			client := metadata.Client.ContainerApps.ContainerAppClient
			subscriptionId := metadata.Client.Account.SubscriptionId

			var containerApp ContainerAppDataSourceModel
			if err := metadata.Decode(&containerApp); err != nil {
				return err
			}

			id := containerapps.NewContainerAppID(subscriptionId, containerApp.ResourceGroup, containerApp.Name)

			existing, err := client.Get(ctx, id)
			if err != nil {
				if response.WasNotFound(existing.HttpResponse) {
					return fmt.Errorf("%s was not found", id)
				}
				return fmt.Errorf("reading %s: %+v", id, err)
			}

			containerApp.Name = id.ContainerAppName
			containerApp.ResourceGroup = id.ResourceGroupName

			if model := existing.Model; model != nil {
				containerApp.Location = location.Normalize(model.Location)
				containerApp.Tags = tags.Flatten(model.Tags)

				if props := model.Properties; props != nil {
					envId, err := managedenvironments.ParseManagedEnvironmentIDInsensitively(pointer.From(props.ManagedEnvironmentId))
					if err != nil {
						return err
					}
					containerApp.ManagedEnvironmentId = envId.ID()
					containerApp.Template = helpers.FlattenContainerAppTemplate(props.Template)
					if config := props.Configuration; config != nil {
						if config.ActiveRevisionsMode != nil {
							if config.ActiveRevisionsMode != nil {
								containerApp.RevisionMode = string(pointer.From(config.ActiveRevisionsMode))
							}
							containerApp.Ingress = helpers.FlattenContainerAppIngress(config.Ingress, id.ContainerAppName)
							containerApp.Registries = helpers.FlattenContainerAppRegistries(config.Registries)
							containerApp.Dapr = helpers.FlattenContainerAppDapr(config.Dapr)
							containerApp.MaxInactiveRevisions = pointer.ToInt64(config.MaxInactiveRevisions)
						}
					}
					containerApp.LatestRevisionName = pointer.From(props.LatestRevisionName)
					containerApp.LatestRevisionFqdn = pointer.From(props.LatestRevisionFqdn)
					containerApp.CustomDomainVerificationId = pointer.From(props.CustomDomainVerificationId)
					containerApp.OutboundIpAddresses = pointer.From(props.OutboundIPAddresses)
					containerApp.WorkloadProfileName = pointer.From(props.WorkloadProfileName)
				}
			}

			secretsResp, err := client.ListSecrets(ctx, id)
			if err != nil {
				return fmt.Errorf("listing secrets for %s: %+v", id, err)
			}

			containerApp.Secrets = helpers.FlattenContainerAppSecrets(secretsResp.Model)
			metadata.SetID(id)

			return metadata.Encode(&containerApp)
		},
	}
}
