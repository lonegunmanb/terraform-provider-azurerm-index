package github.com/hashicorp/terraform-provider-azurerm/internal/services/apimanagement
import (
	"context"
	"errors"
	"fmt"
	"log"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonschema"
	"github.com/hashicorp/go-azure-sdk/resource-manager/apimanagement/2022-08-01/api"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/apimanagement/migration"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/apimanagement/schemaz"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/apimanagement/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceApiManagementApiUpdate(d *pluginsdk.ResourceData, meta interface{}) error {
	client := meta.(*clients.Client).ApiManagement.ApiClient
	ctx, cancel := timeouts.ForCreateUpdate(meta.(*clients.Client).StopContext, d)
	defer cancel()

	path := d.Get("path").(string)
	version := d.Get("version").(string)
	versionSetId := d.Get("version_set_id").(string)
	displayName := d.Get("display_name").(string)
	protocolsRaw := d.Get("protocols").(*pluginsdk.Set).List()
	protocols := expandApiManagementApiProtocols(protocolsRaw)
	sourceApiId := d.Get("source_api_id").(string)
	serviceUrl := d.Get("service_url").(string)

	id, err := api.ParseApiID(d.Id())
	if err != nil {
		return err
	}

	apiType := api.ApiTypeHTTP
	if v, ok := d.GetOk("api_type"); ok {
		apiType = api.ApiType(v.(string))
	}
	soapApiType := soapApiTypeFromApiType(apiType)

	// If import is used, we need to send properties to Azure API in two operations.
	// First we execute import and then updated the other props.
	if d.HasChange("import") {
		if vs, hasImport := d.GetOk("import"); hasImport {
			if apiParams := expandApiManagementApiImport(vs.([]interface{}), apiType, soapApiType,
				path, serviceUrl, version, versionSetId); apiParams != nil {
				if err := client.CreateOrUpdateThenPoll(ctx, *id, *apiParams, api.CreateOrUpdateOperationOptions{}); err != nil {
					return fmt.Errorf("creating/updating %s: %+v", *id, err)
				}
			}
		}
	}

	resp, err := client.Get(ctx, *id)
	if err != nil {
		return fmt.Errorf("retrieving %s: %+v", *id, err)
	}

	if resp.Model == nil || resp.Model.Properties == nil {
		return fmt.Errorf("retrieving %s: `properties` was nil", *id)
	}

	existing := resp.Model.Properties
	if existing.Type != nil {
		soapApiType = soapApiTypeFromApiType(pointer.From(existing.Type))
	}
	prop := &api.ApiCreateOrUpdateProperties{
		Path:                          existing.Path,
		Protocols:                     existing.Protocols,
		ServiceURL:                    existing.ServiceURL,
		Description:                   existing.Description,
		ApiVersionDescription:         existing.ApiVersionDescription,
		ApiRevisionDescription:        existing.ApiRevisionDescription,
		SubscriptionRequired:          existing.SubscriptionRequired,
		SubscriptionKeyParameterNames: existing.SubscriptionKeyParameterNames,
		AuthenticationSettings:        existing.AuthenticationSettings,
		Contact:                       existing.Contact,
		License:                       existing.License,
		SourceApiId:                   existing.SourceApiId,
		DisplayName:                   existing.DisplayName,
		ApiVersion:                    existing.ApiVersion,
		ApiVersionSetId:               existing.ApiVersionSetId,
		TermsOfServiceURL:             existing.TermsOfServiceURL,
		Type:                          existing.Type,
		ApiType:                       pointer.To(soapApiType),
	}

	if d.HasChange("path") {
		prop.Path = path
	}

	if d.HasChange("protocols") {
		prop.Protocols = protocols
	}

	if d.HasChange("api_type") {
		prop.Type = pointer.To(apiType)
		prop.ApiType = pointer.To(soapApiType)
	}

	if d.HasChange("service_url") {
		prop.ServiceURL = pointer.To(serviceUrl)
	}

	if d.HasChange("description") {
		prop.Description = pointer.To(d.Get("description").(string))
	}

	if d.HasChange("revision_description") {
		prop.ApiRevisionDescription = pointer.To(d.Get("revision_description").(string))
	}

	if d.HasChange("version_description") {
		prop.ApiVersionDescription = pointer.To(d.Get("version_description").(string))
	}
	if d.HasChange("subscription_required") {
		prop.SubscriptionRequired = pointer.To(d.Get("subscription_required").(bool))
	}

	if d.HasChange("subscription_key_parameter_names") {
		subscriptionKeyParameterNamesRaw := d.Get("subscription_key_parameter_names").([]interface{})
		prop.SubscriptionKeyParameterNames = expandApiManagementApiSubscriptionKeyParamNames(subscriptionKeyParameterNamesRaw)
	}

	authenticationSettings := existing.AuthenticationSettings
	if authenticationSettings == nil {
		authenticationSettings = &api.AuthenticationSettingsContract{}
	}
	if d.HasChange("oauth2_authorization") {
		oAuth2AuthorizationSettingsRaw := d.Get("oauth2_authorization").([]interface{})
		oAuth2AuthorizationSettings := expandApiManagementOAuth2AuthenticationSettingsContract(oAuth2AuthorizationSettingsRaw)
		authenticationSettings.OAuth2 = oAuth2AuthorizationSettings
		prop.AuthenticationSettings = authenticationSettings
	}

	if d.HasChange("openid_authentication") {
		openIDAuthorizationSettingsRaw := d.Get("openid_authentication").([]interface{})
		openIDAuthorizationSettings := expandApiManagementOpenIDAuthenticationSettingsContract(openIDAuthorizationSettingsRaw)
		authenticationSettings.Openid = openIDAuthorizationSettings
		prop.AuthenticationSettings = authenticationSettings
	}

	if d.HasChange("contact") {
		prop.Contact = expandApiManagementApiContact(d.Get("contact").([]interface{}))
	}

	if d.HasChange("license") {
		prop.License = expandApiManagementApiLicense(d.Get("license").([]interface{}))
	}

	if d.HasChange("source_api_id") {
		prop.SourceApiId = pointer.To(sourceApiId)
	}

	if d.HasChange("display_name") {
		prop.DisplayName = pointer.To(displayName)
	}

	if d.HasChange("version") {
		prop.ApiVersion = pointer.To(version)
	}

	if d.HasChange("version_set_id") {
		prop.ApiVersionSetId = pointer.To(versionSetId)
	}

	if d.HasChange("terms_of_service_url") {
		prop.TermsOfServiceURL = pointer.To(d.Get("terms_of_service_url").(string))
	}

	params := api.ApiCreateOrUpdateParameter{
		Properties: prop,
	}

	if err := client.CreateOrUpdateThenPoll(ctx, *id, params, api.CreateOrUpdateOperationOptions{IfMatch: pointer.To("*")}); err != nil {
		return fmt.Errorf("creating/updating %s: %+v", *id, err)
	}

	return resourceApiManagementApiRead(d, meta)
}
