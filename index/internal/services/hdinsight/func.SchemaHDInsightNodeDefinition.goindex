package github.com/hashicorp/terraform-provider-azurerm/internal/services/hdinsight
import (
	"fmt"
	"net/url"
	"regexp"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/identity"
	"github.com/hashicorp/go-azure-sdk/resource-manager/hdinsight/2021-06-01/clusters"
	"github.com/hashicorp/go-azure-sdk/resource-manager/hdinsight/2021-06-01/extensions"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/azure"
	azValidate "github.com/hashicorp/terraform-provider-azurerm/helpers/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/hdinsight/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/parse"
	keyVault "github.com/hashicorp/terraform-provider-azurerm/internal/services/keyvault/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/utils"
)
func SchemaHDInsightNodeDefinition(schemaLocation string, definition HDInsightNodeDefinition, required bool) *pluginsdk.Schema {
	result := map[string]*pluginsdk.Schema{
		"vm_size": {
			Type:         pluginsdk.TypeString,
			Required:     true,
			ForceNew:     true,
			ValidateFunc: validation.StringInSlice(validate.NodeDefinitionVMSize, false),
		},
		"username": {
			Type:     pluginsdk.TypeString,
			Required: true,
			ForceNew: true,
		},
		"password": {
			Type:      pluginsdk.TypeString,
			Optional:  true,
			ForceNew:  true,
			Sensitive: true,
		},
		"ssh_keys": {
			Type:     pluginsdk.TypeSet,
			Optional: true,
			ForceNew: true,
			Elem: &pluginsdk.Schema{
				Type:         pluginsdk.TypeString,
				ValidateFunc: validation.StringIsNotEmpty,
			},
			Set: pluginsdk.HashString,
			ConflictsWith: []string{
				fmt.Sprintf("%s.0.password", schemaLocation),
			},
		},

		"subnet_id": {
			Type:         pluginsdk.TypeString,
			Optional:     true,
			ForceNew:     true,
			ValidateFunc: commonids.ValidateSubnetID,
		},

		"virtual_network_id": {
			Type:         pluginsdk.TypeString,
			Optional:     true,
			ForceNew:     true,
			ValidateFunc: commonids.ValidateVirtualNetworkID,
		},

		"script_actions": SchemaHDInsightsScriptActions(),
	}

	if definition.CanSpecifyInstanceCount {
		countValidation := validation.IntAtLeast(definition.MinInstanceCount)
		if definition.MaxInstanceCount != nil {
			countValidation = validation.IntBetween(definition.MinInstanceCount, *definition.MaxInstanceCount)
		}

		result["target_instance_count"] = &pluginsdk.Schema{
			Type:         pluginsdk.TypeInt,
			Required:     true,
			ValidateFunc: countValidation,
		}

		if definition.CanAutoScaleByCapacity || definition.CanAutoScaleOnSchedule {
			autoScales := map[string]*pluginsdk.Schema{}

			if definition.CanAutoScaleByCapacity {
				autoScales["capacity"] = &pluginsdk.Schema{
					Type:     pluginsdk.TypeList,
					Optional: true,
					MaxItems: 1,
					ConflictsWith: []string{
						fmt.Sprintf("%s.0.autoscale.0.recurrence", schemaLocation),
					},
					Elem: &pluginsdk.Resource{
						Schema: map[string]*pluginsdk.Schema{
							"min_instance_count": {
								Type:         pluginsdk.TypeInt,
								Required:     true,
								ValidateFunc: countValidation,
							},
							"max_instance_count": {
								Type:         pluginsdk.TypeInt,
								Required:     true,
								ValidateFunc: countValidation,
							},
						},
					},
				}
				if definition.CanAutoScaleOnSchedule {
					autoScales["capacity"].ConflictsWith = []string{
						fmt.Sprintf("%s.0.autoscale.0.recurrence", schemaLocation),
					}
				}
			}

			if definition.CanAutoScaleOnSchedule {
				autoScales["recurrence"] = &pluginsdk.Schema{
					Type:     pluginsdk.TypeList,
					Optional: true,
					MaxItems: 1,
					Elem: &pluginsdk.Resource{
						Schema: map[string]*pluginsdk.Schema{
							"timezone": {
								Type:     pluginsdk.TypeString,
								Required: true,
							},
							"schedule": {
								Type:     pluginsdk.TypeList,
								Required: true,
								MinItems: 1,
								Elem: &pluginsdk.Resource{
									Schema: map[string]*pluginsdk.Schema{
										"time": {
											Type:     pluginsdk.TypeString,
											Required: true,
											ValidateFunc: validation.StringMatch(
												regexp.MustCompile("^([01][0-9]|[2][0-3]):([03][0])$"), // time must be on the hour or half past
												"Time of day must match the format HH:mm where HH is 00-23 and mm is 00 or 30",
											),
										},
										"days": {
											Type:     pluginsdk.TypeList,
											Required: true,
											Elem: &pluginsdk.Schema{
												Type: pluginsdk.TypeString,
												ValidateFunc: validation.StringInSlice([]string{
													string(clusters.DaysOfWeekMonday),
													string(clusters.DaysOfWeekTuesday),
													string(clusters.DaysOfWeekWednesday),
													string(clusters.DaysOfWeekThursday),
													string(clusters.DaysOfWeekFriday),
													string(clusters.DaysOfWeekSaturday),
													string(clusters.DaysOfWeekSunday),
												}, false),
											},
										},

										"target_instance_count": {
											Type:         pluginsdk.TypeInt,
											Required:     true,
											ValidateFunc: countValidation,
										},
									},
								},
							},
						},
					},
				}
				if definition.CanAutoScaleByCapacity {
					autoScales["recurrence"].ConflictsWith = []string{
						fmt.Sprintf("%s.0.autoscale.0.capacity", schemaLocation),
					}
				}
			}

			result["autoscale"] = &pluginsdk.Schema{
				Type:     pluginsdk.TypeList,
				Optional: true,
				MaxItems: 1,
				Elem: &pluginsdk.Resource{
					Schema: autoScales,
				},
			}
		}
	}

	if definition.CanSpecifyDisks {
		result["number_of_disks_per_node"] = &pluginsdk.Schema{
			Type:         pluginsdk.TypeInt,
			Required:     true,
			ForceNew:     true,
			ValidateFunc: validation.IntBetween(1, *definition.MaxNumberOfDisksPerNode),
		}
	}

	s := &pluginsdk.Schema{
		Type:     pluginsdk.TypeList,
		MaxItems: 1,
		Required: required,
		Optional: !required,
		Elem: &pluginsdk.Resource{
			Schema: result,
		},
	}

	return s
}
