package github.com/hashicorp/terraform-provider-azurerm/internal/services/storage
import (
	"errors"
	"fmt"
	"log"
	"time"

	// nolint: staticcheck
	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-sdk/resource-manager/storage/2023-05-01/managementpolicies"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/storage/parse"
	"github.com/hashicorp/terraform-provider-azurerm/internal/services/storage/validate"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func expandStorageManagementPolicyRule(d *pluginsdk.ResourceData, ruleIndex int) (*managementpolicies.ManagementPolicyRule, error) {
	name := d.Get(fmt.Sprintf("rule.%d.name", ruleIndex)).(string)
	enabled := d.Get(fmt.Sprintf("rule.%d.enabled", ruleIndex)).(bool)
	typeVal := "Lifecycle"

	definition := managementpolicies.ManagementPolicyDefinition{
		Filters: &managementpolicies.ManagementPolicyFilter{},
		Actions: managementpolicies.ManagementPolicyAction{},
	}
	filtersRef := d.Get(fmt.Sprintf("rule.%d.filters", ruleIndex)).([]interface{})
	if len(filtersRef) == 1 {
		if filtersRef[0] != nil {
			filterRef := filtersRef[0].(map[string]interface{})

			prefixMatches := []string{}
			prefixMatchesRef := filterRef["prefix_match"].(*pluginsdk.Set)
			if prefixMatchesRef != nil {
				for _, prefixMatchRef := range prefixMatchesRef.List() {
					prefixMatches = append(prefixMatches, prefixMatchRef.(string))
				}
			}
			definition.Filters.PrefixMatch = &prefixMatches

			blobTypes := []string{}
			blobTypesRef := filterRef["blob_types"].(*pluginsdk.Set)
			if blobTypesRef != nil {
				for _, blobTypeRef := range blobTypesRef.List() {
					blobTypes = append(blobTypes, blobTypeRef.(string))
				}
			}
			definition.Filters.BlobTypes = blobTypes

			definition.Filters.BlobIndexMatch = expandAzureRmStorageBlobIndexMatch(filterRef["match_blob_index_tag"].(*pluginsdk.Set).List())
		}
	}
	if _, ok := d.GetOk(fmt.Sprintf("rule.%d.actions", ruleIndex)); ok {
		if _, ok := d.GetOk(fmt.Sprintf("rule.%d.actions.0.base_blob", ruleIndex)); ok {
			baseBlob := &managementpolicies.ManagementPolicyBaseBlob{}
			var (
				sinceMod, sinceAccess, sinceCreate       interface{}
				sinceModOK, sinceAccessOK, sinceCreateOK bool
			)

			sinceMod = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_cool_after_days_since_modification_greater_than", ruleIndex))
			sinceModOK = sinceMod != -1

			sinceAccess = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_cool_after_days_since_last_access_time_greater_than", ruleIndex))
			sinceAccessOK = sinceAccess != -1

			sinceCreate = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_cool_after_days_since_creation_greater_than", ruleIndex))
			sinceCreateOK = sinceCreate != -1

			autoTierToHotOK := d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.auto_tier_to_hot_from_cool_enabled", ruleIndex)).(bool)
			if autoTierToHotOK && !sinceAccessOK {
				return nil, fmt.Errorf("`auto_tier_to_hot_from_cool_enabled` must be used together with `tier_to_cool_after_days_since_last_access_time_greater_than`")
			}

			var cnt int
			if sinceModOK {
				cnt++
			}
			if sinceAccessOK {
				cnt++
			}
			if sinceCreateOK {
				cnt++
			}
			if cnt > 1 {
				return nil, errors.New("only one of `tier_to_cool_after_days_since_modification_greater_than`, `tier_to_cool_after_days_since_last_access_time_greater_than`, `tier_to_cool_after_days_since_creation_greater_than` can be specified at the same time")
			}

			if sinceModOK || sinceAccessOK || sinceCreateOK {
				baseBlob.TierToCool = &managementpolicies.DateAfterModification{}
				if sinceModOK {
					baseBlob.TierToCool.DaysAfterModificationGreaterThan = pointer.To(float64(sinceMod.(int)))
				}
				if sinceAccessOK {
					baseBlob.TierToCool.DaysAfterLastAccessTimeGreaterThan = pointer.To(float64(sinceAccess.(int)))
				}
				if sinceCreateOK {
					baseBlob.TierToCool.DaysAfterCreationGreaterThan = pointer.To(float64(sinceCreate.(int)))
				}
				if autoTierToHotOK {
					baseBlob.EnableAutoTierToHotFromCool = pointer.To(autoTierToHotOK)
				}
			}

			sinceMod = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_archive_after_days_since_modification_greater_than", ruleIndex))
			sinceModOK = sinceMod != -1
			sinceAccess = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_archive_after_days_since_last_access_time_greater_than", ruleIndex))
			sinceAccessOK = sinceAccess != -1
			sinceCreate = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_archive_after_days_since_creation_greater_than", ruleIndex))
			sinceCreateOK = sinceCreate != -1

			cnt = 0
			if sinceModOK {
				cnt++
			}
			if sinceAccessOK {
				cnt++
			}
			if sinceCreateOK {
				cnt++
			}
			if cnt > 1 {
				return nil, errors.New("only one of `tier_to_archive_after_days_since_modification_greater_than`, `tier_to_archive_after_days_since_last_access_time_greater_than` and `tier_to_archive_after_days_since_creation_greater_than` can be specified at the same time")
			}

			if sinceModOK || sinceAccessOK || sinceCreateOK {
				baseBlob.TierToArchive = &managementpolicies.DateAfterModification{}
				if sinceModOK {
					baseBlob.TierToArchive.DaysAfterModificationGreaterThan = pointer.To(float64(sinceMod.(int)))
				}
				if sinceAccessOK {
					baseBlob.TierToArchive.DaysAfterLastAccessTimeGreaterThan = pointer.To(float64(sinceAccess.(int)))
				}
				if sinceCreateOK {
					baseBlob.TierToArchive.DaysAfterCreationGreaterThan = pointer.To(float64(sinceCreate.(int)))
				}
				if v := d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_archive_after_days_since_last_tier_change_greater_than", ruleIndex)); v != -1 {
					baseBlob.TierToArchive.DaysAfterLastTierChangeGreaterThan = pointer.To(float64(v.(int)))
				}
			}

			sinceMod = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.delete_after_days_since_modification_greater_than", ruleIndex))
			sinceModOK = sinceMod != -1
			sinceAccess = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.delete_after_days_since_last_access_time_greater_than", ruleIndex))
			sinceAccessOK = sinceAccess != -1
			sinceCreate = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.delete_after_days_since_creation_greater_than", ruleIndex))
			sinceCreateOK = sinceCreate != -1

			cnt = 0
			if sinceModOK {
				cnt++
			}
			if sinceAccessOK {
				cnt++
			}
			if sinceCreateOK {
				cnt++
			}
			if cnt > 1 {
				return nil, errors.New("only one of `delete_after_days_since_modification_greater_than`, `delete_after_days_since_last_access_time_greater_than` and `delete_after_days_since_creation_greater_than` can be specified at the same time")
			}
			if sinceModOK || sinceAccessOK || sinceCreateOK {
				baseBlob.Delete = &managementpolicies.DateAfterModification{}
				if sinceModOK {
					baseBlob.Delete.DaysAfterModificationGreaterThan = pointer.To(float64(sinceMod.(int)))
				}
				if sinceAccessOK {
					baseBlob.Delete.DaysAfterLastAccessTimeGreaterThan = pointer.To(float64(sinceAccess.(int)))
				}
				if sinceCreateOK {
					baseBlob.Delete.DaysAfterCreationGreaterThan = pointer.To(float64(sinceCreate.(int)))
				}
			}

			sinceMod = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_cold_after_days_since_modification_greater_than", ruleIndex))
			sinceModOK = sinceMod != -1
			sinceAccess = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_cold_after_days_since_last_access_time_greater_than", ruleIndex))
			sinceAccessOK = sinceAccess != -1
			sinceCreate = d.Get(fmt.Sprintf("rule.%d.actions.0.base_blob.0.tier_to_cold_after_days_since_creation_greater_than", ruleIndex))
			sinceCreateOK = sinceCreate != -1

			cnt = 0
			if sinceModOK {
				cnt++
			}
			if sinceAccessOK {
				cnt++
			}
			if sinceCreateOK {
				cnt++
			}
			if cnt > 1 {
				return nil, errors.New("only one of `tier_to_cold_after_days_since_modification_greater_than`, `tier_to_cold_after_days_since_last_access_time_greater_than` and `tier_to_cold_after_days_since_creation_greater_than` can be specified at the same time")
			}

			if sinceModOK || sinceAccessOK || sinceCreateOK {
				baseBlob.TierToCold = &managementpolicies.DateAfterModification{}
				if sinceModOK {
					baseBlob.TierToCold.DaysAfterModificationGreaterThan = pointer.To(float64(sinceMod.(int)))
				}
				if sinceAccessOK {
					baseBlob.TierToCold.DaysAfterLastAccessTimeGreaterThan = pointer.To(float64(sinceAccess.(int)))
				}
				if sinceCreateOK {
					baseBlob.TierToCold.DaysAfterCreationGreaterThan = pointer.To(float64(sinceCreate.(int)))
				}
			}

			definition.Actions.BaseBlob = baseBlob
		}

		if _, ok := d.GetOk(fmt.Sprintf("rule.%d.actions.0.snapshot", ruleIndex)); ok {
			snapshot := &managementpolicies.ManagementPolicySnapShot{}

			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.snapshot.0.delete_after_days_since_creation_greater_than", ruleIndex)); v != -1 {
				snapshot.Delete = &managementpolicies.DateAfterCreation{DaysAfterCreationGreaterThan: float64(v.(int))}
			}

			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.snapshot.0.change_tier_to_archive_after_days_since_creation", ruleIndex)); v != -1 {
				snapshot.TierToArchive = &managementpolicies.DateAfterCreation{
					DaysAfterCreationGreaterThan: float64(v.(int)),
				}
				if vv := d.Get(fmt.Sprintf("rule.%d.actions.0.snapshot.0.tier_to_archive_after_days_since_last_tier_change_greater_than", ruleIndex)); vv != -1 {
					snapshot.TierToArchive.DaysAfterLastTierChangeGreaterThan = pointer.To(float64(vv.(int)))
				}
			}
			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.snapshot.0.change_tier_to_cool_after_days_since_creation", ruleIndex)); v != -1 {
				snapshot.TierToCool = &managementpolicies.DateAfterCreation{
					DaysAfterCreationGreaterThan: float64(v.(int)),
				}
			}
			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.snapshot.0.tier_to_cold_after_days_since_creation_greater_than", ruleIndex)); v != -1 {
				snapshot.TierToCold = &managementpolicies.DateAfterCreation{
					DaysAfterCreationGreaterThan: float64(v.(int)),
				}
			}
			definition.Actions.Snapshot = snapshot
		}

		if _, ok := d.GetOk(fmt.Sprintf("rule.%d.actions.0.version", ruleIndex)); ok {
			version := &managementpolicies.ManagementPolicyVersion{}
			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.version.0.delete_after_days_since_creation", ruleIndex)); v != -1 {
				version.Delete = &managementpolicies.DateAfterCreation{
					DaysAfterCreationGreaterThan: float64(v.(int)),
				}
			}
			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.version.0.change_tier_to_archive_after_days_since_creation", ruleIndex)); v != -1 {
				version.TierToArchive = &managementpolicies.DateAfterCreation{
					DaysAfterCreationGreaterThan: float64(v.(int)),
				}
				if vv := d.Get(fmt.Sprintf("rule.%d.actions.0.version.0.tier_to_archive_after_days_since_last_tier_change_greater_than", ruleIndex)); vv != -1 {
					version.TierToArchive.DaysAfterLastTierChangeGreaterThan = pointer.To(float64(vv.(int)))
				}
			}
			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.version.0.change_tier_to_cool_after_days_since_creation", ruleIndex)); v != -1 {
				version.TierToCool = &managementpolicies.DateAfterCreation{
					DaysAfterCreationGreaterThan: float64(v.(int)),
				}
			}
			if v := d.Get(fmt.Sprintf("rule.%d.actions.0.version.0.tier_to_cold_after_days_since_creation_greater_than", ruleIndex)); v != -1 {
				version.TierToCold = &managementpolicies.DateAfterCreation{
					DaysAfterCreationGreaterThan: float64(v.(int)),
				}
			}
			definition.Actions.Version = version
		}
	}

	return &managementpolicies.ManagementPolicyRule{
		Name:       name,
		Enabled:    &enabled,
		Type:       managementpolicies.RuleType(typeVal),
		Definition: definition,
	}, nil
}
