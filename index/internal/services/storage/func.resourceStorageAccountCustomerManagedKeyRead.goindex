package github.com/hashicorp/terraform-provider-azurerm/internal/services/storage
import (
	"fmt"
	"log"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/commonids"
	"github.com/hashicorp/go-azure-helpers/resourcemanager/keyvault"
	"github.com/hashicorp/go-azure-sdk/resource-manager/storage/2023-05-01/storageaccounts"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
	"github.com/hashicorp/terraform-provider-azurerm/helpers/tf"
	"github.com/hashicorp/terraform-provider-azurerm/internal/clients"
	"github.com/hashicorp/terraform-provider-azurerm/internal/features"
	"github.com/hashicorp/terraform-provider-azurerm/internal/locks"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azurerm/internal/tf/validation"
	"github.com/hashicorp/terraform-provider-azurerm/internal/timeouts"
)
func resourceStorageAccountCustomerManagedKeyRead(d *pluginsdk.ResourceData, meta interface{}) error {
	storageClient := meta.(*clients.Client).Storage.ResourceManager.StorageAccounts
	keyVaultsClient := meta.(*clients.Client).KeyVault

	ctx, cancel := timeouts.ForRead(meta.(*clients.Client).StopContext, d)
	defer cancel()

	id, err := commonids.ParseStorageAccountID(d.Id())
	if err != nil {
		return err
	}

	resp, err := storageClient.GetProperties(ctx, *id, storageaccounts.DefaultGetPropertiesOperationOptions())
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			log.Printf("[DEBUG] %q was not found - removing from state!", *id)
			d.SetId("")
			return nil
		}
		return fmt.Errorf("retrieving %s: %+v", id, err)
	}

	d.Set("storage_account_id", id.ID())

	enabled := false
	if model := resp.Model; model != nil {
		if props := model.Properties; props != nil {
			if encryption := props.Encryption; encryption != nil && pointer.From(encryption.KeySource) == storageaccounts.KeySourceMicrosoftPointKeyvault {
				enabled = true

				if features.FivePointOh() {
					if kvProps := encryption.Keyvaultproperties; kvProps != nil {
						keyID, err := keyvault.NewNestedItemID(pointer.From(kvProps.Keyvaulturi), keyvault.NestedItemTypeKey, pointer.From(kvProps.Keyname), pointer.From(kvProps.Keyversion))
						if err != nil {
							return err
						}
						d.Set("key_vault_key_id", keyID.ID())
					}

					if identityProps := encryption.Identity; identityProps != nil {
						d.Set("user_assigned_identity_id", identityProps.UserAssignedIdentity)
						d.Set("federated_identity_client_id", identityProps.FederatedIdentityClientId)
					}
				} else {
					var keyID *keyvault.NestedItemID
					if kvProps := encryption.Keyvaultproperties; kvProps != nil {
						keyId, err := keyvault.NewNestedItemID(pointer.From(kvProps.Keyvaulturi), keyvault.NestedItemTypeKey, pointer.From(kvProps.Keyname), pointer.From(kvProps.Keyversion))
						if err != nil {
							return err
						}

						d.Set("key_vault_key_id", keyId.ID())
						d.Set("key_name", kvProps.Keyname)
						d.Set("key_version", kvProps.Keyversion)
						d.Set("key_vault_uri", kvProps.Keyvaulturi)

						if keyId.IsManagedHSM() {
							d.Set("managed_hsm_key_id", keyId.ID())
						}

						keyID = keyId
					}

					federatedIdentityClientID := ""
					userAssignedIdentity := ""
					if identityProps := encryption.Identity; identityProps != nil {
						federatedIdentityClientID = pointer.From(identityProps.FederatedIdentityClientId)
						userAssignedIdentity = pointer.From(identityProps.UserAssignedIdentity)
					}
					// now we have the key vault uri we can look up the ID
					// we can't look up the ID when using federated identity as the key will be under different tenant
					keyVaultID := ""
					if federatedIdentityClientID == "" && keyID != nil && !keyID.IsManagedHSM() {
						subscriptionResourceId := commonids.NewSubscriptionID(id.SubscriptionId)
						tmpKeyVaultID, err := keyVaultsClient.KeyVaultIDFromBaseUrl(ctx, subscriptionResourceId, keyID.KeyVaultBaseURL)
						if err != nil {
							return fmt.Errorf("retrieving Key Vault ID from the Base URI %q: %+v", keyID.KeyVaultBaseURL, err)
						}
						keyVaultID = pointer.From(tmpKeyVaultID)
					}
					d.Set("key_vault_id", keyVaultID)
					d.Set("user_assigned_identity_id", userAssignedIdentity)
					d.Set("federated_identity_client_id", federatedIdentityClientID)
				}
			}
		}
	}

	if !enabled {
		log.Printf("[DEBUG] Customer Managed Key was not defined for %s - removing from state!", id)
		d.SetId("")
		return nil
	}

	return pluginsdk.SetResourceIdentityData(d, id, pluginsdk.ResourceTypeForIdentityVirtual)
}
