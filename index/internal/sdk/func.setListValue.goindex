package github.com/hashicorp/terraform-provider-azurerm/internal/sdk
import (
	"fmt"
	"reflect"

	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)
func setListValue(input interface{}, index int, fieldName string, v []interface{}, debugLogger Logger) error {
	fieldType := reflect.ValueOf(input).Elem().Field(index).Type()
	var slice reflect.Value
	if reflect.TypeOf(input).Elem().Field(index).Type.Kind() != reflect.Ptr {
		slice = reflect.MakeSlice(reflect.TypeOf(input).Elem().Field(index).Type, len(v), len(v))
	} else {
		slice = reflect.MakeSlice(fieldType.Elem(), len(v), len(v))
	}
	isPtr := fieldType.Kind() == reflect.Ptr
	var dereferenceFieldType reflect.Kind
	if isPtr {
		dereferenceFieldType = fieldType.Elem().Elem().Kind()
	} else {
		dereferenceFieldType = fieldType.Elem().Kind()
	}
	switch dereferenceFieldType {
	case reflect.String:
		if !isPtr {
			for i, stringVal := range v {
				slice.Index(i).SetString(stringVal.(string))
			}
			reflect.ValueOf(input).Elem().Field(index).Set(slice)
		} else {
			tmp := reflect.New(fieldType.Elem())
			for i, stringVal := range v {
				slice.Index(i).SetString(stringVal.(string))
			}
			tmp.Elem().Set(slice)
			reflect.ValueOf(input).Elem().Field(index).Set(tmp)
		}

	case reflect.Int64:
		if !isPtr {
			for i, iVal := range v {
				slice.Index(i).SetInt(int64(iVal.(int)))
			}
			reflect.ValueOf(input).Elem().Field(index).Set(slice)
		} else {
			tmp := reflect.New(fieldType.Elem())
			for i, iVal := range v {
				slice.Index(i).SetInt(int64(iVal.(int)))
			}
			tmp.Elem().Set(slice)
			reflect.ValueOf(input).Elem().Field(index).Set(tmp)
		}

	case reflect.Float64:
		if !isPtr {
			for i, fVal := range v {
				slice.Index(i).SetFloat(fVal.(float64))
			}
			reflect.ValueOf(input).Elem().Field(index).Set(slice)
		} else {
			tmp := reflect.New(fieldType.Elem())
			for i, fVal := range v {
				slice.Index(i).SetFloat(fVal.(float64))
			}
			tmp.Elem().Set(slice)
			reflect.ValueOf(input).Elem().Field(index).Set(tmp)
		}

	case reflect.Bool:
		if !isPtr {
			for i, bVal := range v {
				slice.Index(i).SetBool(bVal.(bool))
			}
			reflect.ValueOf(input).Elem().Field(index).Set(slice)
		} else {
			tmp := reflect.New(fieldType.Elem())
			for i, bVal := range v {
				slice.Index(i).SetBool(bVal.(bool))
			}
			tmp.Elem().Set(slice)
			reflect.ValueOf(input).Elem().Field(index).Set(tmp)
		}

	default:
		n := reflect.ValueOf(input).Elem().Field(index)
		if n.Kind() == reflect.Pointer {
			tmp := reflect.New(fieldType.Elem())
			valueToSet := reflect.MakeSlice(tmp.Elem().Type(), 0, 0)
			for _, mapVal := range v {
				if test, ok := mapVal.(map[string]interface{}); ok && test != nil {
					elem := reflect.New(fieldType.Elem().Elem())
					debugLogger.Infof("element %s", elem.String())
					for j := 0; j < elem.Type().Elem().NumField(); j++ {
						nestedField := elem.Type().Elem().Field(j)
						debugLogger.Infof("nestedField Name: '%s', Tags: '%+v'", nestedField.Name, nestedField.Tag)

						structTags, err := parseStructTags(nestedField.Tag)
						if err != nil {
							return fmt.Errorf("parsing struct tags for nested field `%s`: %+v", nestedField.Name, err)
						}

						if structTags != nil {
							nestedTFSchemaValue := test[structTags.hclPath]
							if err := setValue(elem.Interface(), nestedTFSchemaValue, j, fieldName, debugLogger); err != nil {
								return err
							}
						}
					}

					if !elem.CanSet() {
						elem = elem.Elem()
					}

					if valueToSet.Kind() == reflect.Ptr {
						valueToSet.Elem().Set(reflect.Append(valueToSet.Elem(), elem))
					} else {
						valueToSet = reflect.Append(valueToSet, elem)
					}

					debugLogger.Infof("value to set type after changes %s", valueToSet.Type().String())
				}
			}

			tmp.Elem().Set(valueToSet)
			n.Set(tmp)
		} else {
			valueToSet := reflect.MakeSlice(n.Type(), 0, 0)
			debugLogger.Infof("List Type '%s'", valueToSet.Type().String())

			for _, mapVal := range v {
				if test, ok := mapVal.(map[string]interface{}); ok && test != nil {
					elem := reflect.New(fieldType.Elem())
					debugLogger.Infof("element '%s'", elem.String())
					for j := 0; j < elem.Type().Elem().NumField(); j++ {
						nestedField := elem.Type().Elem().Field(j)
						debugLogger.Infof("nestedField Name '%s', Tags: '%+v'", nestedField.Name, nestedField.Tag)

						structTags, err := parseStructTags(nestedField.Tag)
						if err != nil {
							return fmt.Errorf("parsing struct tags for nested field '%s': %+v", nestedField.Name, err)
						}

						if structTags != nil {
							nestedTFSchemaValue := test[structTags.hclPath]
							if err := setValue(elem.Interface(), nestedTFSchemaValue, j, nestedField.Name, debugLogger); err != nil {
								return err
							}
						}
					}

					if !elem.CanSet() {
						elem = elem.Elem()
					}

					if valueToSet.Kind() == reflect.Ptr {
						valueToSet.Elem().Set(reflect.Append(valueToSet.Elem(), elem))
					} else {
						valueToSet = reflect.Append(valueToSet, elem)
					}

					debugLogger.Infof("value to set type after changes '%s'", valueToSet.Type().String())
				}
			}

			valueToSet = reflect.Indirect(valueToSet)
			fieldToSet := reflect.ValueOf(input).Elem().Field(index)
			fieldToSet.Set(reflect.Indirect(valueToSet))
		}
	}

	return nil
}
